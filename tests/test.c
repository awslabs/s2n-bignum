// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0 OR ISC OR MIT-0

// ***************************************************************************
// Do some rudimentary unit testing of s2n-bignum functions against
// simple and straightforward generic C reference code. This is a
// useful complement to the formal proofs, handy for catching basic
// problems quickly and for providing an extra layer of assurance
// against disparities between the formal model and the real world.
// ***************************************************************************

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <math.h>
#include <time.h>
#include <string.h>

#if (__linux__)
  #include <alloca.h>
#endif

// Prototypes for the assembler implementations

#include "../include/s2n-bignum.h"

// Functions for detecting architectures and instruction sets

#include "arch.h"

// Some big static buffers (need them big enough for largest test)

#define BUFFERSIZE 65536

static uint64_t b0[BUFFERSIZE];
static uint64_t b1[BUFFERSIZE];
static uint64_t b2[BUFFERSIZE];
static uint64_t b3[BUFFERSIZE];
static uint64_t b4[BUFFERSIZE];
static uint64_t b5[BUFFERSIZE];
static uint64_t b6[BUFFERSIZE];
static uint64_t b7[BUFFERSIZE];
static uint64_t b8[BUFFERSIZE];
static uint64_t b9[BUFFERSIZE];
static uint64_t b10[BUFFERSIZE];
static uint64_t b11[BUFFERSIZE];
static uint64_t b12[BUFFERSIZE];

static uint8_t bb1[BUFFERSIZE];
static uint8_t bb2[BUFFERSIZE];
static uint8_t bb3[BUFFERSIZE];
static uint8_t bb4[BUFFERSIZE];

// What to test, default number of tests, verbosity of output

#define VERBOSE 1
#define TESTS 100
#define MAXSIZE 35

// The actual number of tests, from input parameter or default to TESTS

static int tests = TESTS;

// ***************************************************************************
// Random number generation
// ***************************************************************************

// Source of random 64-bit numbers with bit density
// 0 = all zeros, 32 = "average", 64 = all ones
// Then a generic one with the density itself randomized

uint64_t random64d(int density)
{ int i;
  uint64_t r = 0, b = 0;
  for (i = 0; i < 64; i++)
   { b = ((rand() & 0x3F) < density);
     r = (r + r) + b;
   }
  return r;
}

uint64_t random64(void)
{ int d = ((unsigned) rand() & 0xFFFF) % 65;
  return random64d(d);
}

// Fill size-k bignum array with random digits, again with density option

void random_bignumd(uint64_t k,uint64_t *a,int density)
{ uint64_t i;
  for (i = 0; i < k; ++i) a[i] = random64d(density);
}

void random_bignum(uint64_t k,uint64_t *a)
{ int d = ((unsigned) rand() & 0xFFFF) % 65;
  random_bignumd(k,a,d);
}

void random_sparse_bignum(uint64_t k,uint64_t *a)
{ uint64_t i;
  int d = ((unsigned) rand() & 0xFFFF) % 65;
  for (i = 0; i < k; ++i)
   { if (((unsigned) rand() & 0xFFFF) % 100 <= 1)
       a[i] = random64d(d);
     else a[i] = 0;
   }
}

// Constants for the ML-KEM NTT and INTT functions and mulcache.
// These are taken with no semantic change from mlkem-native
// file "mlkem/native/aarch64/src/aarch64_zetas.c"

static int16_t ntt_zetas_layer01234[80] =
{
    -1600, -15749, -749,  -7373,  -40,   -394,   -687, -6762, 630,  6201,
    -1432, -14095, 848,   8347,   0,     0,      1062, 10453, 296,  2914,
    -882,  -8682,  0,     0,      -1410, -13879, 1339, 13180, 1476, 14529,
    0,     0,      193,   1900,   -283,  -2786,  56,   551,   0,    0,
    797,   7845,   -1089, -10719, 1333,  13121,  0,    0,     -543, -5345,
    1426,  14036,  -1235, -12156, 0,     0,      -69,  -679,  535,  5266,
    -447,  -4400,  0,     0,      569,   5601,   -936, -9213, -450, -4429,
    0,     0,      -1583, -15582, -1355, -13338, 821,  8081,  0,    0
};

static int16_t ntt_zetas_layer56[384] =
{
    289,    289,    331,    331,    -76,    -76,    -1573,  -1573,  2845,
    2845,   3258,   3258,   -748,   -748,   -15483, -15483, 17,     17,
    583,    583,    1637,   1637,   -1041,  -1041,  167,    167,    5739,
    5739,   16113,  16113,  -10247, -10247, -568,   -568,   -680,   -680,
    723,    723,    1100,   1100,   -5591,  -5591,  -6693,  -6693,  7117,
    7117,   10828,  10828,  1197,   1197,   -1025,  -1025,  -1052,  -1052,
    -1274,  -1274,  11782,  11782,  -10089, -10089, -10355, -10355, -12540,
    -12540, 1409,   1409,   -48,    -48,    756,    756,    -314,   -314,
    13869,  13869,  -472,   -472,   7441,   7441,   -3091,  -3091,  -667,
    -667,   233,    233,    -1173,  -1173,  -279,   -279,   -6565,  -6565,
    2293,   2293,   -11546, -11546, -2746,  -2746,  650,    650,    -1352,
    -1352,  -816,   -816,   632,    632,    6398,   6398,   -13308, -13308,
    -8032,  -8032,  6221,   6221,   -1626,  -1626,  -540,   -540,   -1482,
    -1482,  1461,   1461,   -16005, -16005, -5315,  -5315,  -14588, -14588,
    14381,  14381,  1651,   1651,   -1540,  -1540,  952,    952,    -642,
    -642,   16251,  16251,  -15159, -15159, 9371,   9371,   -6319,  -6319,
    -464,   -464,   33,     33,     1320,   1320,   -1414,  -1414,  -4567,
    -4567,  325,    325,    12993,  12993,  -13918, -13918, 939,    939,
    -892,   -892,   733,    733,    268,    268,    9243,   9243,   -8780,
    -8780,  7215,   7215,   2638,   2638,   -1021,  -1021,  -941,   -941,
    -992,   -992,   641,    641,    -10050, -10050, -9262,  -9262,  -9764,
    -9764,  6309,   6309,   -1010,  -1010,  1435,   1435,   807,    807,
    452,    452,    -9942,  -9942,  14125,  14125,  7943,   7943,   4449,
    4449,   1584,   1584,   -1292,  -1292,  375,    375,    -1239,  -1239,
    15592,  15592,  -12717, -12717, 3691,   3691,   -12196, -12196, -1031,
    -1031,  -109,   -109,   -780,   -780,   1645,   1645,   -10148, -10148,
    -1073,  -1073,  -7678,  -7678,  16192,  16192,  1438,   1438,   -461,
    -461,   1534,   1534,   -927,   -927,   14155,  14155,  -4538,  -4538,
    15099,  15099,  -9125,  -9125,  1063,   1063,   -556,   -556,   -1230,
    -1230,  -863,   -863,   10463,  10463,  -5473,  -5473,  -12107, -12107,
    -8495,  -8495,  319,    319,    757,    757,    561,    561,    -735,
    -735,   3140,   3140,   7451,   7451,   5522,   5522,   -7235,  -7235,
    -682,   -682,   -712,   -712,   1481,   1481,   648,    648,    -6713,
    -6713,  -7008,  -7008,  14578,  14578,  6378,   6378,   -525,   -525,
    403,    403,    1143,   1143,   -554,   -554,   -5168,  -5168,  3967,
    3967,   11251,  11251,  -5453,  -5453,  1092,   1092,   1026,   1026,
    -1179,  -1179,  886,    886,    10749,  10749,  10099,  10099,  -11605,
    -11605, 8721,   8721,   -855,   -855,   -219,   -219,   1227,   1227,
    910,    910,    -8416,  -8416,  -2156,  -2156,  12078,  12078,  8957,
    8957,   -1607,  -1607,  -1455,  -1455,  -1219,  -1219,  885,    885,
    -15818, -15818, -14322, -14322, -11999, -11999, 8711,   8711,   1212,
    1212,   1029,   1029,   -394,   -394,   -1175,  -1175,  11930,  11930,
    10129,  10129,  -3878,  -3878,  -11566, -11566
};

static int16_t intt_zetas_layer01234[80] =
{
    1583,  15582,  -821,  -8081,  1355,  13338,  0,     0,      -569,  -5601,
    450,   4429,   936,   9213,   0,     0,      69,    679,    447,   4400,
    -535,  -5266,  0,     0,      543,   5345,   1235,  12156,  -1426, -14036,
    0,     0,      -797,  -7845,  -1333, -13121, 1089,  10719,  0,     0,
    -193,  -1900,  -56,   -551,   283,   2786,   0,     0,      1410,  13879,
    -1476, -14529, -1339, -13180, 0,     0,      -1062, -10453, 882,   8682,
    -296,  -2914,  0,     0,      1600,  15749,  40,    394,    749,   7373,
    -848,  -8347,  1432,  14095,  -630,  -6201,  687,   6762,   0,     0
};

static int16_t intt_zetas_layer56[384] =
{
    -910,   -910,   -1227,  -1227,  219,    219,    855,    855,    -8957,
    -8957,  -12078, -12078, 2156,   2156,   8416,   8416,   1175,   1175,
    394,    394,    -1029,  -1029,  -1212,  -1212,  11566,  11566,  3878,
    3878,   -10129, -10129, -11930, -11930, -885,   -885,   1219,   1219,
    1455,   1455,   1607,   1607,   -8711,  -8711,  11999,  11999,  14322,
    14322,  15818,  15818,  -648,   -648,   -1481,  -1481,  712,    712,
    682,    682,    -6378,  -6378,  -14578, -14578, 7008,   7008,   6713,
    6713,   -886,   -886,   1179,   1179,   -1026,  -1026,  -1092,  -1092,
    -8721,  -8721,  11605,  11605,  -10099, -10099, -10749, -10749, 554,
    554,    -1143,  -1143,  -403,   -403,   525,    525,    5453,   5453,
    -11251, -11251, -3967,  -3967,  5168,   5168,   927,    927,    -1534,
    -1534,  461,    461,    -1438,  -1438,  9125,   9125,   -15099, -15099,
    4538,   4538,   -14155, -14155, 735,    735,    -561,   -561,   -757,
    -757,   -319,   -319,   7235,   7235,   -5522,  -5522,  -7451,  -7451,
    -3140,  -3140,  863,    863,    1230,   1230,   556,    556,    -1063,
    -1063,  8495,   8495,   12107,  12107,  5473,   5473,   -10463, -10463,
    -452,   -452,   -807,   -807,   -1435,  -1435,  1010,   1010,   -4449,
    -4449,  -7943,  -7943,  -14125, -14125, 9942,   9942,   -1645,  -1645,
    780,    780,    109,    109,    1031,   1031,   -16192, -16192, 7678,
    7678,   1073,   1073,   10148,  10148,  1239,   1239,   -375,   -375,
    1292,   1292,   -1584,  -1584,  12196,  12196,  -3691,  -3691,  12717,
    12717,  -15592, -15592, 1414,   1414,   -1320,  -1320,  -33,    -33,
    464,    464,    13918,  13918,  -12993, -12993, -325,   -325,   4567,
    4567,   -641,   -641,   992,    992,    941,    941,    1021,   1021,
    -6309,  -6309,  9764,   9764,   9262,   9262,   10050,  10050,  -268,
    -268,   -733,   -733,   892,    892,    -939,   -939,   -2638,  -2638,
    -7215,  -7215,  8780,   8780,   -9243,  -9243,  -632,   -632,   816,
    816,    1352,   1352,   -650,   -650,   -6221,  -6221,  8032,   8032,
    13308,  13308,  -6398,  -6398,  642,    642,    -952,   -952,   1540,
    1540,   -1651,  -1651,  6319,   6319,   -9371,  -9371,  15159,  15159,
    -16251, -16251, -1461,  -1461,  1482,   1482,   540,    540,    1626,
    1626,   -14381, -14381, 14588,  14588,  5315,   5315,   16005,  16005,
    1274,   1274,   1052,   1052,   1025,   1025,   -1197,  -1197,  12540,
    12540,  10355,  10355,  10089,  10089,  -11782, -11782, 279,    279,
    1173,   1173,   -233,   -233,   667,    667,    2746,   2746,   11546,
    11546,  -2293,  -2293,  6565,   6565,   314,    314,    -756,   -756,
    48,     48,     -1409,  -1409,  3091,   3091,   -7441,  -7441,  472,
    472,    -13869, -13869, 1573,   1573,   76,     76,     -331,   -331,
    -289,   -289,   15483,  15483,  748,    748,    -3258,  -3258,  -2845,
    -2845,  -1100,  -1100,  -723,   -723,   680,    680,    568,    568,
    -10828, -10828, -7117,  -7117,  6693,   6693,   5591,   5591,   1041,
    1041,   -1637,  -1637,  -583,   -583,   -17,    -17,    10247,  10247,
    -16113, -16113, -5739,  -5739,  -167,   -167
};

static int16_t mulcache_zetas[128] =
{
    17,    -17,   -568,  568,  583,   -583,  -680,  680,   1637, -1637, 723,
    -723,  -1041, 1041,  1100, -1100, 1409,  -1409, -667,  667,  -48,   48,
    233,   -233,  756,   -756, -1173, 1173,  -314,  314,   -279, 279,   -1626,
    1626,  1651,  -1651, -540, 540,   -1540, 1540,  -1482, 1482, 952,   -952,
    1461,  -1461, -642,  642,  939,   -939,  -1021, 1021,  -892, 892,   -941,
    941,   733,   -733,  -992, 992,   268,   -268,  641,   -641, 1584,  -1584,
    -1031, 1031,  -1292, 1292, -109,  109,   375,   -375,  -780, 780,   -1239,
    1239,  1645,  -1645, 1063, -1063, 319,   -319,  -556,  556,  757,   -757,
    -1230, 1230,  561,   -561, -863,  863,   -735,  735,   -525, 525,   1092,
    -1092, 403,   -403,  1026, -1026, 1143,  -1143, -1179, 1179, -554,  554,
    886,   -886,  -1607, 1607, 1212,  -1212, -1455, 1455,  1029, -1029, -1219,
    1219,  -394,  394,   885,  -885,  -1175, 1175
};

static int16_t mulcache_zetas_twisted[128] =
{
    167,    -167,  -5591,  5591,   5739,   -5739,  -6693,  6693,   16113,
    -16113, 7117,  -7117,  -10247, 10247,  10828,  -10828, 13869,  -13869,
    -6565,  6565,  -472,   472,    2293,   -2293,  7441,   -7441,  -11546,
    11546,  -3091, 3091,   -2746,  2746,   -16005, 16005,  16251,  -16251,
    -5315,  5315,  -15159, 15159,  -14588, 14588,  9371,   -9371,  14381,
    -14381, -6319, 6319,   9243,   -9243,  -10050, 10050,  -8780,  8780,
    -9262,  9262,  7215,   -7215,  -9764,  9764,   2638,   -2638,  6309,
    -6309,  15592, -15592, -10148, 10148,  -12717, 12717,  -1073,  1073,
    3691,   -3691, -7678,  7678,   -12196, 12196,  16192,  -16192, 10463,
    -10463, 3140,  -3140,  -5473,  5473,   7451,   -7451,  -12107, 12107,
    5522,   -5522, -8495,  8495,   -7235,  7235,   -5168,  5168,   10749,
    -10749, 3967,  -3967,  10099,  -10099, 11251,  -11251, -11605, 11605,
    -5453,  5453,  8721,   -8721,  -15818, 15818,  11930,  -11930, -14322,
    14322,  10129, -10129, -11999, 11999,  -3878,  3878,   8711,   -8711,
    -11566, 11566
};

// Constant table for ML-KEM rejection sampling

uint8_t mlkem_rej_uniform_table[] =
{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 0
  0,  1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 1
  2,  3,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 2
  0,  1,  2,  3,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 3
  4,  5,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 4
  0,  1,  4,  5,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 5
  2,  3,  4,  5,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 6
  0,  1,  2,  3,  4,  5,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 7
  6,  7,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 8
  0,  1,  6,  7,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 9
  2,  3,  6,  7,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 10
  0,  1,  2,  3,  6,  7,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 11
  4,  5,  6,  7,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 12
  0,  1,  4,  5,  6,  7,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 13
  2,  3,  4,  5,  6,  7,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 14
  0,  1,  2,  3,  4,  5,  6,  7,  -1, -1, -1, -1, -1, -1, -1, -1,  // 15
  8,  9,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 16
  0,  1,  8,  9,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 17
  2,  3,  8,  9,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 18
  0,  1,  2,  3,  8,  9,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 19
  4,  5,  8,  9,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 20
  0,  1,  4,  5,  8,  9,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 21
  2,  3,  4,  5,  8,  9,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 22
  0,  1,  2,  3,  4,  5,  8,  9,  -1, -1, -1, -1, -1, -1, -1, -1,  // 23
  6,  7,  8,  9,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 24
  0,  1,  6,  7,  8,  9,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 25
  2,  3,  6,  7,  8,  9,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 26
  0,  1,  2,  3,  6,  7,  8,  9,  -1, -1, -1, -1, -1, -1, -1, -1,  // 27
  4,  5,  6,  7,  8,  9,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 28
  0,  1,  4,  5,  6,  7,  8,  9,  -1, -1, -1, -1, -1, -1, -1, -1,  // 29
  2,  3,  4,  5,  6,  7,  8,  9,  -1, -1, -1, -1, -1, -1, -1, -1,  // 30
  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  -1, -1, -1, -1, -1, -1,  // 31
  10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 32
  0,  1,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 33
  2,  3,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 34
  0,  1,  2,  3,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 35
  4,  5,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 36
  0,  1,  4,  5,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 37
  2,  3,  4,  5,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 38
  0,  1,  2,  3,  4,  5,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1,  // 39
  6,  7,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 40
  0,  1,  6,  7,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 41
  2,  3,  6,  7,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 42
  0,  1,  2,  3,  6,  7,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1,  // 43
  4,  5,  6,  7,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 44
  0,  1,  4,  5,  6,  7,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1,  // 45
  2,  3,  4,  5,  6,  7,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1,  // 46
  0,  1,  2,  3,  4,  5,  6,  7,  10, 11, -1, -1, -1, -1, -1, -1,  // 47
  8,  9,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 48
  0,  1,  8,  9,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 49
  2,  3,  8,  9,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 50
  0,  1,  2,  3,  8,  9,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1,  // 51
  4,  5,  8,  9,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 52
  0,  1,  4,  5,  8,  9,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1,  // 53
  2,  3,  4,  5,  8,  9,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1,  // 54
  0,  1,  2,  3,  4,  5,  8,  9,  10, 11, -1, -1, -1, -1, -1, -1,  // 55
  6,  7,  8,  9,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 56
  0,  1,  6,  7,  8,  9,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1,  // 57
  2,  3,  6,  7,  8,  9,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1,  // 58
  0,  1,  2,  3,  6,  7,  8,  9,  10, 11, -1, -1, -1, -1, -1, -1,  // 59
  4,  5,  6,  7,  8,  9,  10, 11, -1, -1, -1, -1, -1, -1, -1, -1,  // 60
  0,  1,  4,  5,  6,  7,  8,  9,  10, 11, -1, -1, -1, -1, -1, -1,  // 61
  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, -1, -1, -1, -1, -1, -1,  // 62
  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, -1, -1, -1, -1,  // 63
  12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 64
  0,  1,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 65
  2,  3,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 66
  0,  1,  2,  3,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 67
  4,  5,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 68
  0,  1,  4,  5,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 69
  2,  3,  4,  5,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 70
  0,  1,  2,  3,  4,  5,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 71
  6,  7,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 72
  0,  1,  6,  7,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 73
  2,  3,  6,  7,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 74
  0,  1,  2,  3,  6,  7,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 75
  4,  5,  6,  7,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 76
  0,  1,  4,  5,  6,  7,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 77
  2,  3,  4,  5,  6,  7,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 78
  0,  1,  2,  3,  4,  5,  6,  7,  12, 13, -1, -1, -1, -1, -1, -1,  // 79
  8,  9,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 80
  0,  1,  8,  9,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 81
  2,  3,  8,  9,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 82
  0,  1,  2,  3,  8,  9,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 83
  4,  5,  8,  9,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 84
  0,  1,  4,  5,  8,  9,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 85
  2,  3,  4,  5,  8,  9,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 86
  0,  1,  2,  3,  4,  5,  8,  9,  12, 13, -1, -1, -1, -1, -1, -1,  // 87
  6,  7,  8,  9,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 88
  0,  1,  6,  7,  8,  9,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 89
  2,  3,  6,  7,  8,  9,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 90
  0,  1,  2,  3,  6,  7,  8,  9,  12, 13, -1, -1, -1, -1, -1, -1,  // 91
  4,  5,  6,  7,  8,  9,  12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 92
  0,  1,  4,  5,  6,  7,  8,  9,  12, 13, -1, -1, -1, -1, -1, -1,  // 93
  2,  3,  4,  5,  6,  7,  8,  9,  12, 13, -1, -1, -1, -1, -1, -1,  // 94
  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  12, 13, -1, -1, -1, -1,  // 95
  10, 11, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 96
  0,  1,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 97
  2,  3,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 98
  0,  1,  2,  3,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 99
  4,  5,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 100
  0,  1,  4,  5,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 101
  2,  3,  4,  5,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 102
  0,  1,  2,  3,  4,  5,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1,  // 103
  6,  7,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 104
  0,  1,  6,  7,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 105
  2,  3,  6,  7,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 106
  0,  1,  2,  3,  6,  7,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1,  // 107
  4,  5,  6,  7,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 108
  0,  1,  4,  5,  6,  7,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1,  // 109
  2,  3,  4,  5,  6,  7,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1,  // 110
  0,  1,  2,  3,  4,  5,  6,  7,  10, 11, 12, 13, -1, -1, -1, -1,  // 111
  8,  9,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 112
  0,  1,  8,  9,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 113
  2,  3,  8,  9,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 114
  0,  1,  2,  3,  8,  9,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1,  // 115
  4,  5,  8,  9,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 116
  0,  1,  4,  5,  8,  9,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1,  // 117
  2,  3,  4,  5,  8,  9,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1,  // 118
  0,  1,  2,  3,  4,  5,  8,  9,  10, 11, 12, 13, -1, -1, -1, -1,  // 119
  6,  7,  8,  9,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1,  // 120
  0,  1,  6,  7,  8,  9,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1,  // 121
  2,  3,  6,  7,  8,  9,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1,  // 122
  0,  1,  2,  3,  6,  7,  8,  9,  10, 11, 12, 13, -1, -1, -1, -1,  // 123
  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, -1, -1, -1, -1, -1, -1,  // 124
  0,  1,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, -1, -1, -1, -1,  // 125
  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, -1, -1, -1, -1,  // 126
  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, -1, -1,  // 127
  14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 128
  0,  1,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 129
  2,  3,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 130
  0,  1,  2,  3,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 131
  4,  5,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 132
  0,  1,  4,  5,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 133
  2,  3,  4,  5,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 134
  0,  1,  2,  3,  4,  5,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 135
  6,  7,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 136
  0,  1,  6,  7,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 137
  2,  3,  6,  7,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 138
  0,  1,  2,  3,  6,  7,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 139
  4,  5,  6,  7,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 140
  0,  1,  4,  5,  6,  7,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 141
  2,  3,  4,  5,  6,  7,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 142
  0,  1,  2,  3,  4,  5,  6,  7,  14, 15, -1, -1, -1, -1, -1, -1,  // 143
  8,  9,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 144
  0,  1,  8,  9,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 145
  2,  3,  8,  9,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 146
  0,  1,  2,  3,  8,  9,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 147
  4,  5,  8,  9,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 148
  0,  1,  4,  5,  8,  9,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 149
  2,  3,  4,  5,  8,  9,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 150
  0,  1,  2,  3,  4,  5,  8,  9,  14, 15, -1, -1, -1, -1, -1, -1,  // 151
  6,  7,  8,  9,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 152
  0,  1,  6,  7,  8,  9,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 153
  2,  3,  6,  7,  8,  9,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 154
  0,  1,  2,  3,  6,  7,  8,  9,  14, 15, -1, -1, -1, -1, -1, -1,  // 155
  4,  5,  6,  7,  8,  9,  14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 156
  0,  1,  4,  5,  6,  7,  8,  9,  14, 15, -1, -1, -1, -1, -1, -1,  // 157
  2,  3,  4,  5,  6,  7,  8,  9,  14, 15, -1, -1, -1, -1, -1, -1,  // 158
  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  14, 15, -1, -1, -1, -1,  // 159
  10, 11, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 160
  0,  1,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 161
  2,  3,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 162
  0,  1,  2,  3,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 163
  4,  5,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 164
  0,  1,  4,  5,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 165
  2,  3,  4,  5,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 166
  0,  1,  2,  3,  4,  5,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1,  // 167
  6,  7,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 168
  0,  1,  6,  7,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 169
  2,  3,  6,  7,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 170
  0,  1,  2,  3,  6,  7,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1,  // 171
  4,  5,  6,  7,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 172
  0,  1,  4,  5,  6,  7,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1,  // 173
  2,  3,  4,  5,  6,  7,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1,  // 174
  0,  1,  2,  3,  4,  5,  6,  7,  10, 11, 14, 15, -1, -1, -1, -1,  // 175
  8,  9,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 176
  0,  1,  8,  9,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 177
  2,  3,  8,  9,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 178
  0,  1,  2,  3,  8,  9,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1,  // 179
  4,  5,  8,  9,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 180
  0,  1,  4,  5,  8,  9,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1,  // 181
  2,  3,  4,  5,  8,  9,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1,  // 182
  0,  1,  2,  3,  4,  5,  8,  9,  10, 11, 14, 15, -1, -1, -1, -1,  // 183
  6,  7,  8,  9,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 184
  0,  1,  6,  7,  8,  9,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1,  // 185
  2,  3,  6,  7,  8,  9,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1,  // 186
  0,  1,  2,  3,  6,  7,  8,  9,  10, 11, 14, 15, -1, -1, -1, -1,  // 187
  4,  5,  6,  7,  8,  9,  10, 11, 14, 15, -1, -1, -1, -1, -1, -1,  // 188
  0,  1,  4,  5,  6,  7,  8,  9,  10, 11, 14, 15, -1, -1, -1, -1,  // 189
  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 14, 15, -1, -1, -1, -1,  // 190
  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 14, 15, -1, -1,  // 191
  12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 192
  0,  1,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 193
  2,  3,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 194
  0,  1,  2,  3,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 195
  4,  5,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 196
  0,  1,  4,  5,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 197
  2,  3,  4,  5,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 198
  0,  1,  2,  3,  4,  5,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 199
  6,  7,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 200
  0,  1,  6,  7,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 201
  2,  3,  6,  7,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 202
  0,  1,  2,  3,  6,  7,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 203
  4,  5,  6,  7,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 204
  0,  1,  4,  5,  6,  7,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 205
  2,  3,  4,  5,  6,  7,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 206
  0,  1,  2,  3,  4,  5,  6,  7,  12, 13, 14, 15, -1, -1, -1, -1,  // 207
  8,  9,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 208
  0,  1,  8,  9,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 209
  2,  3,  8,  9,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 210
  0,  1,  2,  3,  8,  9,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 211
  4,  5,  8,  9,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 212
  0,  1,  4,  5,  8,  9,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 213
  2,  3,  4,  5,  8,  9,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 214
  0,  1,  2,  3,  4,  5,  8,  9,  12, 13, 14, 15, -1, -1, -1, -1,  // 215
  6,  7,  8,  9,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 216
  0,  1,  6,  7,  8,  9,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 217
  2,  3,  6,  7,  8,  9,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 218
  0,  1,  2,  3,  6,  7,  8,  9,  12, 13, 14, 15, -1, -1, -1, -1,  // 219
  4,  5,  6,  7,  8,  9,  12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 220
  0,  1,  4,  5,  6,  7,  8,  9,  12, 13, 14, 15, -1, -1, -1, -1,  // 221
  2,  3,  4,  5,  6,  7,  8,  9,  12, 13, 14, 15, -1, -1, -1, -1,  // 222
  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  12, 13, 14, 15, -1, -1,  // 223
  10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 224
  0,  1,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 225
  2,  3,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 226
  0,  1,  2,  3,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 227
  4,  5,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 228
  0,  1,  4,  5,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 229
  2,  3,  4,  5,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 230
  0,  1,  2,  3,  4,  5,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1,  // 231
  6,  7,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 232
  0,  1,  6,  7,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 233
  2,  3,  6,  7,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 234
  0,  1,  2,  3,  6,  7,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1,  // 235
  4,  5,  6,  7,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 236
  0,  1,  4,  5,  6,  7,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1,  // 237
  2,  3,  4,  5,  6,  7,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1,  // 238
  0,  1,  2,  3,  4,  5,  6,  7,  10, 11, 12, 13, 14, 15, -1, -1,  // 239
  8,  9,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1,  // 240
  0,  1,  8,  9,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 241
  2,  3,  8,  9,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 242
  0,  1,  2,  3,  8,  9,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1,  // 243
  4,  5,  8,  9,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 244
  0,  1,  4,  5,  8,  9,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1,  // 245
  2,  3,  4,  5,  8,  9,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1,  // 246
  0,  1,  2,  3,  4,  5,  8,  9,  10, 11, 12, 13, 14, 15, -1, -1,  // 247
  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1,  // 248
  0,  1,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1,  // 249
  2,  3,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1,  // 250
  0,  1,  2,  3,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, -1, -1,  // 251
  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, -1, -1, -1, -1,  // 252
  0,  1,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, -1, -1,  // 253
  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, -1, -1,  // 254
  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15   // 255
};

// Constants for the ML-KEM NTT and INTT functions and mulcache.
// These are taken with no semantic change from mlkem-native
// file "mlkem/native/x86_64/src/consts.c"
static int16_t __attribute__((aligned(32))) mlkem_qdata[624] = {
   3854,   3340,   2826,   2312,   1798,   1284,    770,    256,
   3854,   3340,   2826,   2312,   1798,   1284,    770,    256,
      7,      0,      6,      0,      5,      0,      4,      0,
      3,      0,      2,      0,      1,      0,      0,      0,
  31498,  31498,  31498,  31498,   -758,   -758,   -758,   -758,
      0,      0,      0,      0,      0,      0,      0,      0,
  14745,  14745,  14745,  14745,  14745,  14745,  14745,  14745,
  14745,  14745,  14745,  14745,  14745,  14745,  14745,  14745,
   -359,   -359,   -359,   -359,   -359,   -359,   -359,   -359,
   -359,   -359,   -359,   -359,   -359,   -359,   -359,   -359,
  13525,  13525,  13525,  13525,  13525,  13525,  13525,  13525,
 -12402, -12402, -12402, -12402, -12402, -12402, -12402, -12402,
   1493,   1493,   1493,   1493,   1493,   1493,   1493,   1493,
   1422,   1422,   1422,   1422,   1422,   1422,   1422,   1422,
 -20907, -20907, -20907, -20907,  27758,  27758,  27758,  27758,
  -3799,  -3799,  -3799,  -3799, -15690, -15690, -15690, -15690,
   -171,   -171,   -171,   -171,    622,    622,    622,    622,
   1577,   1577,   1577,   1577,    182,    182,    182,    182,
  -5827,  -5827,  17363,  17363, -26360, -26360, -29057, -29057,
   5571,   5571,  -1102,  -1102,  21438,  21438, -26242, -26242,
    573,    573,  -1325,  -1325,    264,    264,    383,    383,
   -829,   -829,   1458,   1458,  -1602,  -1602,   -130,   -130,
  -5689,  -6516,   1496,  30967, -23565,  20179,  20710,  25080,
 -12796,  26616,  16064, -12442,   9134,   -650, -25986,  27837,
   1223,    652,   -552,   1015,  -1293,   1491,   -282,  -1544,
    516,     -8,   -320,   -666,  -1618,  -1162,    126,   1469,
   -335, -11477, -32227,  20494, -27738,    945, -14883,   6182,
  32010,  10631,  29175, -28762, -18486,  17560, -14430,  -5276,
  -1103,    555,  -1251,   1550,    422,    177,   -291,   1574,
   -246,   1159,   -777,   -602,  -1590,   -872,    418,   -156,
  11182,  13387, -14233, -21655,  13131,  -4587,  23092,   5493,
 -32502,  30317, -18741,  12639,  20100,  18525,  19529, -12619,
    430,    843,    871,    105,    587,   -235,   -460,   1653,
    778,   -147,   1483,   1119,    644,    349,    329,    -75,
    787,    787,    787,    787,    787,    787,    787,    787,
    787,    787,    787,    787,    787,    787,    787,    787,
  -1517,  -1517,  -1517,  -1517,  -1517,  -1517,  -1517,  -1517,
  -1517,  -1517,  -1517,  -1517,  -1517,  -1517,  -1517,  -1517,
  28191,  28191,  28191,  28191,  28191,  28191,  28191,  28191,
 -16694, -16694, -16694, -16694, -16694, -16694, -16694, -16694,
    287,    287,    287,    287,    287,    287,    287,    287,
    202,    202,    202,    202,    202,    202,    202,    202,
  10690,  10690,  10690,  10690,   1358,   1358,   1358,   1358,
 -11202, -11202, -11202, -11202,  31164,  31164,  31164,  31164,
    962,    962,    962,    962,  -1202,  -1202,  -1202,  -1202,
  -1474,  -1474,  -1474,  -1474,   1468,   1468,   1468,   1468,
 -28073, -28073,  24313,  24313, -10532, -10532,   8800,   8800,
  18426,  18426,   8859,   8859,  26675,  26675, -16163, -16163,
   -681,   -681,   1017,   1017,    732,    732,    608,    608,
  -1542,  -1542,    411,    411,   -205,   -205,  -1571,  -1571,
  19883, -28250, -15887,  -8898, -28309,   9075, -30199,  18249,
  13426,  14017, -29156, -12757,  16832,   4311, -24155, -17915,
   -853,    -90,   -271,    830,    107,  -1421,   -247,   -951,
   -398,    961,  -1508,   -725,    448,  -1065,    677,  -1275,
 -31183,  25435,  -7382,  24391, -20927,  10946,  24214,  16989,
  10335,  -7934, -22502,  10906,  31636,  28644,  23998, -17422,
    817,    603,   1322,  -1465,  -1215,   1218,   -874,  -1187,
  -1185,  -1278,  -1510,   -870,   -108,    996,    958,   1522,
  20297,   2146,  15355, -32384,  -6280, -14903, -11044,  14469,
 -21498, -20198,  23210, -17442, -23860, -20257,   7756,  23132,
   1097,    610,  -1285,    384,   -136,  -1335,    220,  -1659,
  -1530,    794,   -854,    478,   -308,    991,  -1460,   1628,
  -1103,    555,  -1251,   1550,    422,    177,   -291,   1574,
   -246,   1159,   -777,   -602,  -1590,   -872,    418,   -156,
    430,    843,    871,    105,    587,   -235,   -460,   1653,
    778,   -147,   1483,   1119,    644,    349,    329,    -75,
    817,    603,   1322,  -1465,  -1215,   1218,   -874,  -1187,
  -1185,  -1278,  -1510,   -870,   -108,    996,    958,   1522,
   1097,    610,  -1285,    384,   -136,  -1335,    220,  -1659,
  -1530,    794,   -854,    478,   -308,    991,  -1460,   1628,
   -335, -11477, -32227,  20494, -27738,    945, -14883,   6182,
  32010,  10631,  29175, -28762, -18486,  17560, -14430,  -5276,
  11182,  13387, -14233, -21655,  13131,  -4587,  23092,   5493,
 -32502,  30317, -18741,  12639,  20100,  18525,  19529, -12619,
 -31183,  25435,  -7382,  24391, -20927,  10946,  24214,  16989,
  10335,  -7934, -22502,  10906,  31636,  28644,  23998, -17422,
  20297,   2146,  15355, -32384,  -6280, -14903, -11044,  14469,
 -21498, -20198,  23210, -17442, -23860, -20257,   7756,  23132,
};

// ***************************************************************************
// ML-DSA zeta constants
// ***************************************************************************

// MLDSA zeta constants array (from mldsa-native/mldsa/zetas.inc)
// Used for C reference implementation
static int32_t mldsa_zetas[256] = {
         0,    25847, -2608894,  -518909,   237124,  -777960,  -876248,   466468,
   1826347,  2353451,  -359251, -2091905,  3119733, -2884855,  3111497,  2680103,
   2725464,  1024112, -1079900,  3585928,  -549488, -1119584,  2619752, -2108549,
  -2118186, -3859737, -1399561, -3277672,  1757237,   -19422,  4010497,   280005,
   2706023,    95776,  3077325,  3530437, -1661693, -3592148, -2537516,  3915439,
  -3861115, -3043716,  3574422, -2867647,  3539968,  -300467,  2348700,  -539299,
  -1699267, -1643818,  3505694, -3821735,  3507263, -2140649, -1600420,  3699596,
    811944,   531354,   954230,  3881043,  3900724, -2556880,  2071892, -2797779,
  -3930395, -1528703, -3677745, -3041255, -1452451,  3475950,  2176455, -1585221,
  -1257611,  1939314, -4083598, -1000202, -3190144, -3157330, -3632928,   126922,
   3412210,  -983419,  2147896,  2715295, -2967645, -3693493,  -411027, -2477047,
   -671102, -1228525,   -22981, -1308169,  -381987,  1349076,  1852771, -1430430,
  -3343383,   264944,   508951,  3097992,    44288, -1100098,   904516,  3958618,
  -3724342,    -8578,  1653064, -3249728,  2389356,  -210977,   759969, -1316856,
    189548, -3553272,  3159746, -1851402, -2409325,  -177440,  1315589,  1341330,
   1285669, -1584928,  -812732, -1439742, -3019102, -3881060, -3628969,  3839961,
   2091667,  3407706,  2316500,  3817976, -3342478,  2244091, -2446433, -3562462,
    266997,  2434439, -1235728,  3513181, -3520352, -3759364, -1197226, -3193378,
    900702,  1859098,   909542,   819034,   495491, -1613174,   -43260,  -522500,
   -655327, -3122442,  2031748,  3207046, -3556995,  -525098,  -768622, -3595838,
    342297,   286988, -2437823,  4108315,  3437287, -3342277,  1735879,   203044,
   2842341,  2691481, -2590150,  1265009,  4055324,  1247620,  2486353,  1595974,
  -3767016,  1250494,  2635921, -3548272, -2994039,  1869119,  1903435, -1050970,
  -1333058,  1237275, -3318210, -1430225,  -451100,  1312455,  3306115, -1962642,
  -1279661,  1917081, -2546312, -1374803,  1500165,   777191,  2235880,  3406031,
   -542412, -2831860, -1671176, -1846953, -2584293, -3724270,   594136, -3776993,
  -2013608,  2432395,  2454455, -164721,  1957272,  3369112,   185531, -1207385,
  -3183426,   162844,  1616392,  3014001,   810149,  1652634, -3694233, -1799107,
  -3038916,  3523897,  3866901,   269760,  2213111, -975884,  1717735,   472078,
   -426683,  1723600, -1803090,  1910376, -1667432, -1104333,  -260646, -3833893,
  -2939036, -2235985, -420899, -2286327,   183443, -976891,  1612842, -3545687,
  -554416,  3919660, -48306, -1362209,  3937738,  1400424, -846154,  1976782
};

// Complete AVX2 data structure for x86 MLDSA assembly (624 int32_t elements)
// Based on mldsa-native consts.c structure and reference Dilithium AVX2
// https://github.com/pq-crystals/dilithium/blob/master/avx2/consts.c
static int32_t __attribute__((aligned(32))) mldsa_avx2_data[624] = {
    // Offset 0-7: 8XQ (8 copies of MLDSA_Q = 8380417)
    8380417, 8380417, 8380417, 8380417, 8380417, 8380417, 8380417, 8380417,

    // Offset 8-15: 8XQINV (8 copies of MLDSA_QINV = 58728449)
    58728449, 58728449, 58728449, 58728449, 58728449, 58728449, 58728449, 58728449,

    // Offset 16-23: 8XDIV_QINV (8 copies of -8395782)
    -8395782, -8395782, -8395782, -8395782, -8395782, -8395782, -8395782, -8395782,

    // Offset 24-31: 8XDIV (8 copies of 41978)
    41978, 41978, 41978, 41978, 41978, 41978, 41978, 41978,

    // Offset 32-327: ZETAS_QINV (Montgomery form zetas, 296 elements)
    -151046689,
    1830765815, -1929875198, -1927777021, 1640767044, 1477910808, 1612161320, 1640734244, 308362795,
    308362795, 308362795, 308362795, -1815525077, -1815525077, -1815525077, -1815525077,
    -1374673747, -1374673747, -1374673747, -1374673747, -1091570561, -1091570561, -1091570561,
    -1091570561, -1929495947, -1929495947, -1929495947, -1929495947, 515185417, 515185417,
    515185417, 515185417, -285697463, -285697463, -285697463, -285697463, 625853735, 625853735,
    625853735, 625853735, 1727305304, 1727305304, 2082316400, 2082316400, -1364982364, -1364982364,
    858240904, 858240904, 1806278032, 1806278032, 222489248, 222489248, -346752664, -346752664,
    684667771, 684667771, 1654287830, 1654287830, -878576921, -878576921, -1257667337, -1257667337,
    -748618600, -748618600, 329347125, 329347125, 1837364258, 1837364258, -1443016191, -1443016191,
    -1170414139, -1170414139, -1846138265, -1631226336, -1404529459, 1838055109, 1594295555,
    -1076973524, -1898723372, -594436433, -202001019, -475984260, -561427818, 1797021249,
    -1061813248, 2059733581, -1661512036, -1104976547, -1750224323, -901666090, 418987550,
    1831915353, -1925356481, 992097815, 879957084, 2024403852, 1484874664, -1636082790, -285388938,
    -1983539117, -1495136972, -950076368, -1714807468, -952438995, -1574918427, 1350681039,
    -2143979939, 1599739335, -1285853323, -993005454, -1440787840, 568627424, -783134478,
    -588790216, 289871779, -1262003603, 2135294594, -1018755525, -889861155, 1665705315, 1321868265,
    1225434135, -1784632064, 666258756, 675310538, -1555941048, -1999506068, -1499481951,
    -695180180, -1375177022, 1777179795, 334803717, -178766299, -518252220, 1957047970, 1146323031,
    -654783359, -1974159335, 1651689966, 140455867, -1039411342, 1955560694, 1529189038,
    -2131021878, -247357819, 1518161567, -86965173, 1708872713, 1787797779, 1638590967, -120646188,
    -1669960606, -916321552, 1155548552, 2143745726, 1210558298, -1261461890, -318346816, 628664287,
    -1729304568, 1422575624, 1424130038, -1185330464, 235321234, 168022240, 1206536194, 985155484,
    -894060583, -898413, -1363460238, -605900043, 2027833504, 14253662, 1014493059, 863641633,
    1819892093, 2124962073, -1223601433, -1920467227, -1637785316, -1536588520, 694382729,
    235104446, -1045062172, 831969619, -300448763, 756955444, -260312805, 1554794072, 1339088280,
    -2040058690, -853476187, -2047270596, -1723816713, -1591599803, -440824168, 1119856484,
    1544891539, 155290192, -973777462, 991903578, 912367099, -44694137, 1176904444, -421552614,
    -818371958, 1747917558, -325927722, 908452108, 1851023419, -1176751719, -1354528380, -72690498,
    -314284737, 985022747, 963438279, -1078959975, 604552167, -1021949428, 608791570, 173440395,
    -2126092136, -1316619236, -1039370342, 6087993, -110126092, 565464272, -1758099917, -1600929361,
    879867909, -1809756372, 400711272, 1363007700, 30313375, -326425360, 1683520342, -517299994,
    2027935492, -1372618620, 128353682, -1123881663, 137583815, -635454918, -642772911, 45766801,
    671509323, -2070602178, 419615363, 1216882040, -270590488, -1276805128, 371462360, -1357098057,
    -384158533, 827959816, -596344473, 702390549, -279505433, -260424530, -71875110, -1208667171,
    -1499603926, 2036925262, -540420426, 746144248, -1420958686, 2032221021, 1904936414, 1257750362,
    1926727420, 1931587462, 1258381762, 885133339, 1629985060, 1967222129, 6363718, -1287922800,
    1136965286, 1779436847, 1116720494, 1042326957, 1405999311, 713994583, 940195359, -1542497137,
    2061661095, -883155599, 1726753853, -1547952704, 394851342, 283780712, 776003547, 1123958025,
    201262505, 1934038751, 374860238,

    // Offset 328-623: ZETAS (Regular zetas, 296 elements)
    -3975713, 25847, -2608894, -518909, 237124, -777960, -876248, 466468, 1826347, 1826347, 1826347,
    1826347, 2353451, 2353451, 2353451, 2353451, -359251, -359251, -359251, -359251, -2091905,
    -2091905, -2091905, -2091905, 3119733, 3119733, 3119733, 3119733, -2884855, -2884855, -2884855,
    -2884855, 3111497, 3111497, 3111497, 3111497, 2680103, 2680103, 2680103, 2680103, 2725464,
    2725464, 1024112, 1024112, -1079900, -1079900, 3585928, 3585928, -549488, -549488, -1119584,
    -1119584, 2619752, 2619752, -2108549, -2108549, -2118186, -2118186, -3859737, -3859737,
    -1399561, -1399561, -3277672, -3277672, 1757237, 1757237, -19422, -19422, 4010497, 4010497,
    280005, 280005, 2706023, 95776, 3077325, 3530437, -1661693, -3592148, -2537516, 3915439,
    -3861115, -3043716, 3574422, -2867647, 3539968, -300467, 2348700, -539299, -1699267, -1643818,
    3505694, -3821735, 3507263, -2140649, -1600420, 3699596, 811944, 531354, 954230, 3881043,
    3900724, -2556880, 2071892, -2797779, -3930395, -3677745, -1452451, 2176455, -1257611, -4083598,
    -3190144, -3632928, 3412210, 2147896, -2967645, -411027, -671102, -22981, -381987, 1852771,
    -3343383, 508951, 44288, 904516, -3724342, 1653064, 2389356, 759969, 189548, 3159746, -2409325,
    1315589, 1285669, -812732, -3019102, -3628969, -1528703, -3041255, 3475950, -1585221, 1939314,
    -1000202, -3157330, 126922, -983419, 2715295, -3693493, -2477047, -1228525, -1308169, 1349076,
    -1430430, 264944, 3097992, -1100098, 3958618, -8578, -3249728, -210977, -1316856, -3553272,
    -1851402, -177440, 1341330, -1584928, -1439742, -3881060, 3839961, 2091667, -3342478, 266997,
    -3520352, 900702, 495491, -655327, -3556995, 342297, 3437287, 2842341, 4055324, -3767016,
    -2994039, -1333058, -451100, -1279661, 1500165, -542412, -2584293, -2013608, 1957272, -3183426,
    810149, -3038916, 2213111, -426683, -1667432, -2939036, 183443, -554416, 3937738, 3407706,
    2244091, 2434439, -3759364, 1859098, -1613174, -3122442, -525098, 286988, -3342277, 2691481,
    1247620, 1250494, 1869119, 1237275, 1312455, 1917081, 777191, -2831860, -3724270, 2432395,
    3369112, 162844, 1652634, 3523897, -975884, 1723600, -1104333, -2235985, -976891, 3919660,
    1400424, 2316500, -2446433, -1235728, -1197226, 909542, -43260, 2031748, -768622, -2437823,
    1735879, -2590150, 2486353, 2635921, 1903435, -3318210, 3306115, -2546312, 2235880, -1671176,
    594136, 2454455, 185531, 1616392, -3694233, 3866901, 1717735, -1803090, -260646, -420899,
    1612842, -48306, -846154, 3817976, -3562462, 3513181, -3193378, 819034, -522500, 3207046,
    -3595838, 4108315, 203044, 1265009, 1595974, -3548272, -1050970, -1430225, -1962642, -1374803,
    3406031, -1846953, -3776993, -164721, -1207385, 3014001, -1799107, 269760, 472078, 1910376,
    -3833893, -2286327, -3545687, -1362209, 1976782
};

// ****************************************************************************
// Reference implementations, basic and stupid ones in C
// ****************************************************************************

// Some functions to do carry chains and high multiplies in C

#define hi32(x) ((x) >> 32)
#define lo32(x) ((x) & UINT64_C(0xFFFFFFFF))

uint64_t carryout2(uint64_t x,uint64_t y)
{ uint64_t z = x + y;
  return (uint64_t) ((z < x));
}

uint64_t carryout3(uint64_t x,uint64_t y,uint64_t c)
{ uint64_t w = x + y;
  return (uint64_t) (carryout2(x,y) || carryout2(w,c));
}

uint64_t borrowout2(uint64_t x,uint64_t y)
{ return (uint64_t) ((x < y));
}

uint64_t borrowout3(uint64_t x,uint64_t y,uint64_t b)
{ return (uint64_t) (b ? (x <= y) : (x < y));
}

uint64_t multop(uint64_t x,uint64_t y)
{
  uint64_t x1 = hi32(x);
  uint64_t x0 = lo32(x);
  uint64_t y1 = hi32(y);
  uint64_t y0 = lo32(y);

  uint64_t z0 = x0 * y0;
  uint64_t z1 = x0 * y1;
  uint64_t w1 = x1 * y0 + hi32(z0) + lo32(z1);
  uint64_t z2 = x1 * y1 + hi32(z1) + hi32(w1);
  return z2;
}

// Get a digit from a bignum using default of zero
// This is useful for "simple and naive" reference implementations

uint64_t digit(uint64_t k,uint64_t *a,uint64_t i)
{ if (i < k) return a[i];
  else return 0;
}

// Similarly, get fields indexed by bits

uint64_t bitword(uint64_t k,uint64_t *x,uint64_t b)
{ uint64_t bhi = b >> 6, blo = b & UINT64_C(63);
  if (blo == 0) return digit(k,x,bhi);
  return (digit(k,x,bhi)>>blo) + (digit(k,x,bhi+1) << (64 - blo));
}

uint64_t bitfield(uint64_t k,uint64_t *x,uint64_t b,uint64_t l)
{ uint64_t w = bitword(k,x,b);
  if (l >= 64) return w;
  else return bitword(k,x,b) & ((UINT64_C(1) << l) - UINT64_C(1));
}

// Other trivia on 64-bit unsigned words

uint64_t max(uint64_t x,uint64_t y)
{ if (x < y) return y; else return x;
}

uint64_t min(uint64_t x,uint64_t y)
{ if (x < y) return x; else return y;
}

#define swap(x,y) { uint64_t tmp = x; x = y; y = tmp; }

uint64_t reference_wordbytereverse(uint64_t n)
{ uint64_t n2 = ((n & UINT64_C(0xFF00FF00FF00FF00)) >> 8) |
                ((n & UINT64_C(0x00FF00FF00FF00FF)) << 8);
  uint64_t n4 = ((n2 & UINT64_C(0xFFFF0000FFFF0000)) >> 16) |
                ((n2 & UINT64_C(0x0000FFFF0000FFFF)) << 16);
  uint64_t n8 = ((n4 & UINT64_C(0xFFFFFFFF00000000)) >> 32) |
                ((n4 & UINT64_C(0x00000000FFFFFFFF)) << 32);
  return n8;
}

uint64_t reference_wordclz(uint64_t n)
{ uint64_t m, i;
  m = n;
  for (i = 0; i < 64; ++i)
   { if (m & UINT64_C(0x8000000000000000)) return i;
     m = m << 1;
   }
  return 64;
}

uint64_t reference_wordctz(uint64_t n)
{ uint64_t m, i;
  m = n;
  for (i = 0; i < 64; ++i)
   { if (m & UINT64_C(0x1)) return i;
     m = m >> 1;
   }
  return 64;
}

uint64_t reference_wordpopcount(uint64_t n)
{ uint64_t m = 0;
  uint64_t i;
  for (i = 0; i < 64; ++i)
     if ((UINT64_C(0x1) << i) & n) ++m;
  return m;
}

void reference_copy(uint64_t k,uint64_t *z,uint64_t n, uint64_t *x)
{ uint64_t i;
  for (i = 0; i < k; ++i) z[i] = digit(n,x,i);
}

void reference_of_word(uint64_t k,uint64_t *z,uint64_t n)
{ uint64_t i;
  if (k != 0)
   { z[0] = n;
     for (i = 1; i < k; ++i) z[i] = 0;
   }
}

void reference_pow2(uint64_t k,uint64_t *z,uint64_t n)
{ uint64_t i;
  for (i = 0; i < k; ++i) z[i] = 0;
  if (n < 64*k) z[n>>6] = UINT64_C(1)<<(n&UINT64_C(63));
}

uint64_t reference_iszero(uint64_t k,uint64_t *x)
{ uint64_t i;
  for (i = 0; i < k; ++i)
     if (x[i] != 0) return 0;
  return 1;
}

int reference_compare(uint64_t k1,uint64_t *a1,
                      uint64_t k2,uint64_t *a2)
{ uint64_t k = (k1 < k2) ? k2 : k1;
  uint64_t i;
  if (k == 0) return 0;
  for (i = 1; i <= k; ++i)
   { uint64_t d1 = digit(k1,a1,k - i);
     uint64_t d2 = digit(k2,a2,k - i);
     if (d1 != d2)
      { if (d1 < d2) return -1; else return 1;
      }
   }
  return 0;
}

uint64_t reference_le(uint64_t k,uint64_t *a1,uint64_t p,uint64_t *a2)
{ return reference_compare(k,a1,p,a2) <= 0;
}

uint64_t reference_eq_samelen(uint64_t k,uint64_t *a1,uint64_t *a2)
{ return reference_compare(k,a1,k,a2) == 0;
}

uint64_t reference_lt_samelen(uint64_t k,uint64_t *a1,uint64_t *a2)
{ return reference_compare(k,a1,k,a2) < 0;
}

uint64_t reference_le_samelen(uint64_t k,uint64_t *a1,uint64_t *a2)
{ return reference_compare(k,a1,k,a2) <= 0;
}

uint64_t reference_gt_samelen(uint64_t k,uint64_t *a1,uint64_t *a2)
{ return reference_compare(k,a1,k,a2) > 0;
}

uint64_t reference_ge_samelen(uint64_t k,uint64_t *a1,uint64_t *a2)
{ return reference_compare(k,a1,k,a2) >= 0;
}

uint64_t reference_adc
  (uint64_t k,uint64_t *z,
   uint64_t m,uint64_t *x,uint64_t n,uint64_t *y,uint64_t cin)
{ uint64_t c = cin;
  uint64_t i;
  for (i = 0; i < k; ++i)
   { uint64_t a = digit(m,x,i);
     uint64_t b = digit(n,y,i);
     uint64_t r = a + b + c;
     z[i] = r;
     c = carryout3(a,b,c);
   }
  return c;
}

uint64_t reference_sbb
  (uint64_t k,uint64_t *z,
   uint64_t m,uint64_t *x,uint64_t n,uint64_t *y,uint64_t cin)
{ uint64_t c = cin;
  uint64_t i;
  for (i = 0; i < k; ++i)
   { uint64_t a = digit(m,x,i);
     uint64_t b = digit(n,y,i);
     uint64_t r = a - (b + c);
     z[i] = r;
     c = borrowout3(a,b,c);
   }
  return c;
}

uint64_t reference_add_samelen
  (uint64_t k,uint64_t *z,uint64_t *x,uint64_t *y)
{ return reference_adc(k,z,k,x,k,y,0);
}

uint64_t reference_sub_samelen
  (uint64_t k,uint64_t *z,uint64_t *x,uint64_t *y)
{ return reference_sbb(k,z,k,x,k,y,0);
}

uint64_t reference_optsub
 (uint64_t k, uint64_t *z, uint64_t *x, uint64_t p, uint64_t *y)
{ if (p != 0) return reference_sbb(k,z,k,x,k,y,0);
  else { reference_copy(k,z,k,x); return 0; }
}

uint64_t reference_ctz(uint64_t k,uint64_t *x)
{ uint64_t i;
  for (i = 0; i < 64 * k; ++i)
    if (x[i>>6] & (UINT64_C(1)<<(i&63))) return i;
  return 64*k;
}

uint64_t reference_clz(uint64_t k,uint64_t *x)
{ uint64_t i;
  for (i = 0; i < 64 * k; ++i)
    if (x[(64*k-i-1)>>6] & (UINT64_C(1)<<((64*k-i-1)&63))) return i;
  return 64*k;
}

uint64_t reference_shr_samelen(uint64_t k,uint64_t *z,uint64_t *x,uint64_t cin)
{ uint64_t c, t, i;

  c = (cin != 0);

  for (i = 1; i <= k; ++i)
   { t = x[k - i] & UINT64_C(1);
     z[k - i] = (x[k - i] >> 1) + (c << 63);
     c = t;
   }
  return c;
}

// z = a * x as a k-digit number where x is a n-digit number

void reference_cmul(uint64_t k,uint64_t *z,uint64_t a,uint64_t n,uint64_t *x)
{ uint64_t c, xi, hi, lo, i;

  c = 0;
  for (i = 0; i < k; ++i)
   { xi = (i < n ? x[i] : (uint64_t) 0);
     hi = multop(a,xi), lo = a * xi;
     z[i] = lo + c;
     c = hi + carryout2(lo,c);
   }
}

void reference_cmadd(uint64_t k,uint64_t *z,uint64_t a,uint64_t n,uint64_t *x)
{ uint64_t *temp = malloc(k * sizeof(uint64_t));
  reference_cmul(k,temp,a,n,x);
  (void) reference_adc(k,z,k,z,k,temp,0);
  free(temp);
}

void reference_cmnegadd
  (uint64_t k,uint64_t *z,uint64_t a,uint64_t n,uint64_t *x)
{ uint64_t *temp = malloc(k * sizeof(uint64_t));
  reference_cmul(k,temp,a,n,x);
  (void) reference_sbb(k,z,k,z,k,temp,0);
  free(temp);
}

void reference_shiftleft(uint64_t k,uint64_t *x,uint64_t i)
{ uint64_t j;
  if (k == 0) return;
  for (j = k; j > 0; --j)
     x[j-1] = (j-1 < i) ? 0 : x[j-1 - i];
}

void reference_madd(uint64_t k,uint64_t *z,
                    uint64_t m,uint64_t *x,
                    uint64_t n,uint64_t *y)
{ uint64_t i, km;

  km = (k < m) ? k : m;

  for (i = 0; i < km; ++i)
     reference_cmadd(k-i,z+i,x[i],n,y);
}

void reference_mul(uint64_t k,uint64_t *z,
                    uint64_t m,uint64_t *x,
                    uint64_t n,uint64_t *y)
{ uint64_t i;
  for (i = 0; i < k; ++i) z[i] = 0;
  reference_madd(k,z,m,x,n,y);
}

void reference_divmod(uint64_t k,uint64_t *q,uint64_t *r,
                      uint64_t *x,uint64_t *y)
{ uint64_t i;
  uint64_t *a;
  uint64_t b, c;
  uint64_t bit, word;

  for (i = 0; i < k; ++i) q[i] = r[i] = 0;
  if (k == 0) return;

  a = alloca(8 * (k + 1));      // Accumulator for r with extra space to double
  for (i = 0; i <= k; ++i) a[i] = 0;

  word = k;
  do
   { --word;
     bit = 64;
     do
      { --bit;
        b = (x[word] >> bit) & 1;
        reference_adc(k+1,a,k+1,a,k+1,a,b);
        c = (reference_compare(k+1,a,k,y) >= 0);
        if (c) reference_sbb(k+1,a,k+1,a,k,y,0);
        reference_adc(k,q,k,q,k,q,c);
      }
     while (bit != 0);
   }
  while (word != 0);

  for (i = 0; i < k; ++i) r[i] = a[i];
}

void reference_mod(uint64_t k,uint64_t *r,
                   uint64_t *x,uint64_t *y)
{ uint64_t *q = alloca(2 * k * sizeof(uint64_t));
  reference_divmod(k,q,r,x,y);
}

void reference_gcd(uint64_t k,uint64_t *z,uint64_t *x,uint64_t *y)
{
  uint64_t *xx = alloca(8 * k);
  uint64_t *yy = alloca(8 * k);
  reference_copy(k,xx,k,x);
  reference_copy(k,yy,k,y);

  for (;;)
   {
     if (reference_iszero(k,xx))
      { reference_copy(k,z,k,yy);
        return;
      }
     else if (reference_iszero(k,yy))
      { reference_copy(k,z,k,xx);
        return;
      }

     if (reference_lt_samelen(k,xx,yy))
      { reference_mod(k,z,yy,xx);
        reference_copy(k,yy,k,z);
      }
     else
      { reference_mod(k,z,xx,yy);
        reference_copy(k,xx,k,z);
      }
   }
}

uint64_t reference_odd(uint64_t k,uint64_t *x)
{ return (k != 0) && (x[0] & UINT64_C(1));
}

uint64_t reference_even(uint64_t k,uint64_t *x)
{ return !reference_odd(k,x);
}

void reference_oddgcd(uint64_t k,uint64_t *z,uint64_t *x,uint64_t *y)
{ uint64_t b, i;
  uint64_t *m = alloca(8 * k);
  uint64_t *n = alloca(8 * k);

  if (k == 0) return;

  reference_copy(k,m,k,x);
  reference_copy(k,n,k,y);

  for (i = 0; i < 128 * k; ++i)
   {
     b = reference_even(k,n) ||
         (reference_odd(k,m) && reference_lt_samelen(k,m,n));
     if (b) {uint64_t *t = m; m = n; n = t; } // swap pointers not contents

     b = reference_odd(k,m);
     if (b) reference_sub_samelen(k,m,m,n);

     reference_shr_samelen(k,m,m,0);
   }

  reference_copy(k,z,k,n);
}

uint64_t reference_coprime(uint64_t k,uint64_t *x,uint64_t *y)
{ uint64_t *z = alloca(k * sizeof(uint64_t));
  uint64_t *w = alloca(k * sizeof(uint64_t));
  if (reference_even(k,x) && reference_even(k,y)) return 0;
  reference_oddgcd(k,z,x,y);
  reference_of_word(k,w,1);
  return reference_eq_samelen(k,w,z);
}

void reference_dmontmul(int k,uint64_t *z,uint64_t *x,uint64_t *y,
                       uint64_t *m,uint64_t *i,uint64_t *t)
{ uint64_t p;
  reference_mul(2 * k + 1,t,k,x,k,y);  // t = x * y
  reference_mul(k,z,k,t,k,i);      // z = ((t MOD R) * m') MOD R
  reference_madd(2 * k + 1,t,k,m,k,z);
  p = reference_le(k,m,k+1,t+k);
  reference_optsub(k,z,t+k,p,m);
}

void reference_modpowtwo(uint64_t k,uint64_t *z,uint64_t n, uint64_t *m)
{ uint64_t i, p, c;
  reference_of_word(k,z,0);
  for (i = 0; i <= n; ++i)
   { c = (i == 0) ? 1 : 0;
     c = reference_adc(k,z,k,z,k,z,c);
     p = reference_le_samelen(k,m,z);
     reference_optsub(k,z,z,(c|p),m);
   }
}

uint64_t reference_wordnegmodinv(uint64_t a)
{ uint64_t x = (a - (a<<2))^2;
  uint64_t e = a * x + 1;
  x = e * x + x; e = e * e;
  x = e * x + x; e = e * e;
  x = e * x + x; e = e * e;
  x = e * x + x;
  return x;
}

void reference_negmodinv(uint64_t k,uint64_t *x,uint64_t *a)
{ uint64_t *y = alloca(k * sizeof(uint64_t));
  uint64_t i, b, b2;

  if (k == 0) return;

  x[0] = reference_wordnegmodinv(a[0]);
  for (i = 1; i < k; ++i) x[i] = 0;
  b = 1;

  while (b < k)
   { b2 = 2 * b; if (b2 > k) b2 = k;            // b2 = min(2 * b,k)

     y[0] = 1; for (i = 1; i < b2; ++i) y[i] = 0; // y = 1
     reference_madd(b2,y,b2,a,b,x);               // y = a * x + 1 (length b2)
     reference_madd(b2-b,x+b,b,x,b2-b,y+b);     // x' = x + x * y = x * (1 + y)

     b = b2;
   }
}

void reference_bigendian(uint64_t k,uint64_t *z,uint64_t *x)
{ uint64_t i;

  for (i = 0; i < k; ++i)
   { z[k-(i+1)] =
     (((uint64_t) (((uint8_t *) x)[8*i])) << 56) +
     (((uint64_t) (((uint8_t *) x)[8*i+1])) << 48) +
     (((uint64_t) (((uint8_t *) x)[8*i+2])) << 40) +
     (((uint64_t) (((uint8_t *) x)[8*i+3])) << 32) +
     (((uint64_t) (((uint8_t *) x)[8*i+4])) << 24) +
     (((uint64_t) (((uint8_t *) x)[8*i+5])) << 16) +
     (((uint64_t) (((uint8_t *) x)[8*i+6])) << 8) +
     (((uint64_t) (((uint8_t *) x)[8*i+7])) << 0);
   }
}

void reference_littleendian(uint64_t k,uint64_t *z,uint64_t *x)
{ uint64_t i;

  for (i = 0; i < k; ++i)
   { z[i] =
     (((uint64_t) (((uint8_t *) x)[8*i+7])) << 56) +
     (((uint64_t) (((uint8_t *) x)[8*i+6])) << 48) +
     (((uint64_t) (((uint8_t *) x)[8*i+5])) << 40) +
     (((uint64_t) (((uint8_t *) x)[8*i+4])) << 32) +
     (((uint64_t) (((uint8_t *) x)[8*i+3])) << 24) +
     (((uint64_t) (((uint8_t *) x)[8*i+2])) << 16) +
     (((uint64_t) (((uint8_t *) x)[8*i+1])) << 8) +
     (((uint64_t) (((uint8_t *) x)[8*i])) << 0);
   }
}

void reference_fromlebytes(uint64_t k,uint64_t *z,uint64_t n,uint8_t *x)
{ uint64_t i, acc;

  acc = 0; i = n;
  while (i != 0)
   { --i;
     acc = (acc<<8) + (uint64_t) x[i];
     if (i % 8 == 0) z[i/8] = acc, acc = 0;
   }
}

void reference_tolebytes(uint64_t k,uint8_t *z,uint64_t n,uint64_t *x)
{ uint64_t i;

  for (i = 0; i < k; ++i)
    z[i] = x[i/8] >> (8*(i%8));
}

int64_t reference_divstep(int64_t m[2][2],int n,int64_t din,int64_t fin,int64_t gin)
{ int64_t d, f, g, t;
  int64_t u = 1, v = 0, r = 0, s = 1;
  int i;

  if (n > 61)
   { printf("reference_divstep: parameter too big\n");
     exit(1);
   }

  fin &= 0x1FFFFFFFFFFFFFFF;
  gin &= 0x1FFFFFFFFFFFFFFF;
  d = din; f = fin; g = gin;

  for (i = 0; i < n; ++i)
    if ((d > 0) && (g & 1))
       d = 2 - d, t = g, g = (g - f) >> 1, f = t,
                  t = r, r = (r - u), u = t << 1,
                  t = s, s = (s - v), v = t << 1;
     else if (g & 1)
       d = 2 + d, g = (g + f) >> 1,
                  r = (r + u), u = u << 1,
                  s = (s + v), v = v << 1;
     else d = 2 + d, g = g >> 1, u = u << 1, v = v << 1;

  m[0][0] = u;
  m[0][1] = v;
  m[1][0] = r;
  m[1][1] = s;
  return d;
}


// ****************************************************************************
// References for ML-KEM operations, lots of mod-3329 stuff
// ****************************************************************************

// Proper nonnegative remainder regardless of C's handling of negative x

int16_t rem_3329(int16_t x)
{ return (x % 3329 + 3329) % 3329;
}

// Combine that with a promotion from int16_t to uint64_t

uint64_t mod_3329(int16_t x)
{ return (uint64_t) (rem_3329(x));
}

// Raise number to power: x^n mod 3329

uint64_t pow_3329(uint64_t x,uint64_t n)
{ uint64_t t;
  if (n == 0) return 1;
  t = pow_3329(x,n>>1);
  t = (t * t) % 3329;
  if (n % 2 == 0) return t;
  else return (x * t) % 3329;
}

// Pure forward NTT
// NTT[k] = sum_{j=0..127} a[2 * j + k % 2] * 17^((2 * (k / 2) + 1) * j)

void reference_forward_ntt(int16_t r[256],int16_t a[256])
{ uint64_t k, j, s;
  int16_t t[256];
  for (k = 0; k < 256; ++k)
   { s = 0;
     for (j = 0; j < 128; ++j)
       s += mod_3329(a[2 * j + k % 2]) * pow_3329(17,(2 * (k / 2) + 1) * j);
     s = s % 3329;
     t[k] = (int16_t) s;
   }
  for (k = 0; k < 256; ++k) r[k] = t[k];
}

// Pure inverse NTT
// iNTT[k] =
// 1/128 * sum_{j=0..127} a[2 * j + k % 2] * 1175^((2 * j + 1) * (k / 2))

void reference_inverse_ntt(int16_t r[256],int16_t a[256])
{ uint64_t k, j, s;
  int16_t t[256];
  for (k = 0; k < 256; ++k)
   { s = 0;
     for (j = 0; j < 128; ++j)
       s += mod_3329(a[2 * j + k % 2]) * pow_3329(1175,(2 * j + 1) * (k / 2));
     s = (3303 * s) % 3329;
     t[k] = (int16_t) s;
   }
  for (k = 0; k < 256; ++k) r[k] = t[k];
}

// Reverse bits 1..7 of an 8-bit value, leaving but 0 alone. This is a
// strightforward variant of the Schroeppel-Anderson hack described here:
// https://graphics.stanford.edu/~seander/bithacks.html#ReverseByteWith64Bits
// It has been manually transcribed into HOL Light and checked for correctness.

uint64_t bitreverse_pairs(uint64_t x)
{ return ((((x * UINT64_C(0x40100401)) & UINT64_C(0x884422011)) *
          UINT64_C(0x0101010101)) >> 32)
         & UINT64_C(0xFF);
}

// Bit reversal of a 256-element array as in the NTT spec
// We start with a local intermediate copy to make this aliasing-safe
// if the input and output arrays are the same; we could swap pairs...

void reference_bitreverse(int16_t r[256],int16_t a[256])
{ int16_t t[256];
  uint64_t i;
  for (i = 0; i < 256; ++i) t[i] = a[bitreverse_pairs(i)];
  for (i = 0; i < 256; ++i) r[i] = t[i];
}

// Convert elements of a 256-element array to Montgomery form

void reference_tomont3329(int16_t r[256],int16_t a[256])
{ uint64_t i, t;
  for (i = 0; i < 256; ++i)
   { t = mod_3329(a[i]);
     t = (65536 * t) % 3329;
     r[i] = (int16_t) t;
   }
}

// Mulcache computation

void reference_mulcache_compute(int16_t x[128],int16_t a[256])
{ uint64_t k;
  for (k = 0; k < 128; ++k)
      x[k] = (mod_3329(a[2 * k + 1]) * pow_3329(17,bitreverse_pairs(2 * k + 1))) % 3329;
}

// Base multiplication, which is the following operation
//
// (a0 + a1 * X) * (b0 + b1 * X) mod (X^2 - zeta)
// = (a0 * b0 + a1 * b1 * zeta) + (a0 * b1 + a1 * b0) * X
//
// We scale by 169 = 2^-16 mod 3329 since it's all
// assumed to be in Montgomery form

void reference_basemul(int16_t z[256],int16_t a[256],int16_t b[256])
{ uint64_t k;
  for (k = 0; k < 128; ++k)
   { z[2 * k] = (169 * (mod_3329(a[2 * k]) * mod_3329(b[2 * k]) +
                        mod_3329(a[2 * k + 1]) * mod_3329(b[2 * k + 1]) *
                 pow_3329(17,bitreverse_pairs(2 * k + 1)))) % 3329;
     z[2 * k + 1] = (169 * (mod_3329(a[2 * k]) * mod_3329(b[2 * k + 1]) +
                            mod_3329(a[2 * k + 1]) * mod_3329(b[2 * k]))) % 3329;
   }
}

// 2-wide scalar product of basemuls

void reference_basemul2(int16_t z[256],int16_t a[512],int16_t b[512])
{ uint64_t k;
  int16_t t0[256], t1[256];
  reference_basemul(t0,a,b);
  reference_basemul(t1,a+256,b+256);
  for (k = 0; k < 256; ++k)
     z[k] = (t0[k] + t1[k]) % 3329;
}

// 3-wide scalar product of basemuls

void reference_basemul3(int16_t z[256],int16_t a[768],int16_t b[768])
{ uint64_t k;
  int16_t t0[256], t1[256], t2[256];
  reference_basemul(t0,a,b);
  reference_basemul(t1,a+256,b+256);
  reference_basemul(t2,a+512,b+512);
  for (k = 0; k < 256; ++k)
     z[k] = (t0[k] + t1[k] + t2[k]) % 3329;
}

// 4-wide scalar product of basemuls

void reference_basemul4(int16_t z[256],int16_t a[1024],int16_t b[1024])
{ uint64_t k;
  int16_t t0[256], t1[256], t2[256], t3[256];
  reference_basemul(t0,a,b);
  reference_basemul(t1,a+256,b+256);
  reference_basemul(t2,a+512,b+512);
  reference_basemul(t3,a+768,b+768);
  for (k = 0; k < 256; ++k)
     z[k] = (t0[k] + t1[k] + t2[k] + t3[k]) % 3329;
}

// ****************************************************************************
// References for ML-DSA operations, lots of mod-8380417 stuff
// ****************************************************************************

// Reference function implementing ML-DSA centered reduction
int32_t reference_poly_reduce(int32_t a)
{
    const int32_t MLDSA_Q = 8380417;
    int32_t t;
    t = (a + (1 << 22)) >> 23;
    t = a - t * MLDSA_Q;
    return t;
}

// Reference Montgomery reduction for ML-DSA
// MLDSA_QINV = 58728449 which is q^(-1) mod 2^32
int32_t reference_mldsa_reduce(int64_t a)
{
    int32_t t;
    t = (int32_t)((a * 58728449) & 0xFFFFFFFF);
    t = (a - (int64_t)t * 8380417) >> 32;
    return t;
}

// Reference bit-reversal for 8-bit integers (FIPS 204 Algorithm 43)
uint8_t reference_bitrev8(uint8_t x)
{
    uint8_t result = 0;
    for (int i = 0; i < 8; i++) {
        result = (result << 1) | (x & 1);
        x >>= 1;
    }
    return result;
}

// AVX2 NTT ordering function
// avx2_ntt_order i = bitreverse8(64 * (i DIV 64) + ((i MOD 64) DIV 8) + 8 * (i MOD 8))
uint8_t avx2_ntt_order(uint8_t i)
{
    uint8_t temp = 64 * (i / 64) + ((i % 64) / 8) + 8 * (i % 8);
    return reference_bitrev8(temp);
}

// Reference bit-reversal for ML-DSA coefficient reordering
void reference_mldsa_bitreverse(int32_t a[256])
{
    int32_t temp[256];
    for (int i = 0; i < 256; i++) {
        temp[i] = a[i];
    }
    for (int i = 0; i < 256; i++) {
        a[i] = temp[reference_bitrev8(i)];
    }
}

// Convert ML-DSA array elements to Montgomery form (multiply by 2^32 mod q)
void reference_tomont_mldsa(int32_t a[256])
{
    const int32_t MLDSA_Q = 8380417;
    // 2^32 mod q (computed as (2^32) % 8380417)
    const uint64_t r_mod_q = 4294967296ULL % 8380417; // = 4193792
    
    for (int i = 0; i < 256; i++) {
        // Normalize to [0, q)
        int64_t normalized = ((int64_t)a[i] % MLDSA_Q + MLDSA_Q) % MLDSA_Q;
        // Multiply by 2^32 mod q
        a[i] = (int32_t)((normalized * r_mod_q) % MLDSA_Q);
    }
}

// Convert ML-DSA array elements from Montgomery form to normal form
// Inverse operation of reference_tomont_mldsa
void reference_frommont_mldsa(int32_t a[256])
{
    for (int i = 0; i < 256; i++) {
        int64_t t_val = (int64_t)a[i];
        int32_t m = (int32_t)((t_val * 58728449LL) & 0xFFFFFFFF);
        a[i] = (t_val - (int64_t)m * 8380417) >> 32;
    }
}

// Raise number to power: x^n mod 8380417
uint64_t pow_8380417(uint64_t x, uint64_t n)
{
    uint64_t t;
    if (n == 0) return 1;
    t = pow_8380417(x, n >> 1);
    t = (t * t) % 8380417;
    if (n % 2 == 0) return t;
    else return (x * t) % 8380417;
}

// Pure forward ML-DSA NTT
// NTT[k] = sum_{j=0..255} a[j] * 1753^((2 * avx2_ntt_order(k) + 1) * j) mod 8380417
// where avx2_ntt_order(k) = bitreverse8(64*(k/64) + (k%64)/8 + 8*(k%8))
void reference_mldsa_forward_ntt_spec(int32_t a[256])
{
    int32_t result[256];

    for (int k = 0; k < 256; k++) {
        uint64_t sum = 0;
        uint8_t order_k = avx2_ntt_order(k);

        for (int j = 0; j < 256; j++) {
            // Properly normalize input to [0, MLDSA_Q) range
            int64_t normalized_aj = ((int64_t)a[j] % 8380417 + 8380417) % 8380417;

            uint64_t power = ((uint64_t)(2 * order_k + 1) * j) % 16760832; // Reduce exponent mod (q-1)*2
            uint64_t zeta_power = pow_8380417(1753, power);

            uint64_t term = ((uint64_t)normalized_aj * zeta_power) % 8380417;
            sum = (sum + term) % 8380417;
        }

        result[k] = (int32_t)sum;
    }

    // Copy result back
    for (int i = 0; i < 256; i++) {
        a[i] = result[i];
    }
}

// Reference forward NTT for ML-DSA (matching mldsa-native C algorithm)
void reference_mldsa_forward_ntt(int32_t a[256])
{
    unsigned int layer;

    for (layer = 1; layer < 9; layer++) {
        unsigned start, k, len;
        // Twiddle factors for layer n are at indices 2^(n-1)..2^n-1
        k = 1u << (layer - 1);
        len = 256u >> layer;

        for (start = 0; start < 256; start += 2 * len) {
            int32_t zeta = mldsa_zetas[k++];
            unsigned j;

            for (j = start; j < start + len; j++) {
                int32_t t = reference_mldsa_reduce((int64_t)zeta * a[j + len]);
                a[j + len] = a[j] - t;
                a[j] = a[j] + t;
            }
        }
    }
}

// Reference inverse NTT for ML-DSA (matching mldsa-native C algorithm)
// Takes NTT-domain input (no bit-reversal needed), produces Montgomery form output
// This matches the assembly mldsa_intt behavior
void reference_mldsa_inverse_ntt(int32_t a[256])
{
    unsigned int layer;
    
    // Apply inverse NTT butterfly layers in reverse order (8 down to 1)
    for (layer = 8; layer >= 1; layer--) {
        unsigned start, k, len;
        // For inverse, use zetas starting from index (1 << layer) - 1 and going down
        // This gives us the zetas in reverse order
        k = (1u << layer) - 1;
        len = 256u >> layer;
        
        for (start = 0; start < 256; start += 2 * len) {
            // Use negative zeta for inverse transform
            int32_t zeta = -mldsa_zetas[k--];
            unsigned j;
            
            for (j = start; j < start + len; j++) {
                int32_t t = a[j];
                a[j] = t + a[j + len];
                a[j + len] = t - a[j + len];
                a[j + len] = reference_mldsa_reduce((int64_t)zeta * a[j + len]);
            }
        }
    }
    
    // Scale by mont/256 (= 2^32/256 mod q) to get Montgomery form output
    // 41978 = pow(2, 64-8, MLDSA_Q) per mldsa-native
    const int32_t f = 41978;
    for (unsigned i = 0; i < 256; i++) {
        a[i] = reference_mldsa_reduce((int64_t)a[i] * f);
    }
}

// Pure inverse ML-DSA NTT specification (algebraic inverse of forward NTT)
// Since forward NTT: result[k] = sum_{j=0..255} a[j] * ^((2*order(k)+1)*j)
// Inverse NTT: result[j] = (1/256) * sum_{k=0..255} a[k] * ^(-(2*order(k)+1)*j)
void reference_mldsa_inverse_ntt_spec(int32_t a[256])
{
    int32_t result[256];
    const int32_t MLDSA_Q = 8380417;
    const uint64_t inv_256 = 8347681; // 256^(-1) mod q
    
    for (int j = 0; j < 256; j++) {
        uint64_t sum = 0;
        
        for (int k = 0; k < 256; k++) {
            // Normalize input
            int64_t normalized_ak = ((int64_t)a[k] % MLDSA_Q + MLDSA_Q) % MLDSA_Q;
            
            // Get the bit-reversed index for k (same as forward NTT uses)
            uint8_t order_k = avx2_ntt_order(k);
            
            // For inverse: use negative exponent ^(-(2*order(k)+1)*j)
            uint64_t power = ((uint64_t)(2 * order_k + 1) * j);
            uint64_t inv_power = (8380416 - (power % 8380416)) % 8380416;
            uint64_t zeta_power = pow_8380417(1753, inv_power);
            
            uint64_t term = ((uint64_t)normalized_ak * zeta_power) % MLDSA_Q;
            sum = (sum + term) % MLDSA_Q;
        }
        
        // Multiply by 1/256 mod q
        result[j] = (int32_t)((sum * inv_256) % MLDSA_Q);
    }
    
    // Copy result back
    for (int i = 0; i < 256; i++) {
        a[i] = result[i];
    }
}

<<<<<<< HEAD
// Keccak-f1600 reference.
// https://keccak.team/files/Keccak-reference-3.0.pdf

uint64_t keccak_RC[24] =
 { UINT64_C(0x0000000000000001),
   UINT64_C(0x0000000000008082),
   UINT64_C(0x800000000000808a),
   UINT64_C(0x8000000080008000),
   UINT64_C(0x000000000000808b),
   UINT64_C(0x0000000080000001),
   UINT64_C(0x8000000080008081),
   UINT64_C(0x8000000000008009),
   UINT64_C(0x000000000000008a),
   UINT64_C(0x0000000000000088),
   UINT64_C(0x0000000080008009),
   UINT64_C(0x000000008000000a),
   UINT64_C(0x000000008000808b),
   UINT64_C(0x800000000000008b),
   UINT64_C(0x8000000000008089),
   UINT64_C(0x8000000000008003),
   UINT64_C(0x8000000000008002),
   UINT64_C(0x8000000000000080),
   UINT64_C(0x000000000000800a),
   UINT64_C(0x800000008000000a),
   UINT64_C(0x8000000080008081),
   UINT64_C(0x8000000000008080),
   UINT64_C(0x0000000080000001),
   UINT64_C(0x8000000080008008)
};

uint64_t keccak_r[5][5] =
{{ UINT64_C(0), UINT64_C(36), UINT64_C(3), UINT64_C(41), UINT64_C(18) },
 { UINT64_C(1), UINT64_C(44), UINT64_C(10), UINT64_C(45), UINT64_C(2) },
 { UINT64_C(62), UINT64_C(6), UINT64_C(43), UINT64_C(15), UINT64_C(61) },
 { UINT64_C(28), UINT64_C(55), UINT64_C(25), UINT64_C(21), UINT64_C(56) },
 { UINT64_C(27), UINT64_C(20), UINT64_C(39), UINT64_C(8), UINT64_C(14) }
};

uint64_t rol(uint64_t x,uint64_t k)
{ k &= 0x3F;
  if (k == 0) return x;
  else return (x << k) | (x >> (64 - k));
}

#define add5(x,y) (((x) + (y)) % 5)
#define sub5(x,y) (((x) + (5 - (y))) % 5)

void reference_keccak_f1600(uint64_t r[25],uint64_t a[25])
{ uint64_t i, x, y;

  uint64_t A[5][5], B[5][5], C[5], D[5];

  for (x = 0; x < 5; ++x)
     for (y = 0; y < 5; ++y)
        A[x][y] = a[5*y+x];

  for (i = 0; i <= 23; ++i)
   { for (x = 0; x < 5; ++x)
        C[x] = A[x][0] ^ A[x][1] ^ A[x][2] ^ A[x][3] ^ A[x][4];
     for (x = 0; x < 5; ++x)
        D[x] = C[sub5(x,1)] ^ rol(C[add5(x,1)],1);
     for (x = 0; x < 5; ++x)
        for (y = 0; y < 5; ++y)
           A[x][y] = A[x][y] ^ D[x];

     // rho and pi steps
     for (x = 0; x < 5; ++x)
        for (y = 0; y < 5; ++y)
           B[y][(2*x+3*y)%5] = rol(A[x][y],keccak_r[x][y]);

    // chi step
     for (x = 0; x < 5; ++x)
        for (y = 0; y < 5; ++y)
           A[x][y] = B[x][y] ^ (~B[add5(x,1)][y] & B[add5(x,2)][y]);

    // iota step
    A[0][0] = A[0][0] ^ keccak_RC[i];
  }

  for (x = 0; x < 5; ++x)
     for (y = 0; y < 5; ++y)
        r[5*y+x] = A[x][y];
}

// Rejection sampling reference

uint64_t reference_rej_uniform(int16_t r[256],uint8_t *buf,uint64_t buflen)
{
  uint64_t target = 256;

  uint64_t ctr, pos;
  uint16_t val0, val1;

  ctr = pos = 0;

  while (ctr < 256 && pos + 3 <= buflen)
   {
     val0 = ((buf[pos + 0] >> 0) | ((uint16_t)buf[pos + 1] << 8)) & 0xFFF;
     val1 = ((buf[pos + 1] >> 4) | ((uint16_t)buf[pos + 2] << 4)) & 0xFFF;
     pos += 3;

     if (val0 < 3329) r[ctr++] = val0;
     if (ctr < target && val1 < 3329) r[ctr++] = val1;
   }

  return ctr;
}

// ****************************************************************************
// Testing functions
// ****************************************************************************

int test_bignum_add(void)
{ uint64_t t, j, k0, k1, k2;
  printf("Testing bignum_add with %d cases\n",tests);
  uint64_t c, c1, c2;
  for (t = 0; t < tests; ++t)
   { k0 = (unsigned) rand() % MAXSIZE;
     k1 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     random_bignum(k0,b0);
     random_bignum(k1,b1);
     random_bignum(k2,b2);
     for (j = 0; j < k2; ++j) b3[j] = b2[j];
     c1 = bignum_add(k2,b2,k0,b0,k1,b1);
     c2 = reference_adc(k2,b3,k0,b0,k1,b1,0);
     c = reference_compare(k2,b2,k2,b3);
     if ((c != 0) || (c1 != c2))
      { printf("### Disparity: [sizes %4"PRIu64" := %4"PRIu64" + %4"PRIu64"] "
               "...0x%016"PRIx64" + ...0x%016"PRIx64" = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k2,k0,k1,b0[0],b1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k0 == 0 || k1 == 0 || k2 == 0) printf("OK: [sizes %4"PRIu64" := %4"PRIu64" + %4"PRIu64"]\n",k2,k0,k1);
        else printf("OK: [sizes %4"PRIu64" := %4"PRIu64" + %4"PRIu64"] ...0x%016"PRIx64" + ...0x%016"PRIx64" = ...0x%016"PRIx64"\n",
                    k2,k0,k1,b0[0],b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_add_p25519(void)
{ uint64_t i, k;
  printf("Testing bignum_add_p25519 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_25519);
     random_bignum(k,b2); reference_mod(k,b1,b2,p_25519);
     bignum_add_p25519(b2,b0,b1);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b1);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_25519);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" + ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],p_25519[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" + ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],p_25519[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_add_p256(void)
{ uint64_t i, k;
  printf("Testing bignum_add_p256 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_256);
     random_bignum(k,b2); reference_mod(k,b1,b2,p_256);
     bignum_add_p256(b2,b0,b1);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b1);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_256);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" + ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],p_256[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" + ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],p_256[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_add_p256k1(void)
{ uint64_t i, k;
  printf("Testing bignum_add_p256k1 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_256k1);
     random_bignum(k,b2); reference_mod(k,b1,b2,p_256k1);
     bignum_add_p256k1(b2,b0,b1);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b1);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_256k1);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" + ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],p_256k1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" + ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],p_256k1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_add_p384(void)
{ uint64_t i, k;
  printf("Testing bignum_add_p384 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 6;;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_384);
     random_bignum(k,b2); reference_mod(k,b1,b2,p_384);
     bignum_add_p384(b2,b0,b1);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b1);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_384);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" + ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],p_384[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" + ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],p_384[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_add_p521(void)
{ uint64_t i, k;
  printf("Testing bignum_add_p521 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 9;;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_521);
     random_bignum(k,b2); reference_mod(k,b1,b2,p_521);
     bignum_add_p521(b2,b0,b1);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b1);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_521);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" + ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],p_521[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" + ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],p_521[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_add_sm2(void)
{ uint64_t i, k;
  printf("Testing bignum_add_sm2 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_sm2);
     random_bignum(k,b2); reference_mod(k,b1,b2,p_sm2);
     bignum_add_sm2(b2,b0,b1);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b1);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_sm2);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" + ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],p_sm2[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" + ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],p_sm2[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_amontifier(void)
{ uint64_t i, k, c;
  printf("Testing bignum_amontifier with %d cases\n",tests);
  for (i = 0; i < tests; ++i)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0); b0[0] |= 1;

     bignum_amontifier(k,b1,b0,b7); // b1 = test fun
     reference_mod(k,b2,b1,b0);        // b2 = Fully reduced modulo for comparison

     reference_modpowtwo(k,b3,128*k,b0); /// Naive regerence

     c = reference_compare(k,b2,k,b3);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
           "bignum_amontifier(...0x%016"PRIx64") = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
            k,b0[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] bignum_amontifier(...0x%016"PRIx64") =..0x%016"PRIx64"\n",
                    k,b0[0],b1[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_amontmul(void)
{ uint64_t t, k;
  printf("Testing bignum_amontmul with %d cases\n",tests);
  int c = 0;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0); b0[0] |= 1; // b0 = m
     random_bignum(k,b1);             // b1 = x
     random_bignum(k,b2);             // b2 = y
     reference_mul(2 * k,b3,k,b1,k,b2);  // b3 = z = x * y
     reference_negmodinv(k,b4,b0);    // b4 = m' = negmodinv(m)
     bignum_amontmul(k,b6,b1,b2,b0);        // b6 = output of function

     reference_mod(k,b5,b6,b0);                // b5 = full modulus for comparison
     reference_copy(k,b7,k,b1); reference_mod(k,b1,b7,b0);
     reference_copy(k,b7,k,b2); reference_mod(k,b2,b7,b0);
     reference_dmontmul(k,b3,b1,b2,b0,b4,b8);   // b3 = "reference" Montgomery

     c = reference_compare(k,b3,k,b5);
     if (c != 0)
      { printf("### Disparity (Montgomery mul): [size %4"PRIu64"]\n",k);
        printf("### Output is ...0x%016"PRIx64"\n",b5[0]);
        printf("### Reference ...0x%016"PRIx64"\n",b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] bignum_amontmul(...0x%016"PRIx64",...0x%016"PRIx64") wrt ...0x%016"PRIx64" = ...0x%016"PRIx64"\n",
                    k,b1[0],b2[0],b0[0],b6[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_amontredc(void)
{ uint64_t t, k, n, p, r;
  printf("Testing bignum_amontredc with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     n = (unsigned) rand() % MAXSIZE;
     p = (unsigned) rand() % MAXSIZE;

     random_bignum(k,b0); b0[0] |= 1;  // b0 = m
     random_bignum(n,b1);              // b1 = x

     bignum_amontredc(k,b4,n,b1,b0,p); // b4 = test function

     r = max(p+k,n);

     reference_pow2(r,b2,64*p);            // b2 = 2^{64p}
     reference_mul(r,b3,r,b2,k,b4);        // b3 = 2^{64p} * z
     reference_copy(r,b2,min(n,p+k),b1);   // b2 = x' (truncated x)
     reference_copy(r,b5,k,b0);            // b5 = m
     reference_mod(r,b6,b2,b5);            // b6 = x mod m
     reference_mod(r,b7,b3,b5);            // b7 = (2^{64p} * z) mod m
     c = ((k != 0) && reference_compare(r,b6,r,b7));
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64" -> %4"PRIu64"] "
               "...%016"PRIx64" / 2^%"PRIu64" mod ...%016"PRIx64" = ...%016"PRIx64"\n",
               n,k,b1[0],64*p,b0[0],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64" -> %4"PRIu64"] "
               "...%016"PRIx64" / 2^%"PRIu64" mod ...%016"PRIx64" = ...%016"PRIx64"\n",
               n,k,b1[0],64*p,b0[0],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_amontsqr(void)
{ uint64_t t, k;
  printf("Testing bignum_amontsqr with %d cases\n",tests);
  int c = 0;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0); b0[0] |= 1; // b0 = m
     random_bignum(k,b1);             // b1 = x
     reference_copy(k,b2,k,b1);          // b2 = y = x in squaring case
     reference_mul(2 * k,b3,k,b1,k,b2);  // b3 = z = x * y
     reference_negmodinv(k,b4,b0);    // b4 = m' = negmodinv(m)
     bignum_amontsqr(k,b6,b1,b0);        // b6 = output of function

     reference_mod(k,b5,b6,b0);                // b5 = full modulus for comparison
     reference_copy(k,b7,k,b1); reference_mod(k,b1,b7,b0);
     reference_copy(k,b7,k,b2); reference_mod(k,b2,b7,b0);
     reference_dmontmul(k,b3,b1,b2,b0,b4,b8);   // b3 = "reference" Montgomery

     c = reference_compare(k,b3,k,b5);
     if (c != 0)
      { printf("### Disparity (Montgomery sqr): [size %4"PRIu64"]\n",k);
        printf("### Output is ...0x%016"PRIx64"\n",b5[0]);
        printf("### Reference ...0x%016"PRIx64"\n",b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] bignum_amontsqr(...0x%016"PRIx64") wrt ...0x%016"PRIx64" = ...0x%016"PRIx64"\n",
                    k,b1[0],b0[0],b6[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_bigendian_4(void)
{ uint64_t t;
  printf("Testing bignum_bigendian_4 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     reference_bigendian(4,b3,b0);
     bignum_bigendian_4(b4,b0);
     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_bigendian_4(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] bignum_bigendian_4(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_bigendian_6(void)
{ uint64_t t;
  printf("Testing bignum_bigendian_6 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(6,b0);
     reference_bigendian(6,b3,b0);
     bignum_bigendian_6(b4,b0);
     c = reference_compare(6,b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_bigendian_6(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[5],b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] bignum_bigendian_6(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[5],b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_bitfield(void)
{ uint64_t t, k, n, l;
  printf("Testing bignum_bitfield with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     n = random64();
     l = random64() % UINT64_C(68);
     if (rand() & 3) n %= (64 * k + 1);
     if ((k > 0) && (rand() & 3) == 0) n = 64 * (k - 1) + (rand() % 130);
     c1 = bignum_bitfield(k,b0,n,l);
     c2 = bitfield(k,b0,n,l);
     if (c1 != c2)
      { printf(
          "### Disparity: [size %4"PRIu64"] bignum_bitfield(...0x%016"PRIx64",%"PRIu64",%"PRIu64") = 0x%016"PRIx64" not 0x%016"PRIx64"\n",
          k,b0[0],n,l,c1,c2);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] bignum_bitfield(...0x%016"PRIx64",%"PRIu64",%"PRIu64") = 0x%016"PRIx64"\n",
                    k,b0[0],n,l,c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_bitsize(void)
{ uint64_t t, k;
  printf("Testing bignum_bitsize with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     if (rand() & 1) random_sparse_bignum(k,b0); else random_bignum(k,b0);
     c1 = bignum_bitsize(k,b0);
     c2 = 64 * k - reference_clz(k,b0);
     if (c1 != c2)
      { printf(
          "### Disparity: [size %4"PRIu64"] bignum_bitsize(0x%016"PRIx64"...) = %"PRIu64" not %"PRIu64"\n",
          k,b0[k-1],c1,c2);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] bignum_bitsize(0x%016"PRIx64"...) = %"PRIu64"\n",
                    k,b0[k-1],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cdiv(void)
{ uint64_t t, j1, j2, k1, k2, k, m, r, s;
  printf("Testing bignum_cdiv with %d cases\n",tests);
  for (t = 0; t < tests; ++t)
   { k1 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     m = random64(); if (m == 0) m = (rand() & 31) + 1;
     random_bignum(k1,b1);
     k = max(k1,k2);
     bignum_copy(k,b3,k1,b1);
     bignum_of_word(k,b4,m);
     reference_divmod(k,b5,b6,b3,b4);
     reference_copy(k2,b3,k,b5);
     s = (k == 0) ? 0 : b6[0];
     r = bignum_cdiv(k2,b4,k1,b1,m);
     j1 = (k1 == 0) ? 0 : k1-1;
     j2 = (k2 == 0) ? 0 : k2-1;
     if (reference_compare(k2,b3,k2,b4) != 0)
      { printf("### Disparity in quotient: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" div %"PRIu64" = "
               "0x%016"PRIx64"...%016"PRIx64" rem %"PRIu64" not 0x%016"PRIx64"...%016"PRIx64" rem %"PRIu64"\n",
               k2,b1[j1],b1[0],m,b4[j2],b4[0],r,b3[j2],b3[0],s);
        return 1;
      }
     if (r != s)
      { printf("### Disparity in modulus: [sizes %4"PRIu64" := %4"PRIu64" / 1] "
               "0x%016"PRIx64"...%016"PRIx64" mod %"PRIu64" = "
               "%"PRIu64" not %"PRIu64"\n",
               k2,k1,b1[j1],b1[0],m,r,s);
        return 1;
     }
     else if (VERBOSE)
      { if (k2 == 0) printf("OK: [sizes %4"PRIu64" := %4"PRIu64" / 1]\n",k2,k1);
        else printf("OK: [sizes %4"PRIu64" := %4"PRIu64" / 1]  0x%016"PRIx64"...0x%016"PRIx64" / 0x%016"PRIx64" = "
                    "0x%016"PRIx64"...0x%016"PRIx64" rem %"PRIu64"\n",
                    k2,k1,b1[j1],b1[0],m,b4[j2],b4[0],r);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cdiv_exact(void)
{ uint64_t t, j1, j2, k1, k2, k, m;
  printf("Testing bignum_cdiv_exact with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k1 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     m = random64(); if (m == 0) m = (rand() & 31) + 1;
     random_bignum(k2,b2);
     if (k1 >= 2)
      { random_bignum(k1-1,b3);
        reference_cmul(k1,b1,m,k1-1,b3);
      }
     else if (k1 == 1)
      { b1[0] = random64();
        b1[0] -= b1[0] % m;
      }
     bignum_cdiv_exact(k2,b2,k1,b1,m);
     k = max(k1,k2);
     bignum_copy(k,b3,k1,b1);
     bignum_of_word(k,b4,m);
     reference_divmod(k,b5,b6,b3,b4);
     reference_copy(k2,b3,k,b5);
     c = reference_compare(k2,b2,k2,b3);
     j1 = (k1 == 0) ? 0 : k1-1;
     j2 = (k2 == 0) ? 0 : k2-1;
     if (c != 0)
      { printf("### Disparity: [sizes %4"PRIu64" := %4"PRIu64" / 1] "
               "0x%016"PRIx64"...0x%016"PRIx64" / 0x%016"PRIx64" = 0x%016"PRIx64"....0x%016"PRIx64" not 0x%016"PRIx64"...0x%016"PRIx64"\n",
               k2,k1,b1[j1],b1[0],m,b2[j2],b2[0],b3[j2],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k2 == 0) printf("OK: [sizes %4"PRIu64" := %4"PRIu64" / 1]\n",k2,k1);
        else printf("OK: [sizes %4"PRIu64" := %4"PRIu64" / 1]  0x%016"PRIx64"...0x%016"PRIx64" / 0x%016"PRIx64" =  0x%016"PRIx64"...0x%016"PRIx64"\n",
                    k2,k1,b1[j1],b1[0],m,b2[j2],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cld(void)
{ uint64_t t, k;
  printf("Testing bignum_cld with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     if (rand() & 1) random_sparse_bignum(k,b0); else random_bignum(k,b0);
     c1 = bignum_cld(k,b0);
     c2 = reference_clz(k,b0) >> 6;
     if (c1 != c2)
      { printf(
          "### Disparity: [size %4"PRIu64"] bignum_cld(0x%016"PRIx64"...) = %"PRIu64" not %"PRIu64"\n",
          k,b0[k-1],c1,c2);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] bignum_cld(0x%016"PRIx64"...) = %"PRIu64"\n",
                    k,b0[k-1],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_clz(void)
{ uint64_t t, k;
  printf("Testing bignum_clz with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     if (rand() & 1) random_sparse_bignum(k,b0); else random_bignum(k,b0);
     c1 = bignum_clz(k,b0);
     c2 = reference_clz(k,b0);
     if (c1 != c2)
      { printf(
          "### Disparity: [size %4"PRIu64"] bignum_clz(0x%016"PRIx64"...) = %"PRIu64" not %"PRIu64"\n",
          k,b0[k-1],c1,c2);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] bignum_clz(0x%016"PRIx64"...) = %"PRIu64"\n",
                    k,b0[k-1],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cmadd(void)
{ uint64_t t, k1, k2, a;
  printf("Testing bignum_cmadd with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k1 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     a = random64();
     random_bignum(k1,b1);
     random_bignum(k2,b2);
     reference_copy(k2,b3,k2,b2);
     bignum_cmadd(k2,b2,a,k1,b1);
     reference_cmadd(k2,b3,a,k1,b1);
     c = reference_compare(k2,b2,k2,b3);
     if (c != 0)
      { printf("### Disparity: [sizes %4"PRIu64" := 1 * %4"PRIu64"] "
               "0x%016"PRIx64" * ...0x%016"PRIx64" = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k2,k1,a,b1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k2 == 0) printf("OK: [sizes %4"PRIu64" := 1 * %4"PRIu64"]\n",k2,k1);
        else printf("OK: [sizes %4"PRIu64" := 1 * %4"PRIu64"] 0x%016"PRIx64" * ...0x%016"PRIx64" = ...0x%016"PRIx64"\n",
                    k2,k1,a,b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cmnegadd(void)
{ uint64_t t, k1, k2, a;
  printf("Testing bignum_cmnegadd with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k1 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     a = random64();
     random_bignum(k1,b1);
     random_bignum(k2,b2);
     bignum_copy(k2,b3,k2,b2);
     bignum_cmnegadd(k2,b2,a,k1,b1);
     reference_cmnegadd(k2,b3,a,k1,b1);
     c = reference_compare(k2,b2,k2,b3);
     if (c != 0)
      { printf("### Disparity: [sizes %4"PRIu64" := 1 * %4"PRIu64"] "
               "0x%016"PRIx64" * ...0x%016"PRIx64" = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k2,k1,a,b1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k2 == 0) printf("OK: [sizes %4"PRIu64" := 1 * %4"PRIu64"]\n",k2,k1);
        else printf("OK: [sizes %4"PRIu64" := 1 * %4"PRIu64"] 0x%016"PRIx64" * ...0x%016"PRIx64" = ...0x%016"PRIx64"\n",
                    k2,k1,a,b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cmod(void)
{ uint64_t t, k, r, j, m;
  printf("Testing bignum_cmod with %d cases\n",tests);
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     m = random64();
     if (m == 0) m += (1ull<<(rand() % 64));
     r = bignum_cmod(k,b0,m);
     bignum_copy(k+2,b1,k,b0);
     bignum_of_word(k+2,b2,m);
     reference_divmod(k+2,b4,b3,b1,b2); // b3 = x mod m

     j = (k == 0) ? 0 : k-1;
     if (r != b3[0])
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod %"PRIu64" = %"PRIu64" not %"PRIu64"\n",
               k,b0[j],b0[0],m,r,b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod %"PRIu64" = %"PRIu64"\n",
               k,b0[j],b0[0],m,r);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cmul(void)
{ uint64_t t, j, k1, k2, a;
  printf("Testing bignum_cmul with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k1 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     a = random64();
     random_bignum(k1,b1);
     random_bignum(k2,b2);
     for (j = 0; j < k2; ++j) b3[j] = b2[j] + 1;
     bignum_cmul(k2,b2,a,k1,b1);
     reference_cmul(k2,b3,a,k1,b1);
     c = reference_compare(k2,b2,k2,b3);
     if (c != 0)
      { printf("### Disparity: [sizes %4"PRIu64" := 1 * %4"PRIu64"] "
               "0x%016"PRIx64" * ...0x%016"PRIx64" = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k2,k1,a,b1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k2 == 0) printf("OK: [sizes %4"PRIu64" := 1 * %4"PRIu64"]\n",k2,k1);
        else printf("OK: [sizes %4"PRIu64" := 1 * %4"PRIu64"] 0x%016"PRIx64" * ...0x%016"PRIx64" = ...0x%016"PRIx64"\n",
                    k2,k1,a,b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cmul_p25519(void)
{ uint64_t i, k, m;
  printf("Testing bignum_cmul_p25519 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_25519);
     m = random64();
     bignum_cmul_p25519(b2,m,b0);
     reference_mul(k+1,b1,1,&m,k,b0);
     reference_copy(k+1,b3,k,p_25519);
     reference_mod(k+1,b4,b1,b3);
     reference_copy(k,b3,k+1,b4);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64" *  ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,m,b0[0],p_25519[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,m,b0[0],p_25519[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cmul_p25519_alt(void)
{ uint64_t i, k, m;
  printf("Testing bignum_cmul_p25519_alt with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_25519);
     m = random64();
     bignum_cmul_p25519_alt(b2,m,b0);
     reference_mul(k+1,b1,1,&m,k,b0);
     reference_copy(k+1,b3,k,p_25519);
     reference_mod(k+1,b4,b1,b3);
     reference_copy(k,b3,k+1,b4);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64" *  ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,m,b0[0],p_25519[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,m,b0[0],p_25519[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cmul_p256(void)
{ uint64_t i, k, m;
  printf("Testing bignum_cmul_p256 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_256);
     m = random64();
     bignum_cmul_p256(b2,m,b0);
     reference_mul(k+1,b1,1,&m,k,b0);
     reference_copy(k+1,b3,k,p_256);
     reference_mod(k+1,b4,b1,b3);
     reference_copy(k,b3,k+1,b4);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64" *  ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,m,b0[0],p_256[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,m,b0[0],p_256[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cmul_p256_alt(void)
{ uint64_t i, k, m;
  printf("Testing bignum_cmul_p256_alt with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_256);
     m = random64();
     bignum_cmul_p256_alt(b2,m,b0);
     reference_mul(k+1,b1,1,&m,k,b0);
     reference_copy(k+1,b3,k,p_256);
     reference_mod(k+1,b4,b1,b3);
     reference_copy(k,b3,k+1,b4);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64" *  ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,m,b0[0],p_256[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,m,b0[0],p_256[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cmul_p256k1(void)
{ uint64_t i, k, m;
  printf("Testing bignum_cmul_p256k1 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_256k1);
     m = random64();
     bignum_cmul_p256k1(b2,m,b0);
     reference_mul(k+1,b1,1,&m,k,b0);
     reference_copy(k+1,b3,k,p_256k1);
     reference_mod(k+1,b4,b1,b3);
     reference_copy(k,b3,k+1,b4);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64" *  ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,m,b0[0],p_256k1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,m,b0[0],p_256k1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cmul_p256k1_alt(void)
{ uint64_t i, k, m;
  printf("Testing bignum_cmul_p256k1_alt with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_256k1);
     m = random64();
     bignum_cmul_p256k1_alt(b2,m,b0);
     reference_mul(k+1,b1,1,&m,k,b0);
     reference_copy(k+1,b3,k,p_256k1);
     reference_mod(k+1,b4,b1,b3);
     reference_copy(k,b3,k+1,b4);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64" *  ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,m,b0[0],p_256k1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,m,b0[0],p_256k1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cmul_p384(void)
{ uint64_t i, k, m;
  printf("Testing bignum_cmul_p384 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 6;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_384);
     m = random64();
     bignum_cmul_p384(b2,m,b0);
     reference_mul(k+1,b1,1,&m,k,b0);
     reference_copy(k+1,b3,k,p_384);
     reference_mod(k+1,b4,b1,b3);
     reference_copy(k,b3,k+1,b4);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64" *  ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,m,b0[0],p_384[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,m,b0[0],p_384[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cmul_p384_alt(void)
{ uint64_t i, k, m;
  printf("Testing bignum_cmul_p384_alt with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 6;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_384);
     m = random64();
     bignum_cmul_p384_alt(b2,m,b0);
     reference_mul(k+1,b1,1,&m,k,b0);
     reference_copy(k+1,b3,k,p_384);
     reference_mod(k+1,b4,b1,b3);
     reference_copy(k,b3,k+1,b4);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64" *  ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,m,b0[0],p_384[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,m,b0[0],p_384[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cmul_p521(void)
{ uint64_t i, k, m;
  printf("Testing bignum_cmul_p521 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 9;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_521);
     m = random64();
     bignum_cmul_p521(b2,m,b0);
     reference_mul(k+1,b1,1,&m,k,b0);
     reference_copy(k+1,b3,k,p_521);
     reference_mod(k+1,b4,b1,b3);
     reference_copy(k,b3,k+1,b4);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64" *  ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,m,b0[0],p_521[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,m,b0[0],p_521[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cmul_p521_alt(void)
{ uint64_t i, k, m;
  printf("Testing bignum_cmul_p521_alt with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 9;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_521);
     m = random64();
     bignum_cmul_p521_alt(b2,m,b0);
     reference_mul(k+1,b1,1,&m,k,b0);
     reference_copy(k+1,b3,k,p_521);
     reference_mod(k+1,b4,b1,b3);
     reference_copy(k,b3,k+1,b4);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64" *  ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,m,b0[0],p_521[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,m,b0[0],p_521[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cmul_sm2(void)
{ uint64_t i, k, m;
  printf("Testing bignum_cmul_sm2 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_sm2);
     m = random64();
     bignum_cmul_sm2(b2,m,b0);
     reference_mul(k+1,b1,1,&m,k,b0);
     reference_copy(k+1,b3,k,p_sm2);
     reference_mod(k+1,b4,b1,b3);
     reference_copy(k,b3,k+1,b4);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64" *  ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,m,b0[0],p_sm2[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,m,b0[0],p_sm2[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_cmul_sm2_alt(void)
{ uint64_t i, k, m;
  printf("Testing bignum_cmul_sm2_alt with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_sm2);
     m = random64();
     bignum_cmul_sm2_alt(b2,m,b0);
     reference_mul(k+1,b1,1,&m,k,b0);
     reference_copy(k+1,b3,k,p_sm2);
     reference_mod(k+1,b4,b1,b3);
     reference_copy(k,b3,k+1,b4);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64" *  ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,m,b0[0],p_sm2[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,m,b0[0],p_sm2[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_coprime(void)
{ uint64_t i, k0, k1, kmin, kmax, c1, c2;
  printf("Testing bignum_coprime with %d cases\n",tests);
  for (i = 0; i < tests; ++i)
   { k0 = (unsigned) rand() % MAXSIZE;
     k1 = (unsigned) rand() % MAXSIZE;
     kmin = (k0 < k1) ? k0 : k1;
     kmax = (k0 < k1) ? k1 : k0;
     if (rand() & 1)
      { random_bignum(k0,b0);
        random_bignum(k1,b1);
      }
     else
      { random_bignum(k0/2,b2);
        random_bignum(k1/2,b3);
        random_bignum(kmin/2,b4);
        reference_mul(k0,b0,k0/2,b2,kmin/2,b4);
        reference_mul(k1,b1,k1/2,b3,kmin/2,b4);
      }
     reference_copy(kmax,b4,k0,b0);
     reference_copy(kmax,b5,k1,b1);
     c1 = bignum_coprime(k0,b0,k1,b1,b7);
     c2 = reference_coprime(kmax,b4,b5);
     if (c1 != c2)
      { printf("### Disparity: [sizes %4"PRIu64", %4"PRIu64"] "
               "coprime(...0x%016"PRIx64", ...0x%016"PRIx64") = %4"PRIu64" not %4"PRIu64"\n",
               k0,k1,b0[0],b1[0],c1,c2);
        return 1;

      }
     else if (VERBOSE)
      { if (kmax == 0) printf("OK: [sizes %4"PRIu64", %4"PRIu64"]\n",k0, k1);
        else printf
         ("OK: [size %4"PRIu64", %4"PRIu64"] coprime(...0x%016"PRIx64" , ...0x%016"PRIx64") = %4"PRIu64"\n",
            k0,k1,b0[0],b1[0],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_copy(void)
{ uint64_t t, k1, k2, d;
  printf("Testing bignum_copy with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k1 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     random_bignum(k1,b0);
     random_bignum(k2,b1);
     b0[k1] = d = random64();
     bignum_copy(k1,b0,k2,b1);
     c = (k2 <= k1) ? reference_compare(k1,b0,k2,b1)
                    : reference_compare(k1,b0,k1,b1);
     if (c != 0)
      { printf("### Disparity: [sizes %4"PRIu64" := %4"PRIu64"] "
               "....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k1,k2,b0[0],b1[0]);
        return 1;
      }
     else if (b0[k1] != d)
      { printf("### Disparity: [sizes %4"PRIu64" := %4"PRIu64"]: writes off end\n",k1,k2);
        return 1;
      }
     else if (VERBOSE)
      { if (k1 == 0 || k2 == 0) printf("OK: [sizes %4"PRIu64" := %4"PRIu64"]\n",k1,k2);
        else printf("OK: [sizes %4"PRIu64" := %4"PRIu64"] "
                    "....0x%016"PRIx64" = ...0x%016"PRIx64"\n",
               k1,k2,b0[0],b1[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_copy_row_from_table_specific(const char *name, uint64_t fixed_width,
    int width_multiple_of_8,
    void (*f)(uint64_t*, const uint64_t*, uint64_t, uint64_t, uint64_t))
{ uint64_t i, t;
  // The height, width, height*width of table
  uint64_t h, w, n;
  printf("Testing %s with %d cases\n", name, tests);
  int c;

  for (t = 0; t < tests; ++t)
   { // Use BUFFERSIZE instead of MAXSIZE because MAXSIZE is too small
     if (fixed_width) w = fixed_width;
     else {
       w = (uint64_t) rand() % (uint64_t)sqrt((double)BUFFERSIZE);
       if (width_multiple_of_8) w = w & ~7ull;
     }

     h = (uint64_t) rand() % (uint64_t)sqrt((double)BUFFERSIZE);
     if (h == 0) ++h;
     n = h * w;
     uint64_t *table = malloc(n * sizeof(uint64_t));
     for (i = 0; i < h; ++i)
       random_bignum(w,&table[w * i]);

     i = rand() % h;
     reference_copy(w,b1,w,&table[w * i]);
     f(b2, table, h, w, i);

     c = reference_compare(w,b2,w,b1);
     free(table);

     if (c != 0)
      { printf("### Disparity: [height %5"PRIu64", width %5"PRIu64"] "
               "table [%5"PRIu64"*%5"PRIu64"] = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               h, w, i, w, b2[0], b1[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [height %5"PRIu64", width %5"PRIu64"]", h, w);
        if (n == 0) printf("\n");
        else printf(" element [%5"PRIu64"*%5"PRIu64"] = .0x%016"PRIx64"\n",
                    i, w, b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_copy_row_from_table(void)
{
  return test_bignum_copy_row_from_table_specific("bignum_copy_row_from_table",
      0, 0, bignum_copy_row_from_table);
}

int test_bignum_copy_row_from_table_8n(void)
{
#ifdef __x86_64__
  return 1;
#else
  return test_bignum_copy_row_from_table_specific(
      "bignum_copy_row_from_table_8n", 0, 1,
      bignum_copy_row_from_table_8n);
#endif
}

#ifdef __x86_64__
int test_bignum_copy_row_from_table_16(void)
{ return 1;
}
#else
void _bignum_copy_row_from_table_16_wrapper(uint64_t *z, const uint64_t *table,
                                                 uint64_t height,
                                                 uint64_t width,
                                                 uint64_t index) {
  assert(width == 16);
  bignum_copy_row_from_table_16(z, table, height, index);
}

int test_bignum_copy_row_from_table_16(void)
{ return test_bignum_copy_row_from_table_specific(
      "bignum_copy_row_from_table_16", 16, 0,
      _bignum_copy_row_from_table_16_wrapper);
}
#endif

#ifdef __x86_64__
int test_bignum_copy_row_from_table_32(void)
{ return 1;
}
#else
void _bignum_copy_row_from_table_32_wrapper(uint64_t *z, const uint64_t *table,
                                                 uint64_t height,
                                                 uint64_t width,
                                                 uint64_t index) {
  assert(width == 32);
  bignum_copy_row_from_table_32(z, table, height, index);
}

int test_bignum_copy_row_from_table_32(void)
{ return test_bignum_copy_row_from_table_specific(
      "bignum_copy_row_from_table_32", 32, 0,
      _bignum_copy_row_from_table_32_wrapper);
}
#endif

int test_bignum_ctd(void)
{ uint64_t t, k;
  printf("Testing bignum_ctd with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     if (rand() & 1) random_sparse_bignum(k,b0); else random_bignum(k,b0);
     c1 = bignum_ctd(k,b0);
     c2 = reference_ctz(k,b0) >> 6;
     if (c1 != c2)
      { printf(
          "### Disparity: [size %4"PRIu64"] bignum_ctd(...0x%016"PRIx64") = %"PRIu64" not %"PRIu64"\n",
          k,b0[0],c1,c2);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] bignum_ctd(...0x%016"PRIx64") = %"PRIu64"\n",
                    k,b0[0],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_ctz(void)
{ uint64_t t, k;
  printf("Testing bignum_ctz with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     if (rand() & 1) random_sparse_bignum(k,b0); else random_bignum(k,b0);
     c1 = bignum_ctz(k,b0);
     c2 = reference_ctz(k,b0);
     if (c1 != c2)
      { printf(
          "### Disparity: [size %4"PRIu64"] bignum_ctz(...0x%016"PRIx64") = %"PRIu64" not %"PRIu64"\n",
          k,b0[0],c1,c2);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] bignum_ctz(...0x%016"PRIx64") = %"PRIu64"\n",
                    k,b0[0],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_deamont_p256(void)
{ uint64_t t;
  printf("Testing bignum_deamont_p256 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     bignum_deamont_p256(b4,b0);
     reference_of_word(4,b1,UINT64_C(1));
     reference_dmontmul(4,b3,b0,b1,p_256,i_256,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_deamont_p256_alt(void)
{ uint64_t t;
  printf("Testing bignum_deamont_p256_alt with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     bignum_deamont_p256_alt(b4,b0);
     reference_of_word(4,b1,UINT64_C(1));
     reference_dmontmul(4,b3,b0,b1,p_256,i_256,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_deamont_p256k1(void)
{ uint64_t t;
  printf("Testing bignum_deamont_p256k1 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     bignum_deamont_p256k1(b4,b0);
     reference_of_word(4,b1,UINT64_C(1));
     reference_dmontmul(4,b3,b0,b1,p_256k1,i_256k1,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_deamont_p384(void)
{ uint64_t t;
  printf("Testing bignum_deamont_p384 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(6,b0);
     bignum_deamont_p384(b4,b0);
     reference_of_word(6,b1,UINT64_C(1));
     reference_dmontmul(6,b3,b0,b1,p_384,i_384,b5);

     c = reference_compare(6,b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-384 * ...0x%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-384 * ...0x%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_deamont_p384_alt(void)
{ uint64_t t;
  printf("Testing bignum_deamont_p384_alt with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(6,b0);
     bignum_deamont_p384_alt(b4,b0);
     reference_of_word(6,b1,UINT64_C(1));
     reference_dmontmul(6,b3,b0,b1,p_384,i_384,b5);

     c = reference_compare(6,b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-384 * ...0x%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-384 * ...0x%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_deamont_p521(void)
{ uint64_t t;
  printf("Testing bignum_deamont_p521 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(9,b0);
     bignum_deamont_p521(b4,b0);
     reference_of_word(9,b1,UINT64_C(1));
     reference_dmontmul(9,b3,b0,b1,p_521,i_521,b5);

     c = reference_compare(9,b3,9,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-576 * ...0x%016"PRIx64" mod p_521 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[0],b4[8],b4[0],b3[8],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-576 * ...0x%016"PRIx64" mod p_521 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[0],b4[8],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_deamont_sm2(void)
{ uint64_t t;
  printf("Testing bignum_deamont_sm2 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     bignum_deamont_sm2(b4,b0);
     reference_of_word(4,b1,UINT64_C(1));
     reference_dmontmul(4,b3,b0,b1,p_sm2,i_sm2,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_demont(void)
{ uint64_t t, k;
  printf("Testing bignum_demont with %d cases\n",tests);
  int c = 0;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0); b0[0] |= 1; // b0 = m
     random_bignum(k,b1);             // b1 = raw x
     reference_copy(k,b2,k,b1);          // b2 = y = x in redc case
     reference_copy(2 * k,b3,k,b1);      // b3 = x as well, just reduction here
     reference_negmodinv(k,b4,b0);    // b4 = m' = negmodinv(m)
     bignum_demont(k,b5,b1,b0);        // b5 = output of function
     reference_copy(k,b7,k,b1);
     reference_of_word(k,b2,UINT64_C(1));

     reference_dmontmul(k,b3,b1,b2,b0,b4,b8);   // b3 = "reference" Montgomery

     c = reference_compare(k,b3,k,b5);
     if (c != 0)
      { printf("### Disparity (Montgomery redc): [size %4"PRIu64"]\n",k);
        printf("### Output is ...0x%016"PRIx64"\n",b5[0]);
        printf("### Reference ...0x%016"PRIx64"\n",b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] bignum_demont(...0x%016"PRIx64") wrt ...0x%016"PRIx64" = ...0x%016"PRIx64"\n",
                    k,b1[0],b0[0],b5[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_demont_p256(void)
{ uint64_t t;
  printf("Testing bignum_demont_p256 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b2);
     reference_mod(4,b0,b2,p_256);
     bignum_demont_p256(b4,b0);
     reference_of_word(4,b1,UINT64_C(1));
     reference_dmontmul(4,b3,b0,b1,p_256,i_256,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_demont_p256_alt(void)
{ uint64_t t;
  printf("Testing bignum_demont_p256_alt with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b2);
     reference_mod(4,b0,b2,p_256);
     bignum_demont_p256_alt(b4,b0);
     reference_of_word(4,b1,UINT64_C(1));
     reference_dmontmul(4,b3,b0,b1,p_256,i_256,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_demont_p256k1(void)
{ uint64_t t;
  printf("Testing bignum_demont_p256k1 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b2);
     reference_mod(4,b0,b2,p_256k1);
     bignum_demont_p256k1(b4,b0);
     reference_of_word(4,b1,UINT64_C(1));
     reference_dmontmul(4,b3,b0,b1,p_256k1,i_256k1,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_demont_p384(void)
{ uint64_t t;
  printf("Testing bignum_demont_p384 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(6,b2);
     reference_mod(6,b0,b2,p_384);
     bignum_demont_p384(b4,b0);
     reference_of_word(6,b1,UINT64_C(1));
     reference_dmontmul(6,b3,b0,b1,p_384,i_384,b5);

     c = reference_compare(6,b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-384 * ...0x%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-384 * ...0x%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_demont_p384_alt(void)
{ uint64_t t;
  printf("Testing bignum_demont_p384_alt with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(6,b2);
     reference_mod(6,b0,b2,p_384);
     bignum_demont_p384_alt(b4,b0);
     reference_of_word(6,b1,UINT64_C(1));
     reference_dmontmul(6,b3,b0,b1,p_384,i_384,b5);

     c = reference_compare(6,b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-384 * ...0x%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-384 * ...0x%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_demont_p521(void)
{ uint64_t t;
  printf("Testing bignum_demont_p521 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(9,b2);
     reference_mod(9,b0,b2,p_521);
     bignum_demont_p521(b4,b0);
     reference_of_word(9,b1,UINT64_C(1));
     reference_dmontmul(9,b3,b0,b1,p_521,i_521,b5);

     c = reference_compare(9,b3,9,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-576 * ...0x%016"PRIx64" mod p_521 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b4[8],b4[0],b3[8],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-576 * ...0x%016"PRIx64" mod p_521 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b4[8],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_demont_sm2(void)
{ uint64_t t;
  printf("Testing bignum_demont_sm2 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b2);
     reference_mod(4,b0,b2,p_sm2);
     bignum_demont_sm2(b4,b0);
     reference_of_word(4,b1,UINT64_C(1));
     reference_dmontmul(4,b3,b0,b1,p_sm2,i_sm2,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_digit(void)
{ uint64_t t, k, n;
  printf("Testing bignum_digit with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     n = random64();
     if (rand() & 3) n %= (k + 1);
     c1 = bignum_digit(k,b0,n);
     c2 = digit(k,b0,n);
     if (c1 != c2)
      { printf(
          "### Disparity: [size %4"PRIu64"] bignum_digit(...0x%016"PRIx64",%"PRIu64") = 0x%016"PRIx64" not 0x%016"PRIx64"\n",
          k,b0[0],n,c1,c2);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] bignum_digit(...0x%016"PRIx64",%"PRIu64") = 0x%016"PRIx64"\n",
                    k,b0[0],n,c1);
      }
   }
  printf("All OK\n");
  return 0;
}


int test_bignum_digitsize(void)
{ uint64_t t, k;
  printf("Testing bignum_digitsize with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     if (rand() & 1) random_sparse_bignum(k,b0); else random_bignum(k,b0);
     c1 = bignum_digitsize(k,b0);
     c2 = ((64 * k + 63) - reference_clz(k,b0)) / 64;
     if (c1 != c2)
      { printf(
          "### Disparity: [size %4"PRIu64"] bignum_digitsize(0x%016"PRIx64"...) = %"PRIu64" not %"PRIu64"\n",
          k,b0[k-1],c1,c2);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] bignum_digitsize(0x%016"PRIx64"...) = %"PRIu64"\n",
                    k,b0[k-1],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_divmod10(void)
{ uint64_t t, k, r, d, j, s;
  printf("Testing bignum_divmod10 with %d cases\n",tests);
  d = 10;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     reference_copy(k,b4,k,b0);
     reference_of_word(k,b1,d);
     reference_divmod(k,b3,b2,b0,b1);
     r = bignum_divmod10(k,b4);
     s = (k == 0) ? 0 : b2[0];
     j = (k == 0) ? 0 : k - 1;
    if (reference_compare(k,b3,k,b4) != 0)
      { printf("### Disparity in quotient: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" div %"PRIu64" = "
               "0x%016"PRIx64"...%016"PRIx64" rem %"PRIu64" not 0x%016"PRIx64"...%016"PRIx64" rem %"PRIu64"\n",
               k,b0[j],b0[0],d,b4[j],b4[0],r,b3[j],b3[0],s);
        return 1;
      }
     else if (r != s)
      { printf("### Disparity in modulus: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod %"PRIu64" = "
               "%"PRIu64" not %"PRIu64"\n",
               k,b0[j],b0[0],d,r,b2[0]);
        return 1;
     }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" div %"PRIu64" = "
               "0x%016"PRIx64"...%016"PRIx64", remainder %"PRIu64"\n",
               k,b0[j],b0[0],d,b4[j],b4[0],r);
      }
   }

  printf("All OK\n");
  return 0;
}

int test_bignum_double_p25519(void)
{ uint64_t i, k;
  printf("Testing bignum_double_p25519 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_25519);
     bignum_double_p25519(b2,b0);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b0);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_25519);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * 2 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_25519[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * 2 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_25519[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_double_p256(void)
{ uint64_t i, k;
  printf("Testing bignum_double_p256 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_256);
     bignum_double_p256(b2,b0);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b0);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_256);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * 2 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_256[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * 2 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_256[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_double_p256k1(void)
{ uint64_t i, k;
  printf("Testing bignum_double_p256k1 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_256k1);
     bignum_double_p256k1(b2,b0);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b0);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_256k1);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * 2 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_256k1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * 2 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_256k1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_double_p384(void)
{ uint64_t i, k;
  printf("Testing bignum_double_p384 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 6;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_384);
     bignum_double_p384(b2,b0);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b0);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_384);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * 2 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_384[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * 2 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_384[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_double_p521(void)
{ uint64_t i, k;
  printf("Testing bignum_double_p521 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 9;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_521);
     bignum_double_p521(b2,b0);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b0);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_521);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * 2 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_521[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * 2 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_521[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_double_sm2(void)
{ uint64_t i, k;
  printf("Testing bignum_double_sm2 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_sm2);
     bignum_double_sm2(b2,b0);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b0);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_sm2);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * 2 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_sm2[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * 2 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_sm2[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_emontredc_specific(const char *name, int is_8n, int ge_16,
                                   uint64_t (*f)(uint64_t, uint64_t *,
                                                 const uint64_t *, uint64_t)) {
  uint64_t t, k, w, tc;
  printf("Testing %s with %d cases\n", name, tests);

  int c;
  for (t = 0; t < tests; ++t) {
    k = (unsigned)rand() % MAXSIZE;
    if (is_8n) {
      k = (k >> 3) << 3;
      if (k == 0)
        k = 8;
      if (ge_16 && k < 16)
        k = 16;
    }

    random_bignum(k, b0);
    b0[0] |= 1;                // b0 = m
    w = word_negmodinv(b0[0]); // w = negated modular inverse
    random_bignum(2 * k, b4);  // b4 = initial z

    reference_copy(2 * k + 1, b1, 2 * k, b4); // b1 = longer copy of z_0
    reference_copy(2 * k + 1, b2, 2 * k, b4); // b2 = also longer copy of z_0

    tc = f(k, b4, b0, w);

    reference_madd(2 * k + 1, b1, k, b4, k, b0); // b1 = q * m + z_0

    c = ((b1[2 * k] == tc) && reference_eq_samelen(k, b4 + k, b1 + k) &&
         reference_iszero(k, b1));

    if (!c) {
      printf("### Disparity reducing modulo: [size %4" PRIu64 " -> %4" PRIu64
             "] "
             "...%016" PRIx64 " / 2^%" PRIu64 " mod ...%016" PRIx64
             " = ...%016" PRIx64 "\n",
             2 * k, k, b2[0], 64 * k, b0[0], b4[k]);
      return 1;
    } else if (VERBOSE) {
      printf("OK: [size %4" PRIu64 " -> %4" PRIu64 "] "
             "...%016" PRIx64 " / 2^%" PRIu64 " mod ...%016" PRIx64
             " = ...%016" PRIx64 "\n",
             2 * k, k, b2[0], 64 * k, b0[0], b4[0]);
    }
  }
  printf("All OK\n");
  return 0;
}

int test_bignum_emontredc(void)
{ return test_bignum_emontredc_specific("bignum_emontredc", 0, 0,
                                        bignum_emontredc);
}

int test_bignum_emontredc_8n(void)
{ return test_bignum_emontredc_specific("bignum_emontredc_8n", 1, 0,
                                        bignum_emontredc_8n);
}

#ifndef __x86_64__
uint64_t bignum_emontredc_8n_cdiff_wrapper (uint64_t k, uint64_t *z,
                                            const uint64_t *m, uint64_t w) {
  // b12 is a buffer that is not used by bignum_emontredc_specific.
  return bignum_emontredc_8n_cdiff(k, z, m, w, b12);
}
#endif

int test_bignum_emontredc_8n_cdiff(void)
{
#ifdef __x86_64__
  // Do not call the neon function to avoid a linking failure error.
  return 1;
#else
  return test_bignum_emontredc_specific("bignum_emontredc_8n_cdiff", 1, 1,
                                        bignum_emontredc_8n_cdiff_wrapper);
#endif
}

int test_bignum_eq(void)
{ uint64_t t, k1, k2;
  printf("Testing bignum_eq with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k1 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     random_bignum(k1,b0);
     random_bignum(k2,b1);
     if (rand() % 16 == 0) reference_copy(k1,b0,k2,b1);
     if (rand() % 16 == 0) reference_copy(k2,b1,k1,b0);
     if ((rand() % 16 == 0) && (k1 != 0)) ++b0[rand() % k1];
     if ((rand() % 16 == 0) && (k1 != 0)) --b0[rand() % k1];
     if ((rand() % 16 == 0) && (k2 != 0)) ++b1[rand() % k2];
     if ((rand() % 16 == 0) && (k2 != 0)) --b1[rand() % k2];
     c1 = bignum_eq(k1,b0,k2,b1);
     c2 = (reference_compare(k1,b0,k2,b1) == 0);
     if (c1 != c2)
      { printf("### Disparity: [sizes %4"PRIu64" == %4"PRIu64"] ...0x%016"PRIx64" == ...0x%016"PRIx64" <=> %"PRIx64" not %"PRIx64"\n",
               k1,k2,b0[0],b1[0],c1,c2);
        return 1;
      }
     else if (VERBOSE)
      { if (k1 == 0 || k2 == 0) printf("OK: [sizes %4"PRIu64" == %4"PRIu64" ]\n",k1,k2);
        else printf("OK: [sizes %4"PRIu64" == %4"PRIu64"] ...0x%016"PRIx64" == ...0x%016"PRIx64" <=> %"PRIx64"\n",
                    k1,k2,b0[0],b1[0],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_even(void)
{ uint64_t t, k;
  printf("Testing bignum_even with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     c1 = bignum_even(k,b0);
     c2 = !((k != 0) && (b0[0] & 1));
     if (c1 != c2)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_even(...0x%016"PRIx64") = %"PRIx64" not %"PRIx64"\n",
               k,b0[0],c1,c2);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK:[size %4"PRIu64"] "
               "bignum_even(...0x%016"PRIx64") = %"PRIx64"\n",
               k,b0[0],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_frombebytes_4(void)
{ uint64_t t;
  printf("Testing bignum_frombebytes_4 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     reference_bigendian(4,b3,b0);
     bignum_frombebytes_4(b4,(uint8_t *)b0);
     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_frombebytes_4(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] bignum_frombebytes_4(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_frombebytes_6(void)
{ uint64_t t;
  printf("Testing bignum_frombebytes_6 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(6,b0);
     reference_bigendian(6,b3,b0);
     bignum_frombebytes_6(b4,(uint8_t *)b0);
     c = reference_compare(6,b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_frombebytes_6(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[5],b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] bignum_frombebytes_6(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[5],b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_fromlebytes_4(void)
{ uint64_t t;
  printf("Testing bignum_fromlebytes_4 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     reference_littleendian(4,b3,b0);
     bignum_fromlebytes_4(b4,(uint8_t *)b0);
     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_fromlebytes_4(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] bignum_fromlebytes_4(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_fromlebytes_6(void)
{ uint64_t t;
  printf("Testing bignum_fromlebytes_6 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(6,b0);
     reference_littleendian(6,b3,b0);
     bignum_fromlebytes_6(b4,(uint8_t *)b0);
     c = reference_compare(6,b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_fromlebytes_6(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[5],b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] bignum_fromlebytes_6(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[5],b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_fromlebytes_p521(void)
{ uint64_t t;
  printf("Testing bignum_fromlebytes_p521 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(9,b0);
     reference_fromlebytes(9,b3,66,(uint8_t *)b0);
     bignum_fromlebytes_p521(b4,(uint8_t *)b0);
     c = reference_compare(9,b3,9,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_fromlebytes_p521(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[8],b0[0],b4[8],b4[0],b3[8],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] bignum_fromlebytes_p521(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[8],b0[0],b4[8],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_ge(void)
{ uint64_t t, k1, k2;
  printf("Testing bignum_ge with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k1 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     random_bignum(k1,b0);
     random_bignum(k2,b1);
     if (rand() % 16 == 0) reference_copy(k1,b0,k2,b1);
     if (rand() % 16 == 0) reference_copy(k2,b1,k1,b0);
     if ((rand() % 16 == 0) && (k1 != 0)) ++b0[rand() % k1];
     if ((rand() % 16 == 0) && (k1 != 0)) --b0[rand() % k1];
     if ((rand() % 16 == 0) && (k2 != 0)) ++b1[rand() % k2];
     if ((rand() % 16 == 0) && (k2 != 0)) --b1[rand() % k2];
     c1 = bignum_ge(k1,b0,k2,b1);
     c2 = (reference_compare(k1,b0,k2,b1) >= 0);
     if (c1 != c2)
      { printf("### Disparity: [sizes %4"PRIu64" >= %4"PRIu64"] ...0x%016"PRIx64" >= ...0x%016"PRIx64" <=> %"PRIx64" not %"PRIx64"\n",
               k1,k2,b0[0],b1[0],c1,c2);
        return 1;
      }
     else if (VERBOSE)
      { if (k1 == 0 || k2 == 0) printf("OK: [sizes %4"PRIu64" >= %4"PRIu64" ]\n",k1,k2);
        else printf("OK: [sizes %4"PRIu64" >= %4"PRIu64"] ...0x%016"PRIx64" >= ...0x%016"PRIx64" <=> %"PRIx64"\n",
                    k1,k2,b0[0],b1[0],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_gt(void)
{ uint64_t t, k1, k2;
  printf("Testing bignum_gt with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k1 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     random_bignum(k1,b0);
     random_bignum(k2,b1);
     if (rand() % 16 == 0) reference_copy(k1,b0,k2,b1);
     if (rand() % 16 == 0) reference_copy(k2,b1,k1,b0);
     if ((rand() % 16 == 0) && (k1 != 0)) ++b0[rand() % k1];
     if ((rand() % 16 == 0) && (k1 != 0)) --b0[rand() % k1];
     if ((rand() % 16 == 0) && (k2 != 0)) ++b1[rand() % k2];
     if ((rand() % 16 == 0) && (k2 != 0)) --b1[rand() % k2];
     c1 = bignum_gt(k1,b0,k2,b1);
     c2 = (reference_compare(k1,b0,k2,b1) > 0);
     if (c1 != c2)
      { printf("### Disparity: [sizes %4"PRIu64" > %4"PRIu64"] ...0x%016"PRIx64" > ...0x%016"PRIx64" <=> %"PRIx64" not %"PRIx64"\n",
               k1,k2,b0[0],b1[0],c1,c2);
        return 1;
      }
     else if (VERBOSE)
      { if (k1 == 0 || k2 == 0) printf("OK: [sizes %4"PRIu64" > %4"PRIu64" ]\n",k1,k2);
        else printf("OK: [sizes %4"PRIu64" > %4"PRIu64"] ...0x%016"PRIx64" > ...0x%016"PRIx64" <=> %"PRIx64"\n",
                    k1,k2,b0[0],b1[0],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_half_p256(void)
{ uint64_t i, k;
  printf("Testing bignum_half_p256 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_256);

     bignum_half_p256(b2,b0);

     reference_adc(k+1,b4,k,b2,k,b2,0);
     reference_copy(k+1,b5,k,p_256);
     reference_mod(k+1,b6,b4,b5);
     reference_copy(k,b3,k+1,b6);

     c = reference_compare(k,b3,k,b0);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2 * (...0x%016"PRIx64" / 2) mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_256[0],b3[0],b0[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "2 * (...0x%016"PRIx64" / 2) mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,b0[0],p_256[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_half_p256k1(void)
{ uint64_t i, k;
  printf("Testing bignum_half_p256k1 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_256k1);

     bignum_half_p256k1(b2,b0);

     reference_adc(k+1,b4,k,b2,k,b2,0);
     reference_copy(k+1,b5,k,p_256k1);
     reference_mod(k+1,b6,b4,b5);
     reference_copy(k,b3,k+1,b6);

     c = reference_compare(k,b3,k,b0);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2 * (...0x%016"PRIx64" / 2) mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_256k1[0],b3[0],b0[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "2 * (...0x%016"PRIx64" / 2) mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,b0[0],p_256k1[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_half_p384(void)
{ uint64_t i, k;
  printf("Testing bignum_half_p384 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 6;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_384);

     bignum_half_p384(b2,b0);
     reference_adc(k+1,b4,k,b2,k,b2,0);
     reference_copy(k+1,b5,k,p_384);;
     reference_mod(k+1,b6,b4,b5);
     reference_copy(k,b3,k+1,b6);

     c = reference_compare(k,b3,k,b0);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2 * (...0x%016"PRIx64" / 2) mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_384[0],b3[0],b0[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "2 * (...0x%016"PRIx64" / 2) mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,b0[0],p_384[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_half_p521(void)
{ uint64_t i, k;
  printf("Testing bignum_half_p521 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 9;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_521);

     bignum_half_p521(b2,b0);
     reference_adc(k+1,b4,k,b2,k,b2,0);
     reference_copy(k+1,b5,k,p_521);;
     reference_mod(k+1,b6,b4,b5);
     reference_copy(k,b3,k+1,b6);

     c = reference_compare(k,b3,k,b0);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2 * (...0x%016"PRIx64" / 2) mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_521[0],b3[0],b0[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "2 * (...0x%016"PRIx64" / 2) mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,b0[0],p_521[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_half_sm2(void)
{ uint64_t i, k;
  printf("Testing bignum_half_sm2 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_sm2);

     bignum_half_sm2(b2,b0);

     reference_adc(k+1,b4,k,b2,k,b2,0);
     reference_copy(k+1,b5,k,p_sm2);
     reference_mod(k+1,b6,b4,b5);
     reference_copy(k,b3,k+1,b6);

     c = reference_compare(k,b3,k,b0);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2 * (...0x%016"PRIx64" / 2) mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_sm2[0],b3[0],b0[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "2 * (...0x%016"PRIx64" / 2) mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,b0[0],p_sm2[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_inv_p25519(void)
{ uint64_t i, k;
  int c, d;
  printf("Testing bignum_inv_p25519 with %d cases\n",tests);

  for (i = 0; i < tests; ++i)
   { k = 4;
     bignum_copy(k,b0,k,p_25519);

     do random_bignum(k,b1);
     while (!reference_coprime(k,b1,b0));

     // Make sure to check the degenerate a = 1 cases occasionally
     if ((rand() & 0xFFF) < 1) reference_of_word(k,b1,UINT64_C(1));

     // Another pathological case worth re-checking
     // It makes some intermediate results > p_25519
     // for the current algorithm

     if ((rand() & 0xFFFF) < 1)
      { b1[3] = 0xfddfffffffffffff;
        b1[2] = 0xffffffffffffffff;
        b1[1] = 0xfffffffbffffffff;
        b1[0] = 0xffffefffffffffff;
      }

     bignum_inv_p25519(b2,b1);             // s with a * s == 1 (mod b)
     reference_mul(2 * k,b4,k,b1,k,b2);    // b4 = a * s
     reference_copy(2 * k,b5,k,b0);        // b5 = b (double-length)
     reference_mod(2 * k,b3,b4,b5);        // b3 = (a * s) mod b
     reference_modpowtwo(k,b4,0,b0);       // b4 = 1 mod b = 2^k mod b

     c = reference_compare(k,b3,k,b4);
     d = reference_le(k,p_25519,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0],b4[0]);
        return 1;
      }
     else if (d != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "congruent but not reduced modulo, top word 0x%016"PRIx64"\n",
               k,b2[3]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf
         ("OK: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_inv_p256(void)
{ uint64_t i, k;
  int c, d;
  printf("Testing bignum_inv_p256 with %d cases\n",tests);

  for (i = 0; i < tests; ++i)
   { k = 4;
     bignum_copy(k,b0,k,p_256);

     do random_bignum(k,b1);
     while (!reference_coprime(k,b1,b0));

     // Make sure to check the degenerate a = 1 cases occasionally
     if ((rand() & 0xFFF) < 1) reference_of_word(k,b1,UINT64_C(1));

     bignum_inv_p256(b2,b1);             // s with a * s == 1 (mod b)

     reference_mul(2 * k,b4,k,b1,k,b2);    // b4 = a * s
     reference_copy(2 * k,b5,k,b0);        // b5 = b (double-length)
     reference_mod(2 * k,b3,b4,b5);        // b3 = (a * s) mod b
     reference_modpowtwo(k,b4,0,b0);       // b4 = 1 mod b = 2^k mod b

     c = reference_compare(k,b3,k,b4);
     d = reference_le(k,p_256,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0],b4[0]);
        return 1;
      }
     else if (d != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "congruent but not reduced modulo, top word 0x%016"PRIx64"\n",
               k,b2[3]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf
         ("OK: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_inv_p384(void)
{ uint64_t i, k;
  int c, d;
  printf("Testing bignum_inv_p384 with %d cases\n",tests);

  for (i = 0; i < tests; ++i)
   { k = 6;
     bignum_copy(k,b0,k,p_384);

     do random_bignum(k,b1);
     while (!reference_coprime(k,b1,b0));

     // Make sure to check the degenerate a = 1 cases occasionally
     if ((rand() & 0xFFF) < 1) reference_of_word(k,b1,UINT64_C(1));

     bignum_inv_p384(b2,b1);             // s with a * s == 1 (mod b)

     reference_mul(2 * k,b4,k,b1,k,b2);    // b4 = a * s
     reference_copy(2 * k,b5,k,b0);        // b5 = b (double-length)
     reference_mod(2 * k,b3,b4,b5);        // b3 = (a * s) mod b
     reference_modpowtwo(k,b4,0,b0);       // b4 = 1 mod b = 2^k mod b

     c = reference_compare(k,b3,k,b4);
     d = reference_le(k,p_384,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0],b4[0]);
        return 1;
      }
     else if (d != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "congruent but not reduced modulo, top word 0x%016"PRIx64"\n",
               k,b2[3]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf
         ("OK: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_inv_p521(void)
{ uint64_t i, k;
  int c, d;
  printf("Testing bignum_inv_p521 with %d cases\n",tests);

  for (i = 0; i < tests; ++i)
   { k = 9;
     bignum_copy(k,b0,k,p_521);

     do random_bignum(k,b1);
     while (!reference_coprime(k,b1,b0));

     // Make sure to check the degenerate a = 1 cases occasionally
     if ((rand() & 0xFFF) < 1) reference_of_word(k,b1,UINT64_C(1));

     bignum_inv_p521(b2,b1);               // s with a * s == 1 (mod b)

     reference_mul(2 * k,b4,k,b1,k,b2);    // b4 = a * s
     reference_copy(2 * k,b5,k,b0);        // b5 = b (double-length)
     reference_mod(2 * k,b3,b4,b5);        // b3 = (a * s) mod b
     reference_modpowtwo(k,b4,0,b0);       // b4 = 1 mod b = 2^k mod b

     c = reference_compare(k,b3,k,b4);
     d = reference_le(k,p_521,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0],b4[0]);
        return 1;
      }
     else if (d != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "congruent but not reduced modulo, top word 0x%016"PRIx64"\n",
               k,b2[3]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf
         ("OK: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_inv_sm2(void)
{ uint64_t i, k;
  int c, d;
  printf("Testing bignum_inv_sm2 with %d cases\n",tests);

  for (i = 0; i < tests; ++i)
   { k = 4;
     bignum_copy(k,b0,k,p_sm2);

     do random_bignum(k,b1);
     while (!reference_coprime(k,b1,b0));

     // Make sure to check the degenerate a = 1 cases occasionally
     if ((rand() & 0xFFF) < 1) reference_of_word(k,b1,UINT64_C(1));

     bignum_inv_sm2(b2,b1);                // s with a * s == 1 (mod b)

     reference_mul(2 * k,b4,k,b1,k,b2);    // b4 = a * s
     reference_copy(2 * k,b5,k,b0);        // b5 = b (double-length)
     reference_mod(2 * k,b3,b4,b5);        // b3 = (a * s) mod b
     reference_modpowtwo(k,b4,0,b0);       // b4 = 1 mod b = 2^k mod b

     c = reference_compare(k,b3,k,b4);
     d = reference_le(k,p_sm2,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0],b4[0]);
        return 1;
      }
     else if (d != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "congruent but not reduced modulo, top word 0x%016"PRIx64"\n",
               k,b2[3]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf
         ("OK: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_invsqrt_p25519(void)
{ uint64_t i, k;
  printf("Testing bignum_invsqrt_p25519 with %d cases\n",tests);
  uint64_t c, d;
  uint64_t  l, r;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_25519);
     l = reference_legendre(k,b0,p_25519);
     r = bignum_invsqrt_p25519(b2,b0);

     reference_mul(2*k,b4,k,b2,k,b2);
     reference_copy(2*k,b3,k,p_25519);
     reference_mod(2*k,b5,b4,b3);
     reference_copy(k,b4,2*k,b5);       // b4 = b2^2

     reference_mul(2*k,b5,k,b4,k,b0);
     reference_mod(2*k,b4,b5,b3);
     reference_copy(k,b3,2*k,b4);       // b3 = b0 * b2^2

     reference_of_word(k,b4,1);         // b4 = 1

     c = reference_compare(k,b3,k,b4);
     d = reference_iszero(k,b3);

     if (l != r)
      { printf("### Disparity: [size %4"PRIu64"] "
               "legendre(...0x%016"PRIx64" / ....0x%016"PRIx64") = "
               "%"PRIi64" not %"PRIi64"\n",
               k,b0[0],p_25519[0],r,l);
        return 1;
      }
     else if ((l == 0) != d)
      { printf("### Disparity: [size %4"PRIu64"] "
               "Legendre symbol (%"PRIi64") versus result zeroness "
               "on ...0x%016"PRIx64"\n",
               k,l,b0[0]);
        return 1;
      }
     else if ((l == 1) && (c != 0))
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * ...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b2[0],p_25519[0],b3[0],b4[0]);
        return 1;
      }
     else if (b2[0] & 1)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" is odd (wrong choice of square root)\n",
               k,b2[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * ...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64" (%s)\n",
                    k,b0[2],b2[0],p_25519[0],b3[0],
                    ((l == -1) ? "nonresidue" :
                     (l == 1) ? "residue" :
                     (l == 0) ? "trivial" : "invalid"));
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_invsqrt_p25519_alt(void)
{ uint64_t i, k;
  printf("Testing bignum_invsqrt_p25519_alt with %d cases\n",tests);
  uint64_t c, d;
  uint64_t  l, r;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_25519);
     l = reference_legendre(k,b0,p_25519);
     r = bignum_invsqrt_p25519_alt(b2,b0);

     reference_mul(2*k,b4,k,b2,k,b2);
     reference_copy(2*k,b3,k,p_25519);
     reference_mod(2*k,b5,b4,b3);
     reference_copy(k,b4,2*k,b5);       // b4 = b2^2

     reference_mul(2*k,b5,k,b4,k,b0);
     reference_mod(2*k,b4,b5,b3);
     reference_copy(k,b3,2*k,b4);       // b3 = b0 * b2^2

     reference_of_word(k,b4,1);         // b4 = 1

     c = reference_compare(k,b3,k,b4);
     d = reference_iszero(k,b3);

     if (l != r)
      { printf("### Disparity: [size %4"PRIu64"] "
               "legendre(...0x%016"PRIx64" / ....0x%016"PRIx64") = "
               "%"PRIi64" not %"PRIi64"\n",
               k,b0[0],p_25519[0],r,l);
        return 1;
      }
     else if ((l == 0) != d)
      { printf("### Disparity: [size %4"PRIu64"] "
               "Legendre symbol (%"PRIi64") versus result zeroness "
               "on ...0x%016"PRIx64"\n",
               k,l,b0[0]);
        return 1;
      }
     else if ((l == 1) && (c != 0))
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * ...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b2[0],p_25519[0],b3[0],b4[0]);
        return 1;
      }
     else if (b2[0] & 1)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" is odd (wrong choice of square root)\n",
               k,b2[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * ...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64" (%s)\n",
                    k,b0[2],b2[0],p_25519[0],b3[0],
                    ((l == -1) ? "nonresidue" :
                     (l == 1) ? "residue" :
                     (l == 0) ? "trivial" : "invalid"));
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_iszero(void)
{ uint64_t t, k;
  printf("Testing bignum_iszero with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_sparse_bignum(k,b0);
     c1 = bignum_iszero(k,b0);
     c2 = reference_iszero(k,b0);
     if (c1 != c2)
      { printf("### Disparity: [size %4"PRIu64"] ...0x%016"PRIx64" = 0\n",
               k,b0[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] ...0x%016"PRIx64" = 0 <=> %"PRIx64"\n",
                    k,b0[0],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_kmul_specific
  (uint64_t p,uint64_t m,uint64_t n, char *name,
   void (*f)(uint64_t *,const uint64_t *, const uint64_t *,uint64_t *))
{ uint64_t i, j;
  printf("Testing %s with %d cases\n",name,tests);
  int c;
  for (i = 0; i < tests; ++i)
   { random_bignum(m,b0);
     random_bignum(n,b1);
     random_bignum(p,b2);
     for (j = 0; j < p; ++j) b3[j] = b2[j] + 1;
     (*f)(b2,b0,b1,b5);
     reference_mul(p,b3,m,b0,n,b1);
     c = reference_compare(p,b2,p,b3);
     if (c != 0)
      { printf("### Disparity: [sizes %4"PRIu64" x %4"PRIu64" -> %4"PRIu64"] "
               "...0x%016"PRIx64" * ...0x%016"PRIx64" = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               m,n,p,b0[0],b1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (p == 0) printf("OK: [size %4"PRIu64" x %4"PRIu64" -> %4"PRIu64"]\n",m,n,p);
        else printf("OK: [size %4"PRIu64" x %4"PRIu64" -> %4"PRIu64"] "
                    "...0x%016"PRIx64" * ...0x%016"PRIx64" =..0x%016"PRIx64"\n",
                    m,n,p,b0[0],b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_kmul_16_32(void)
{ return test_bignum_kmul_specific(32,16,16,"bignum_kmul_16_32",bignum_kmul_16_32);
}

int test_bignum_kmul_32_64(void)
{ return test_bignum_kmul_specific(64,32,32,"bignum_kmul_32_64",bignum_kmul_32_64);
}

int test_bignum_ksqr_specific
  (uint64_t p,uint64_t n, char *name,
   void (*f)(uint64_t *,const uint64_t *,uint64_t *))
{ uint64_t i, j;
  printf("Testing %s with %d cases\n",name,tests);
  int c;
  for (i = 0; i < tests; ++i)
   { random_bignum(n,b0);
     random_bignum(p,b2);
     for (j = 0; j < p; ++j) b3[j] = b2[j] + 1;
     (*f)(b2,b0,b5);
     reference_mul(p,b3,n,b0,n,b0);
     c = reference_compare(p,b2,p,b3);
     if (c != 0)
      { printf("### Disparity: [sizes %4"PRIu64" x %4"PRIu64" -> %4"PRIu64"] "
               "...0x%016"PRIx64"^2  = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               n,n,p,b0[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (p == 0) printf("OK: [size %4"PRIu64" x %4"PRIu64" -> %4"PRIu64"]\n",n,n,p);
        else printf("OK: [size %4"PRIu64" x %4"PRIu64" -> %4"PRIu64"] "
                    "...0x%016"PRIx64"^2 =..0x%016"PRIx64"\n",
                    n,n,p,b0[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_ksqr_16_32(void)
{ return test_bignum_ksqr_specific(32,16,"bignum_ksqr_16_32",bignum_ksqr_16_32);
}

int test_bignum_ksqr_32_64(void)
{ return test_bignum_ksqr_specific(64,32,"bignum_ksqr_32_64",bignum_ksqr_32_64);
}

int test_bignum_le(void)
{ uint64_t t, k1, k2;
  printf("Testing bignum_le with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k1 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     random_bignum(k1,b0);
     random_bignum(k2,b1);
     if (rand() % 16 == 0) reference_copy(k1,b0,k2,b1);
     if (rand() % 16 == 0) reference_copy(k2,b1,k1,b0);
     if ((rand() % 16 == 0) && (k1 != 0)) ++b0[rand() % k1];
     if ((rand() % 16 == 0) && (k1 != 0)) --b0[rand() % k1];
     if ((rand() % 16 == 0) && (k2 != 0)) ++b1[rand() % k2];
     if ((rand() % 16 == 0) && (k2 != 0)) --b1[rand() % k2];
     c1 = bignum_le(k1,b0,k2,b1);
     c2 = (reference_compare(k1,b0,k2,b1) <= 0);
     if (c1 != c2)
      { printf("### Disparity: [sizes %4"PRIu64" <= %4"PRIu64"] ...0x%016"PRIx64" <= ...0x%016"PRIx64" <=> %"PRIx64" not %"PRIx64"\n",
               k1,k2,b0[0],b1[0],c1,c2);
        return 1;
      }
     else if (VERBOSE)
      { if (k1 == 0 || k2 == 0) printf("OK: [sizes %4"PRIu64" <= %4"PRIu64" ]\n",k1,k2);
        else printf("OK: [sizes %4"PRIu64" <= %4"PRIu64"] ...0x%016"PRIx64" <= ...0x%016"PRIx64" <=> %"PRIx64"\n",
                    k1,k2,b0[0],b1[0],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_littleendian_4(void)
{ uint64_t t;
  printf("Testing bignum_littleendian_4 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     reference_littleendian(4,b3,b0);
     bignum_littleendian_4(b4,b0);
     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_littleendian_4(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] bignum_littleendian_4(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_littleendian_6(void)
{ uint64_t t;
  printf("Testing bignum_littleendian_6 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(6,b0);
     reference_littleendian(6,b3,b0);
     bignum_littleendian_6(b4,b0);
     c = reference_compare(6,b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_littleendian_6(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[5],b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] bignum_littleendian_6(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[5],b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_lt(void)
{ uint64_t t, k1, k2;
  printf("Testing bignum_lt with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k1 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     random_bignum(k1,b0);
     random_bignum(k2,b1);
     if (rand() % 16 == 0) reference_copy(k1,b0,k2,b1);
     if (rand() % 16 == 0) reference_copy(k2,b1,k1,b0);
     if ((rand() % 16 == 0) && (k1 != 0)) ++b0[rand() % k1];
     if ((rand() % 16 == 0) && (k1 != 0)) --b0[rand() % k1];
     if ((rand() % 16 == 0) && (k2 != 0)) ++b1[rand() % k2];
     if ((rand() % 16 == 0) && (k2 != 0)) --b1[rand() % k2];
     c1 = bignum_lt(k1,b0,k2,b1);
     c2 = (reference_compare(k1,b0,k2,b1) < 0);
     if (c1 != c2)
      { printf("### Disparity: [sizes %4"PRIu64" < %4"PRIu64"] ...0x%016"PRIx64" < ...0x%016"PRIx64" <=> %"PRIx64" not %"PRIx64"\n",
               k1,k2,b0[0],b1[0],c1,c2);
        return 1;
      }
     else if (VERBOSE)
      { if (k1 == 0 || k2 == 0) printf("OK: [sizes %4"PRIu64" < %4"PRIu64" ]\n",k1,k2);
        else printf("OK: [sizes %4"PRIu64" < %4"PRIu64"] ...0x%016"PRIx64" < ...0x%016"PRIx64" <=> %"PRIx64"\n",
                    k1,k2,b0[0],b1[0],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_madd(void)
{ uint64_t t, j, k0, k1, k2;
  printf("Testing bignum_madd with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k0 = (unsigned) rand() % MAXSIZE;
     k1 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     random_bignum(k0,b0);
     random_bignum(k1,b1);
     random_bignum(k2,b2);
     for (j = 0; j < k2; ++j) b3[j] = b2[j];

     bignum_madd(k2,b2,k0,b0,k1,b1);
     reference_madd(k2,b3,k0,b0,k1,b1);
     c = reference_compare(k2,b2,k2,b3);
     if (c != 0)
      { printf("### Disparity: [sizes %4"PRIu64" + %4"PRIu64" * %4"PRIu64"] "
               "... + ...0x%016"PRIx64" * ...0x%016"PRIx64" = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k2,k0,k1,b0[0],b1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k0 == 0 || k1 == 0 || k2 == 0) printf("OK: [sizes %4"PRIu64" + %4"PRIu64" * %4"PRIu64"]\n",k2,k0,k1);
        else printf("OK: [sizes %4"PRIu64" + %4"PRIu64" * %4"PRIu64"] ... + ...0x%016"PRIx64" * ...0x%016"PRIx64" = ...0x%016"PRIx64"\n",
                    k2,k0,k1,b0[0],b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_madd_n25519(void)
{ uint64_t t, k;
  printf("Testing bignum_madd_n25519 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = 4;
     random_bignum(8,b0);
     random_bignum(4,b1);
     random_bignum(4,b2);
     random_bignum(4,b3);
     bignum_madd_n25519(b0,b1,b2,b3);
     bignum_copy(9,b4,4,b3);
     reference_madd(9,b4,4,b1,4,b2);
     reference_copy(9,b5,4,n_25519);
     reference_mod(9,b6,b4,b5);
     reference_copy(4,b4,9,b6);
     c = reference_compare(4,b0,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64" -> %4"PRIu64"] "
               "(...0x%016"PRIx64" * ...%016"PRIx64" + ...%016"PRIx64") mod n_256 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b1[0],b2[0],b3[0],b0[3],b0[0],b4[3],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64" -> %4"PRIu64"] "
               "(...0x%016"PRIx64" * ...%016"PRIx64" + ...%016"PRIx64") mod n_256 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b1[0],b2[0],b3[0],b0[3],b0[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_madd_n25519_alt(void)
{ uint64_t t, k;
  printf("Testing bignum_madd_n25519_alt with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = 4;
     random_bignum(8,b0);
     random_bignum(4,b1);
     random_bignum(4,b2);
     random_bignum(4,b3);
     bignum_madd_n25519_alt(b0,b1,b2,b3);
     bignum_copy(9,b4,4,b3);
     reference_madd(9,b4,4,b1,4,b2);
     reference_copy(9,b5,4,n_25519);
     reference_mod(9,b6,b4,b5);
     reference_copy(4,b4,9,b6);
     c = reference_compare(4,b0,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64" -> %4"PRIu64"] "
               "(...0x%016"PRIx64" * ...%016"PRIx64" + ...%016"PRIx64") mod n_256 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b1[0],b2[0],b3[0],b0[3],b0[0],b4[3],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64" -> %4"PRIu64"] "
               "(...0x%016"PRIx64" * ...%016"PRIx64" + ...%016"PRIx64") mod n_256 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b1[0],b2[0],b3[0],b0[3],b0[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_m25519(void)
{ uint64_t t, k;
  printf("Testing bignum_mod_m25519 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     reference_copy(k,b1,4,m_25519);
     reference_mod(k,b3,b0,b1);
     bignum_mod_m25519(b4,k,b0);
     c = reference_compare(k,(k < 4) ? b0 : b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64" -> %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod m_25519 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64" -> %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod m_25519 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_m25519_4(void)
{ uint64_t t;
  printf("Testing bignum_mod_m25519_4 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     if ((rand() & 0xF) == 0) b0[3] |= UINT64_C(0xFFFFFFF000000000);
     else if ((rand() & 0xF) == 0)
      { b0[3] = m_25519[3];
        b0[2] = m_25519[2];
        b0[1] = m_25519[1];
        b0[0] = (m_25519[0] - UINT64_C(3)) + (rand() & UINT64_C(7));
      }

     reference_mod(4,b3,b0,m_25519);
     bignum_mod_m25519_4(b4,b0);
     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod m_25519 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod m_25519 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_n25519(void)
{ uint64_t t, k;
  printf("Testing bignum_mod_n25519 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     reference_copy(k,b1,4,n_25519);
     reference_mod(k,b3,b0,b1);
     bignum_mod_n25519(b4,k,b0);
     c = reference_compare(k,(k < 4) ? b0 : b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64" -> %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod n_25519 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64" -> %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod n_25519 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_n25519_4(void)
{ uint64_t t;
  printf("Testing bignum_mod_n25519_4 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     if ((rand() & 0xF) == 0) b0[3] |= UINT64_C(0xFFFFFFF000000000);
     else if ((rand() & 0xF) == 0)
      { b0[3] = n_25519[3];
        b0[2] = n_25519[2];
        b0[1] = n_25519[1];
        b0[0] = (n_25519[0] - UINT64_C(3)) + (rand() & UINT64_C(7));
      }

     reference_mod(4,b3,b0,n_25519);
     bignum_mod_n25519_4(b4,b0);
     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod n_25519 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod n_25519 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_n256(void)
{ uint64_t t, k;
  printf("Testing bignum_mod_n256 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     reference_copy(k,b1,4,n_256);
     reference_mod(k,b3,b0,b1);
     bignum_mod_n256(b4,k,b0);
     c = reference_compare(k,(k < 4) ? b0 : b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64" -> %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod n_256 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64" -> %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod n_256 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_n256_alt(void)
{ uint64_t t, k;
  printf("Testing bignum_mod_n256_alt with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     reference_copy(k,b1,4,n_256);
     reference_mod(k,b3,b0,b1);
     bignum_mod_n256_alt(b4,k,b0);
     c = reference_compare(k,(k < 4) ? b0 : b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64" -> %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod n_256 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64" -> %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod n_256 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_n256_4(void)
{ uint64_t t;
  printf("Testing bignum_mod_n256_4 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     if ((rand() & 0xF) == 0) b0[3] |= UINT64_C(0xFFFFFFF000000000);
     else if ((rand() & 0xF) == 0)
      { b0[3] = n_256[3];
        b0[2] = n_256[2];
        b0[1] = n_256[1];
        b0[0] = (n_256[0] - UINT64_C(3)) + (rand() & UINT64_C(7));
      }

     reference_mod(4,b3,b0,n_256);
     bignum_mod_n256_4(b4,b0);
     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod n_256 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod n_256 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_n256k1_4(void)
{ uint64_t t;
  printf("Testing bignum_mod_n256k1_4 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     if ((rand() & 0xF) == 0) b0[3] |= UINT64_C(0xFFFFFFF000000000);
     else if ((rand() & 0xF) == 0)
      { b0[3] = n_256k1[3];
        b0[2] = n_256k1[2];
        b0[1] = n_256k1[1];
        b0[0] = (n_256k1[0] - UINT64_C(3)) + (rand() & UINT64_C(7));
      }

     reference_mod(4,b3,b0,n_256k1);
     bignum_mod_n256k1_4(b4,b0);
     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod n_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod n_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_n384(void)
{ uint64_t t, k;
  printf("Testing bignum_mod_n384 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     reference_copy(k,b1,6,n_384);
     reference_mod(k,b3,b0,b1);
     bignum_mod_n384(b4,k,b0);
     c = reference_compare(k,(k < 6) ? b0 : b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64" -> %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod n_384 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(6),b0[k-1],b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64" -> %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod n_384 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(6),b0[k-1],b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_n384_alt(void)
{ uint64_t t, k;
  printf("Testing bignum_mod_n384_alt with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     reference_copy(k,b1,6,n_384);
     reference_mod(k,b3,b0,b1);
     bignum_mod_n384_alt(b4,k,b0);
     c = reference_compare(k,(k < 6) ? b0 : b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64" -> %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod n_384 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(6),b0[k-1],b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64" -> %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod n_384 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(6),b0[k-1],b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_n384_6(void)
{ uint64_t t;
  printf("Testing bignum_mod_n384_6 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(6,b0);
     if ((rand() & 0xF) == 0) b0[5] |= UINT64_C(0xFFFFFFFFFFFFFFFF);
     else if ((rand() & 0xF) == 0)
      { b0[5] = n_384[5];
        b0[4] = n_384[4];
        b0[3] = n_384[3];
        b0[2] = n_384[2];
        b0[1] = n_384[1];
        b0[0] = (n_384[0] - UINT64_C(3)) + (rand() & UINT64_C(7));
      }

     reference_mod(6,b3,b0,n_384);
     bignum_mod_n384_6(b4,b0);
     c = reference_compare(6,b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod n_384 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[5],b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod n_384 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[5],b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_n521_9(void)
{ uint64_t t;
  printf("Testing bignum_mod_n521_9 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(9,b0);
     if ((rand() & 0xF) == 0) b0[8] |= UINT64_C(0xFFFFFFFFFFFFFFFF);
     else if ((rand() & 0xF) == 0)
      { b0[8] = n_521[8];
        b0[7] = n_521[7];
        b0[6] = n_521[6];
        b0[5] = n_521[5];
        b0[4] = n_521[4];
        b0[3] = n_521[3];
        b0[2] = n_521[2];
        b0[1] = n_521[1];
        b0[0] = (n_521[0] - UINT64_C(3)) + (rand() & UINT64_C(7));
      }

     reference_mod(9,b3,b0,n_521);
     bignum_mod_n521_9(b4,b0);
     c = reference_compare(9,b3,9,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod n_521 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[8],b0[0],b4[8],b4[0],b3[8],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod n_521 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[8],b0[0],b4[8],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_n521_9_alt(void)
{ uint64_t t;
  printf("Testing bignum_mod_n521_9_alt with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(9,b0);
     if ((rand() & 0xF) == 0) b0[8] |= UINT64_C(0xFFFFFFFFFFFFFFFF);
     else if ((rand() & 0xF) == 0)
      { b0[8] = n_521[8];
        b0[7] = n_521[7];
        b0[6] = n_521[6];
        b0[5] = n_521[5];
        b0[4] = n_521[4];
        b0[3] = n_521[3];
        b0[2] = n_521[2];
        b0[1] = n_521[1];
        b0[0] = (n_521[0] - UINT64_C(3)) + (rand() & UINT64_C(7));
      }

     reference_mod(9,b3,b0,n_521);
     bignum_mod_n521_9_alt(b4,b0);
     c = reference_compare(9,b3,9,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod n_521 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[8],b0[0],b4[8],b4[0],b3[8],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod n_521 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[8],b0[0],b4[8],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_nsm2(void)
{ uint64_t t, k;
  printf("Testing bignum_mod_nsm2 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     reference_copy(k,b1,4,n_sm2);
     reference_mod(k,b3,b0,b1);
     bignum_mod_nsm2(b4,k,b0);
     c = reference_compare(k,(k < 4) ? b0 : b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64" -> %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod n_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64" -> %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod n_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_nsm2_alt(void)
{ uint64_t t, k;
  printf("Testing bignum_mod_nsm2_alt with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     reference_copy(k,b1,4,n_sm2);
     reference_mod(k,b3,b0,b1);
     bignum_mod_nsm2_alt(b4,k,b0);
     c = reference_compare(k,(k < 4) ? b0 : b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64" -> %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod n_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64" -> %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod n_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_nsm2_4(void)
{ uint64_t t;
  printf("Testing bignum_mod_nsm2_4 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     if ((rand() & 0xF) == 0) b0[3] |= UINT64_C(0xFFFFFFF000000000);
     else if ((rand() & 0xF) == 0)
      { b0[3] = n_sm2[3];
        b0[2] = n_sm2[2];
        b0[1] = n_sm2[1];
        b0[0] = (n_sm2[0] - UINT64_C(3)) + (rand() & UINT64_C(7));
      }

     reference_mod(4,b3,b0,n_sm2);
     bignum_mod_nsm2_4(b4,b0);
     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod n_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod n_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_p25519_4(void)
{ uint64_t t;
  printf("Testing bignum_mod_p25519_4 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     if ((rand() & 0xF) == 0)
      { b0[3] = p_25519[3];
        b0[2] = p_25519[2];
        b0[1] = p_25519[1];
        b0[0] = (p_25519[0] - UINT64_C(3)) + (rand() & UINT64_C(7));
      }

     reference_mod(4,b3,b0,p_25519);
     bignum_mod_p25519_4(b4,b0);
     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod p_25519 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod p_25519 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_p256(void)
{ uint64_t t, k;
  printf("Testing bignum_mod_p256 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     reference_copy(k,b1,4,p_256);
     reference_mod(k,b3,b0,b1);
     bignum_mod_p256(b4,k,b0);
     c = reference_compare(k,(k < 4) ? b0 : b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64" -> %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64" -> %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_p256_alt(void)
{ uint64_t t, k;
  printf("Testing bignum_mod_p256_alt with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     reference_copy(k,b1,4,p_256);
     reference_mod(k,b3,b0,b1);
     bignum_mod_p256_alt(b4,k,b0);
     c = reference_compare(k,(k < 4) ? b0 : b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64" -> %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64" -> %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_p256_4(void)
{ uint64_t t;
  printf("Testing bignum_mod_p256_4 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     if ((rand() & 0xF) == 0) b0[3] |= UINT64_C(0xFFFFFFF000000000);
     else if ((rand() & 0xF) == 0)
      { b0[3] = p_256[3];
        b0[2] = p_256[2];
        b0[1] = p_256[1];
        b0[0] = (p_256[0] - UINT64_C(3)) + (rand() & UINT64_C(7));
      }

     reference_mod(4,b3,b0,p_256);
     bignum_mod_p256_4(b4,b0);
     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_p256k1_4(void)
{ uint64_t t;
  printf("Testing bignum_mod_p256k1_4 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     if ((rand() & 0xF) == 0) b0[3] |= UINT64_C(0xFFFFFFF000000000);
     else if ((rand() & 0xF) == 0)
      { b0[3] = p_256k1[3];
        b0[2] = p_256k1[2];
        b0[1] = p_256k1[1];
        b0[0] = (p_256k1[0] - UINT64_C(3)) + (rand() & UINT64_C(7));
      }

     reference_mod(4,b3,b0,p_256k1);
     bignum_mod_p256k1_4(b4,b0);
     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_p384(void)
{ uint64_t t, k;
  printf("Testing bignum_mod_p384 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     reference_copy(k,b1,6,p_384);
     reference_mod(k,b3,b0,b1);
     bignum_mod_p384(b4,k,b0);
     c = reference_compare(k,(k < 6) ? b0 : b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64" -> %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(6),b0[k-1],b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64" -> %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(6),b0[k-1],b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_p384_alt(void)
{ uint64_t t, k;
  printf("Testing bignum_mod_p384_alt with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     reference_copy(k,b1,6,p_384);
     reference_mod(k,b3,b0,b1);
     bignum_mod_p384_alt(b4,k,b0);
     c = reference_compare(k,(k < 6) ? b0 : b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64" -> %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(6),b0[k-1],b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64" -> %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(6),b0[k-1],b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_p384_6(void)
{ uint64_t t;
  printf("Testing bignum_mod_p384_6 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(6,b0);
     if ((rand() & 0xF) == 0) b0[5] |= UINT64_C(0xFFFFFFFFFFFFFFFF);
     else if ((rand() & 0xF) == 0)
      { b0[5] = p_384[5];
        b0[4] = p_384[4];
        b0[3] = p_384[3];
        b0[2] = p_384[2];
        b0[1] = p_384[1];
        b0[0] = (p_384[0] - UINT64_C(3)) + (rand() & UINT64_C(7));
      }

     reference_mod(6,b3,b0,p_384);
     bignum_mod_p384_6(b4,b0);
     c = reference_compare(6,b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[5],b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[5],b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_p521_9(void)
{ uint64_t t;
  printf("Testing bignum_mod_p521_9 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(9,b0);
     if ((rand() & 0xF) == 0) b0[8] |= UINT64_C(0xFFFFFFFFFFFFFFFF);
     else if ((rand() & 0xF) == 0)
      { b0[8] = p_521[8];
        b0[7] = p_521[7];
        b0[6] = p_521[6];
        b0[5] = p_521[5];
        b0[4] = p_521[4];
        b0[3] = p_521[3];
        b0[2] = p_521[2];
        b0[1] = p_521[1];
        b0[0] = (p_521[0] - UINT64_C(3)) + (rand() & UINT64_C(7));
      }

     reference_mod(9,b3,b0,p_521);
     bignum_mod_p521_9(b4,b0);
     c = reference_compare(9,b3,9,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod p_521 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[8],b0[0],b4[8],b4[0],b3[8],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod p_521 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[8],b0[0],b4[8],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_sm2(void)
{ uint64_t t, k;
  printf("Testing bignum_mod_sm2 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     reference_copy(k,b1,4,p_sm2);
     reference_mod(k,b3,b0,b1);
     bignum_mod_sm2(b4,k,b0);
     c = reference_compare(k,(k < 4) ? b0 : b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64" -> %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64" -> %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,UINT64_C(4),b0[k-1],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mod_sm2_4(void)
{ uint64_t t;
  printf("Testing bignum_mod_sm2_4 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     if ((rand() & 0xF) == 0) b0[3] |= UINT64_C(0xFFFFFFF000000000);
     else if ((rand() & 0xF) == 0)
      { b0[3] = p_sm2[3];
        b0[2] = p_sm2[2];
        b0[1] = p_sm2[1];
        b0[0] = (p_sm2[0] - UINT64_C(3)) + (rand() & UINT64_C(7));
      }

     reference_mod(4,b3,b0,p_sm2);
     bignum_mod_sm2_4(b4,b0);
     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...%016"PRIx64" mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_modadd(void)
{ uint64_t i, k;
  printf("Testing bignum_modadd with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b2);
     random_bignum(k,b3); reference_divmod(k,b4,b0,b3,b2);
     random_bignum(k,b3); reference_divmod(k,b4,b1,b3,b2);

     reference_adc(k+1,b4,k,b0,k,b1,0);
     reference_copy(k+1,b5,k,b2);
     reference_divmod(k+1,b6,b7,b4,b5);
     reference_copy(k,b3,k+1,b7);

     bignum_modadd(k,b4,b0,b1,b2);
     c = reference_compare(k,b3,k,b4);

     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
         "(...0x%016"PRIx64" + ...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
         "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
        k,b0[0],b1[0],b2[0],b4[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        printf("OK: [size %4"PRIu64"] "
         "(...0x%016"PRIx64" + ...0x%016"PRIx64") mod ...0x%016"PRIx64" = ...0x%016"PRIx64"\n",
        k,b0[0],b1[0],b2[0],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_moddouble(void)
{ uint64_t i, k;
  printf("Testing bignum_moddouble with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b2);
     random_bignum(k,b3); reference_divmod(k,b4,b0,b3,b2);

     reference_adc(k+1,b4,k,b0,k,b0,0);
     reference_copy(k+1,b5,k,b2);
     reference_divmod(k+1,b6,b7,b4,b5);
     reference_copy(k,b3,k+1,b7);

     bignum_moddouble(k,b4,b0,b2);
     c = reference_compare(k,b3,k,b4);

     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
         "(2 * ...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
         "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
        k,b0[0],b2[0],b4[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        printf("OK: [size %4"PRIu64"] "
         "(2 * ...0x%016"PRIx64") mod ...0x%016"PRIx64" = ...0x%016"PRIx64"\n",
        k,b0[0],b2[0],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_modexp(void)
{ uint64_t i, k;
  printf("Testing bignum_modexp with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);       // a
     random_bignum(k,b1);       // p
     random_bignum(k,b2);       // m
     b2[0] |= 1;                // ...which is always odd

     bignum_modexp(k,b3,b0,b1,b2,b5);
     reference_modexp(k,b4,b0,b1,b2);
     c = reference_compare(k,b4,k,b3);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" ^ ...0x%016"PRIx64" mod ...0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],b2[0],b3[0],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "...0x%016"PRIx64" ^ ...0x%016"PRIx64" mod ...0x%016"PRIx64" = ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],b2[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_modifier(void)
{ uint64_t i, k, c;
  printf("Testing bignum_modifier with %d cases\n",tests);
  for (i = 0; i < tests; ++i)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0); b0[0] |= 1;

     bignum_modifier(k,b2,b0,b7); // b2 = test fun
     reference_modpowtwo(k,b3,64*k,b0); // Naive regerence

     c = reference_compare(k,b2,k,b3);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
           "bignum_modifier(...0x%016"PRIx64") = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
            k,b0[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] bignum_modifier(...0x%016"PRIx64") =..0x%016"PRIx64"\n",
                    k,b0[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_modinv(void)
{ uint64_t i, k;
  int c;
  printf("Testing bignum_modinv with %d cases\n",tests);

  for (i = 0; i < tests; ++i)
   { k = (unsigned) rand() % MAXSIZE + 1; // Size 0 cannot make sense
     random_bignum(k,b0), b0[0] |= 1;     // Modulus b, which has to be odd

     do random_bignum(k,b1);
     while (!reference_coprime(k,b1,b0));

     // Make sure to check the degenerate a = 1 and b = 1 cases occasionally
     if ((rand() & 0xFF) < 3) reference_of_word(k,b0,UINT64_C(1));
     if ((rand() & 0xFF) < 3) reference_of_word(k,b1,UINT64_C(1));

     bignum_modinv(k,b2,b1,b0,b7);        // s with a * s == 1 (mod b)
     reference_mul(2 * k,b4,k,b1,k,b2);    // b4 = a * s
     reference_copy(2 * k,b5,k,b0);        // b5 = b (double-length)
     reference_mod(2 * k,b3,b4,b5);        // b3 = (a * s) mod b
     reference_modpowtwo(k,b4,0,b0);       // b4 = 1 mod b = 2^k mod b

     c = reference_compare(k,b3,k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf
         ("OK: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_modoptneg(void)
{ uint64_t i, k, p;
  printf("Testing bignum_modoptneg with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b1);
     random_bignum(k,b4);
     reference_mod(k,b0,b4,b1);
     p = (rand() & 1) ? 0 :
         (rand() & 1) ? 1 :
         (rand() & 1) ? 2 : random64();
     bignum_modoptneg(k,b2,p,b0,b1);
     if ((p == 0) || reference_iszero(k,b0)) reference_copy(k,b3,k,b0);
     else reference_sub_samelen(k,b3,b1,b0);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "%s...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,(p ? "-" : "+"),b0[0],b1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "%s...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,(p ? "-" : "+"),b0[0],b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_modsub(void)
{ uint64_t i, k;
  printf("Testing bignum_modsub with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b2);
     random_bignum(k,b3); reference_divmod(k,b4,b0,b3,b2);
     random_bignum(k,b3); reference_divmod(k,b4,b1,b3,b2);

     reference_adc(k+1,b4,k,b0,k,b2,0);
     reference_sbb(k+1,b4,k+1,b4,k,b1,0);
     reference_copy(k+1,b5,k,b2);
     reference_divmod(k+1,b6,b7,b4,b5);
     reference_copy(k,b3,k+1,b7);

     bignum_modsub(k,b4,b0,b1,b2);
     c = reference_compare(k,b3,k,b4);

     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
         "(...0x%016"PRIx64" - ...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
         "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
        k,b0[0],b1[0],b2[0],b4[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        printf("OK: [size %4"PRIu64"] "
         "(...0x%016"PRIx64" - ...0x%016"PRIx64") mod ...0x%016"PRIx64" = ...0x%016"PRIx64"\n",
        k,b0[0],b1[0],b2[0],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montifier(void)
{ uint64_t i, k, c;
  printf("Testing bignum_montifier with %d cases\n",tests);
  for (i = 0; i < tests; ++i)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0); b0[0] |= 1;

     bignum_montifier(k,b2,b0,b7); // b2 = test fun
     reference_modpowtwo(k,b3,128*k,b0); // Naive regerence

     c = reference_compare(k,b2,k,b3);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
           "bignum_montifier(...0x%016"PRIx64") = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
            k,b0[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] bignum_montifier(...0x%016"PRIx64") =..0x%016"PRIx64"\n",
                    k,b0[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montinv_p256(void)
{ uint64_t i, k;
  int c, d;
  printf("Testing bignum_montinv_p256 with %d cases\n",tests);

  for (i = 0; i < tests; ++i)
   { k = 4;
     bignum_copy(k,b0,k,p_256);

     do random_bignum(k,b1);
     while (!reference_coprime(k,b1,b0));

     // Make sure to check the degenerate a = 1 cases occasionally
     if ((rand() & 0xFFF) < 1) reference_of_word(k,b1,UINT64_C(1));

     bignum_montinv_p256(b2,b1);           // s with a * s == 2^512 (mod b)

     reference_mul(2 * k,b4,k,b1,k,b2);    // b4 = a * s
     reference_copy(2 * k,b5,k,b0);        // b5 = b (double-length)
     reference_mod(2 * k,b3,b4,b5);        // b3 = (a * s) mod b
     reference_modpowtwo(k,b4,512,b0);     // b4 = 2^512 mod b

     c = reference_compare(k,b3,k,b4);
     d = reference_le(k,p_256,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0],b4[0]);
        return 1;
      }
     else if (d != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "congruent but not reduced modulo, top word 0x%016"PRIx64"\n",
               k,b2[3]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf
         ("OK: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montinv_p384(void)
{ uint64_t i, k;
  int c, d;
  printf("Testing bignum_montinv_p384 with %d cases\n",tests);

  for (i = 0; i < tests; ++i)
   { k = 6;
     bignum_copy(k,b0,k,p_384);

     do random_bignum(k,b1);
     while (!reference_coprime(k,b1,b0));

     // Make sure to check the degenerate a = 1 cases occasionally
     if ((rand() & 0xFFF) < 1) reference_of_word(k,b1,UINT64_C(1));

     bignum_montinv_p384(b2,b1);           // s with a * s == 2^768 (mod b)

     reference_mul(2 * k,b4,k,b1,k,b2);    // b4 = a * s
     reference_copy(2 * k,b5,k,b0);        // b5 = b (double-length)
     reference_mod(2 * k,b3,b4,b5);        // b3 = (a * s) mod b
     reference_modpowtwo(k,b4,768,b0);     // b4 = 2^768 mod b

     c = reference_compare(k,b3,k,b4);
     d = reference_le(k,p_384,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0],b4[0]);
        return 1;
      }
     else if (d != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "congruent but not reduced modulo, top word 0x%016"PRIx64"\n",
               k,b2[3]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf
         ("OK: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montinv_sm2(void)
{ uint64_t i, k;
  int c, d;
  printf("Testing bignum_montinv_sm2 with %d cases\n",tests);

  for (i = 0; i < tests; ++i)
   { k = 4;
     bignum_copy(k,b0,k,p_sm2);

     do random_bignum(k,b1);
     while (!reference_coprime(k,b1,b0));

     // Make sure to check the degenerate a = 1 cases occasionally
     if ((rand() & 0xFFF) < 1) reference_of_word(k,b1,UINT64_C(1));

     bignum_montinv_sm2(b2,b1);           // s with a * s == 2^512 (mod b)

     reference_mul(2 * k,b4,k,b1,k,b2);    // b4 = a * s
     reference_copy(2 * k,b5,k,b0);        // b5 = b (double-length)
     reference_mod(2 * k,b3,b4,b5);        // b3 = (a * s) mod b
     reference_modpowtwo(k,b4,512,b0);     // b4 = 2^512 mod b

     c = reference_compare(k,b3,k,b4);
     d = reference_le(k,p_sm2,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0],b4[0]);
        return 1;
      }
     else if (d != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "congruent but not reduced modulo, top word 0x%016"PRIx64"\n",
               k,b2[3]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf
         ("OK: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * modinv(...0x%016"PRIx64") mod ...0x%016"PRIx64" = "
               "....0x%016"PRIx64"\n",
               k,b1[0],b1[0],b0[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montmul(void)
{ uint64_t t, k;
  printf("Testing bignum_montmul with %d cases\n",tests);
  int c = 0;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0); b0[0] |= 1; // b0 = m
     random_bignum(k,b1);             // b1 = x
     random_bignum(k,b2);             // b2 = y
     reference_mul(2 * k,b3,k,b1,k,b2);  // b3 = z = x * y
     reference_negmodinv(k,b4,b0);    // b4 = m' = negmodinv(m)

     reference_copy(3 * k,b7,k,b0);                           // b7 = m
     reference_of_word(k,b8,0); reference_copy(2*k,b8+k,k,b1);   // b8 = R * x
     reference_of_word(k,b9,0); reference_copy(2*k,b9+k,k,b2);   // b9 = R * x
     reference_of_word(k,b10,0); reference_copy(2*k,b10+k,2*k,b3);   // b10 = R * z

     reference_divmod(3*k,b11,b12,b8,b7);
     reference_copy(k,b1,k,b12);                          // b1 = (R * x) MOD m
     reference_divmod(3*k,b11,b12,b9,b7);
     reference_copy(k,b2,k,b12);                          // b2 = (R * y) MOD m
     reference_divmod(3*k,b11,b12,b10,b7);
     reference_copy(k,b3,k,b12);                          // b3 = (R * z) MOD m
     bignum_montmul(k,b5,b1,b2,b0);           // b5 = function

     c = reference_compare(k,b3,k,b5);
     if (c != 0)
      { printf("### Disparity (Montgomery mul): [size %4"PRIu64"]\n",k);
        printf("### Output is ...0x%016"PRIx64"\n",b5[0]);
        printf("### Reference ...0x%016"PRIx64"\n",b3[0]);
        return 1;
      }
     else
      { printf("OK: [size %4"PRIu64"] bignum_montmul(...0x%016"PRIx64",...0x%016"PRIx64") wrt ...0x%016"PRIx64" = ...0x%016"PRIx64"\n",
                    k,b1[0],b2[0],b0[0],b5[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montmul_p256_specific(
    const char *name, void (*f)(uint64_t *, const uint64_t *, const uint64_t *))
{ uint64_t t;
  printf("Testing %s with %d cases\n",name,tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b2);
     reference_mod(4,b0,b2,p_256);
     random_bignum(4,b2);
     reference_mod(4,b1,b2,p_256);
     f(b4,b0,b1);
     reference_dmontmul(4,b3,b0,b1,p_256,i_256,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" * ...%016"PRIx64"  mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b1[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" * ...%016"PRIx64"  mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b1[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montmul_p256(void)
{ return test_bignum_montmul_p256_specific("bignum_montmul_p256",
      bignum_montmul_p256);
}

int test_bignum_montmul_p256_alt(void)
{ return test_bignum_montmul_p256_specific("bignum_montmul_p256_alt",
      bignum_montmul_p256_alt);
}

int test_bignum_montmul_p256k1(void)
{ uint64_t t;
  printf("Testing bignum_montmul_p256k1 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b2);
     reference_mod(4,b0,b2,p_256k1);
     random_bignum(4,b2);
     reference_mod(4,b1,b2,p_256k1);
     bignum_montmul_p256k1(b4,b0,b1);
     reference_dmontmul(4,b3,b0,b1,p_256k1,i_256k1,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" * ...%016"PRIx64"  mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b1[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" * ...%016"PRIx64"  mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b1[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montmul_p256k1_alt(void)
{ uint64_t t;
  printf("Testing bignum_montmul_p256k1_alt with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b2);
     reference_mod(4,b0,b2,p_256k1);
     random_bignum(4,b2);
     reference_mod(4,b1,b2,p_256k1);
     bignum_montmul_p256k1_alt(b4,b0,b1);
     reference_dmontmul(4,b3,b0,b1,p_256k1,i_256k1,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" * ...%016"PRIx64"  mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b1[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" * ...%016"PRIx64"  mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b1[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montmul_p384_specific(const char *name,
    void (*f)(uint64_t *z, const uint64_t *x, const uint64_t *y))
{ uint64_t t;
  printf("Testing %s with %d cases\n",name,tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(6,b2);
     reference_mod(6,b0,b2,p_384);
     random_bignum(6,b2);
     reference_mod(6,b1,b2,p_384);
     f(b4,b0,b1);
     reference_dmontmul(6,b3,b0,b1,p_384,i_384,b5);

     c = reference_compare(6,b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-384 * ...0x%016"PRIx64" * ...%016"PRIx64"  mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b1[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-384 * ...0x%016"PRIx64" * ...%016"PRIx64"  mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b1[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montmul_p384(void) {
  return test_bignum_montmul_p384_specific("bignum_montmul_p384",
                                           bignum_montmul_p384);
}

int test_bignum_montmul_p384_alt(void) {
  return test_bignum_montmul_p384_specific("bignum_montmul_p384_alt",
                                           bignum_montmul_p384_alt);
}

int test_bignum_montmul_p521_specific(const char *name,
                                      void (*f)(uint64_t *z, const uint64_t *x,
                                                const uint64_t *y)) {
  uint64_t t;
  printf("Testing %s with %d cases\n",name,tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(9,b2);
     reference_mod(9,b0,b2,p_521);
     random_bignum(9,b2);
     reference_mod(9,b1,b2,p_521);
     f(b4,b0,b1);
     reference_dmontmul(9,b3,b0,b1,p_521,i_521,b5);

     c = reference_compare(9,b3,9,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-576 * ...0x%016"PRIx64" * ...%016"PRIx64"  mod p_521 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[0],b1[0],b4[8],b4[0],b3[8],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-576 * ...0x%016"PRIx64" * ...%016"PRIx64"  mod p_521 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[0],b1[0],b4[8],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montmul_p521(void)
{ return test_bignum_montmul_p521_specific("bignum_montmul_p521",
                                           bignum_montmul_p521);
}

int test_bignum_montmul_p521_alt(void)
{ return test_bignum_montmul_p521_specific("bignum_montmul_p521_alt",
                                           bignum_montmul_p521_alt);
}

int test_bignum_montmul_sm2(void)
{ uint64_t t;
  printf("Testing bignum_montmul_sm2 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b2);
     reference_mod(4,b0,b2,p_sm2);
     random_bignum(4,b2);
     reference_mod(4,b1,b2,p_sm2);
     bignum_montmul_sm2(b4,b0,b1);
     reference_dmontmul(4,b3,b0,b1,p_sm2,i_sm2,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" * ...%016"PRIx64"  mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b1[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" * ...%016"PRIx64"  mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b1[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montmul_sm2_alt(void)
{ uint64_t t;
  printf("Testing bignum_montmul_sm2_alt with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b2);
     reference_mod(4,b0,b2,p_sm2);
     random_bignum(4,b2);
     reference_mod(4,b1,b2,p_sm2);
     bignum_montmul_sm2_alt(b4,b0,b1);
     reference_dmontmul(4,b3,b0,b1,p_sm2,i_sm2,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" * ...%016"PRIx64"  mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b1[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64" * ...%016"PRIx64"  mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b1[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montredc(void)
{ uint64_t t, k, n, p, r, q;
  printf("Testing bignum_montredc with %d cases\n",tests);

  int c, d;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     n = (unsigned) rand() % MAXSIZE;
     p = (unsigned) rand() % MAXSIZE;

     q = max(p+k,n) + 1;

     random_bignum(k,b0); b0[0] |= 1;  // b0 = m
     random_bignum(n,b1);              // b1 = x

     // To test strict Montgomery reduction make x <= 2^{64p} * n.
     // Actually this never hits the x = 2^{64p} * n case

     reference_copy(q,b3,k,b0);            // b3 = m
     reference_pow2(q,b4,64*p);            // b4 = 2^{64p}
     reference_mul(q,b2,q,b3,q,b4);        // b2 = 2^{64p} * m
     reference_copy(q,b3,n,b1);            // b3 = x
     reference_mod(q,b4,b3,b2);            // b4 = x mod (2^{64p} * m)
     reference_copy(n,b1,q,b4);

     bignum_montredc(k,b4,n,b1,b0,p); // b4 = test function

     r = max(p+k,n);

     reference_pow2(r,b2,64*p);            // b2 = 2^{64p}
     reference_mul(r,b3,r,b2,k,b4);        // b3 = 2^{64p} * z
     reference_copy(r,b2,min(n,p+k),b1);   // b2 = x' (truncated x)
     reference_copy(r,b5,k,b0);            // b5 = m
     reference_mod(r,b6,b2,b5);            // b6 = x mod m
     reference_mod(r,b7,b3,b5);            // b7 = (2^{64p} * z) mod m
     c = ((k != 0) && reference_compare(r,b6,r,b7));
     d = (k == 0) || reference_lt_samelen(k,b4,b0);
     if (c != 0)
      { printf("### Disparity even reducing modulo: [size %4"PRIu64" -> %4"PRIu64"] "
               "...%016"PRIx64" / 2^%"PRIu64" mod ...%016"PRIx64" = ...%016"PRIx64"\n",
               n,k,b1[0],64*p,b0[0],b4[0]);
        return 1;
      }
     if (d != 1)
      { printf("### Disparity with modular reduction: [size %4"PRIu64" -> %4"PRIu64"] "
               "...%016"PRIx64" / 2^%"PRIu64" mod ...%016"PRIx64" = ...%016"PRIx64"\n",
               n,k,b1[0],64*p,b0[0],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64" -> %4"PRIu64"] "
               "...%016"PRIx64" / 2^%"PRIu64" mod ...%016"PRIx64" = ...%016"PRIx64"\n",
               n,k,b1[0],64*p,b0[0],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montsqr(void)
{ uint64_t t, k;
  printf("Testing bignum_montsqr with %d cases\n",tests);
  int c = 0;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0); b0[0] |= 1; // b0 = m
     random_bignum(k,b2);             // b2 = raw x
     reference_mod(k,b1,b2,b0);          // b1 = x with < m
     reference_copy(k,b2,k,b1);          // b2 = y = x in squaring case
     reference_mul(2 * k,b3,k,b1,k,b2);  // b3 = z = x * y
     reference_negmodinv(k,b4,b0);    // b4 = m' = negmodinv(m)
     bignum_montsqr(k,b5,b1,b0);        // b5 = output of function
     reference_copy(k,b7,k,b1);
     reference_copy(k,b7,k,b2);
     reference_dmontmul(k,b3,b1,b2,b0,b4,b8);   // b3 = "reference" Montgomery

     c = reference_compare(k,b3,k,b5);
     if (c != 0)
      { printf("### Disparity (Montgomery sqr): [size %4"PRIu64"]\n",k);
        printf("### Output is ...0x%016"PRIx64"\n",b5[0]);
        printf("### Reference ...0x%016"PRIx64"\n",b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] bignum_montsqr(...0x%016"PRIx64") wrt ...0x%016"PRIx64" = ...0x%016"PRIx64"\n",
                    k,b1[0],b0[0],b5[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montsqr_p256_specific(const char *name,
    void (*f)(uint64_t *z, const uint64_t *x))
{ uint64_t t;
  printf("Testing %s with %d cases\n",name,tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b2);
     reference_mod(4,b0,b2,p_256);
     f(b4,b0);
     reference_dmontmul(4,b3,b0,b0,p_256,i_256,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64"^2 mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64"^2 mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montsqr_p256(void)
{ return test_bignum_montsqr_p256_specific("bignum_montsqr_p256",
      bignum_montsqr_p256);
}

int test_bignum_montsqr_p256_alt(void)
{ return test_bignum_montsqr_p256_specific("bignum_montsqr_p256_alt",
      bignum_montsqr_p256_alt);
}

int test_bignum_montsqr_p256k1(void)
{ uint64_t t;
  printf("Testing bignum_montsqr_p256k1 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b2);
     reference_mod(4,b0,b2,p_256k1);
     bignum_montsqr_p256k1(b4,b0);
     reference_dmontmul(4,b3,b0,b0,p_256k1,i_256k1,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64"^2 mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64"^2 mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montsqr_p256k1_alt(void)
{ uint64_t t;
  printf("Testing bignum_montsqr_p256k1_alt with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b2);
     reference_mod(4,b0,b2,p_256k1);
     bignum_montsqr_p256k1_alt(b4,b0);
     reference_dmontmul(4,b3,b0,b0,p_256k1,i_256k1,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64"^2 mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64"^2 mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montsqr_p384_specific(const char *name,
    void (*f)(uint64_t *z, const uint64_t *x))
{ uint64_t t;
  printf("Testing %s with %d cases\n",name,tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(6,b2);
     reference_mod(6,b0,b2,p_384);
     f(b4,b0);
     reference_dmontmul(6,b3,b0,b0,p_384,i_384,b5);

     c = reference_compare(6,b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-384 * ...0x%016"PRIx64"^2 mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-384 * ...0x%016"PRIx64"^2 mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montsqr_p384(void) {
  return test_bignum_montsqr_p384_specific("bignum_montsqr_p384",
                                           bignum_montsqr_p384);
}

int test_bignum_montsqr_p384_alt(void) {
  return test_bignum_montsqr_p384_specific("bignum_montsqr_p384_alt",
                                           bignum_montsqr_p384_alt);
}

int test_bignum_montsqr_p521_specific(const char *name,
                                      void (*f)(uint64_t *z, const uint64_t *x)) {
  uint64_t t;
  printf("Testing %s with %d cases\n",name,tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(9,b2);
     reference_mod(9,b0,b2,p_521);
     f(b4,b0);
     reference_dmontmul(9,b3,b0,b0,p_521,i_521,b5);

     c = reference_compare(9,b3,9,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-576 * ...0x%016"PRIx64"^2 mod p_521 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[0],b4[8],b4[0],b3[8],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-576 * ...0x%016"PRIx64"^2 mod p_521 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[0],b4[8],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montsqr_p521(void)
{ return test_bignum_montsqr_p521_specific("bignum_montsqr_p521",
                                           bignum_montsqr_p521);
}

int test_bignum_montsqr_p521_alt(void)
{ return test_bignum_montsqr_p521_specific("bignum_montsqr_p521_alt",
                                           bignum_montsqr_p521_alt);
}

int test_bignum_montsqr_sm2(void)
{ uint64_t t;
  printf("Testing bignum_montsqr_sm2 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b2);
     reference_mod(4,b0,b2,p_sm2);
     bignum_montsqr_sm2(b4,b0);
     reference_dmontmul(4,b3,b0,b0,p_sm2,i_sm2,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64"^2 mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64"^2 mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_montsqr_sm2_alt(void)
{ uint64_t t;
  printf("Testing bignum_montsqr_sm2_alt with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b2);
     reference_mod(4,b0,b2,p_sm2);
     bignum_montsqr_sm2_alt(b4,b0);
     reference_dmontmul(4,b3,b0,b0,p_sm2,i_sm2,b5);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64"^2 mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^-256 * ...0x%016"PRIx64"^2 mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mul(void)
{ uint64_t t, j, k0, k1, k2;
  printf("Testing bignum_mul with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k0 = (unsigned) rand() % MAXSIZE;
     k1 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     random_bignum(k0,b0);
     random_bignum(k1,b1);
     random_bignum(k2,b2);
     for (j = 0; j < k2; ++j) b3[j] = b2[j];
     bignum_mul(k2,b2,k0,b0,k1,b1);
     reference_mul(k2,b3,k0,b0,k1,b1);
     c = reference_compare(k2,b2,k2,b3);
     if (c != 0)
      { printf("### Disparity: [sizes %4"PRIu64" := %4"PRIu64" * %4"PRIu64"] "
               "...0x%016"PRIx64" * ...0x%016"PRIx64" = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k2,k0,k1,b0[0],b1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k0 == 0 || k1 == 0 || k2 == 0) printf("OK: [sizes %4"PRIu64" := %4"PRIu64" * %4"PRIu64"]\n",k2,k0,k1);
        else printf("OK: [sizes %4"PRIu64" := %4"PRIu64" * %4"PRIu64"] ...0x%016"PRIx64" * ...0x%016"PRIx64" = ...0x%016"PRIx64"\n",
                    k2,k0,k1,b0[0],b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mul_specific
  (uint64_t p,uint64_t m,uint64_t n, char *name,
   void (*f)(uint64_t *,const uint64_t *,const uint64_t *))
{ uint64_t i, j;
  printf("Testing %s with %d cases\n",name,tests);
  int c;
  for (i = 0; i < tests; ++i)
   { random_bignum(m,b0);
     random_bignum(n,b1);
     random_bignum(p,b2);
     for (j = 0; j < p; ++j) b3[j] = b2[j] + 1;
     (*f)(b2,b0,b1);
     reference_mul(p,b3,m,b0,n,b1);
     c = reference_compare(p,b2,p,b3);
     if (c != 0)
      { printf("### Disparity: [sizes %4"PRIu64" x %4"PRIu64" -> %4"PRIu64"] "
               "...0x%016"PRIx64" * ...0x%016"PRIx64" = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               m,n,p,b0[0],b1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (p == 0) printf("OK: [size %4"PRIu64" x %4"PRIu64" -> %4"PRIu64"]\n",m,n,p);
        else printf("OK: [size %4"PRIu64" x %4"PRIu64" -> %4"PRIu64"] "
                    "...0x%016"PRIx64" * ...0x%016"PRIx64" =..0x%016"PRIx64"\n",
                    m,n,p,b0[0],b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mul_4_8(void)
{ return test_bignum_mul_specific(8,4,4,"bignum_mul_4_8",bignum_mul_4_8);
}

int test_bignum_mul_4_8_alt(void)
{ return test_bignum_mul_specific(8,4,4,"bignum_mul_4_8_alt",bignum_mul_4_8_alt);
}

int test_bignum_mul_6_12(void)
{ return test_bignum_mul_specific(12,6,6,"bignum_mul_6_12",bignum_mul_6_12);
}

int test_bignum_mul_6_12_alt(void)
{ return test_bignum_mul_specific(12,6,6,"bignum_mul_6_12_alt",bignum_mul_6_12_alt);
}

int test_bignum_mul_8_16(void)
{ return test_bignum_mul_specific(16,8,8,"bignum_mul_8_16",bignum_mul_8_16);
}

int test_bignum_mul_8_16_alt(void)
{ return test_bignum_mul_specific(16,8,8,"bignum_mul_8_16_alt",bignum_mul_8_16_alt);
}

int test_bignum_mul_p25519(void) {
  uint64_t i, k;
  printf("Testing bignum_mul_p25519 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b0);
     random_bignum(k,b1);
     bignum_mul_p25519(b2,b0,b1);
     reference_mul(2*k,b4,k,b0,k,b1);
     reference_copy(2*k,b3,k,p_25519);
     reference_mod(2*k,b5,b4,b3);
     reference_copy(k,b3,2*k,b5);
     c = reference_compare(k,b3,k,b2);

     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],p_25519[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],p_25519[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mul_p25519_alt(void)
{ uint64_t i, k;
  printf("Testing bignum_mul_p25519_alt with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b0);
     random_bignum(k,b1);
     bignum_mul_p25519_alt(b2,b0,b1);
     reference_mul(2*k,b4,k,b0,k,b1);
     reference_copy(2*k,b3,k,p_25519);
     reference_mod(2*k,b5,b4,b3);
     reference_copy(k,b3,2*k,b5);
     c = reference_compare(k,b3,k,b2);

     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],p_25519[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],p_25519[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mul_p256k1(void)
{ uint64_t i, k;
  printf("Testing bignum_mul_p256k1 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b0);
     random_bignum(k,b1);
     bignum_mul_p256k1(b2,b0,b1);
     reference_mul(2*k,b4,k,b0,k,b1);
     reference_copy(2*k,b3,k,p_256k1);
     reference_mod(2*k,b5,b4,b3);
     reference_copy(k,b3,2*k,b5);
     c = reference_compare(k,b3,k,b2);

     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],p_256k1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],p_256k1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mul_p256k1_alt(void)
{ uint64_t i, k;
  printf("Testing bignum_mul_p256k1_alt with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b0);
     random_bignum(k,b1);
     bignum_mul_p256k1_alt(b2,b0,b1);
     reference_mul(2*k,b4,k,b0,k,b1);
     reference_copy(2*k,b3,k,p_256k1);
     reference_mod(2*k,b5,b4,b3);
     reference_copy(k,b3,2*k,b5);
     c = reference_compare(k,b3,k,b2);

     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],p_256k1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],p_256k1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mul_p521_specific(const char *name,
                                  void (*f)(uint64_t *z, const uint64_t *x,
                                            const uint64_t *y))
{ uint64_t i, k;
  printf("Testing %s with %d cases\n",name,tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 9;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_521);
     random_bignum(k,b2); reference_mod(k,b1,b2,p_521);
     f(b2,b0,b1);
     reference_mul(2*k,b4,k,b0,k,b1);
     reference_copy(2*k,b3,k,p_521);
     reference_mod(2*k,b5,b4,b3);
     reference_copy(k,b3,2*k,b5);
     c = reference_compare(k,b3,k,b2);

     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],p_521[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],p_521[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mul_p521(void)
{ return test_bignum_mul_p521_specific("bignum_mul_p521", bignum_mul_p521);
}

int test_bignum_mul_p521_alt(void)
{ return test_bignum_mul_p521_specific("bignum_mul_p521_alt", bignum_mul_p521_alt);
}

int test_bignum_muladd10(void)
{ uint64_t t, k, r, d, j, s;
  printf("Testing bignum_muladd10 with %d cases\n",tests);
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     d = random64();
     bignum_copy(k,b4,k,b0);
     bignum_of_word(k+1,b3,d);
     reference_cmadd(k+1,b3,10,k,b0);
     r = bignum_muladd10(k,b4,d);
     j = (k == 0) ? 0 : k - 1;
     s = b3[k];
     if (reference_compare(k,b3,k,b4) != 0)
      { printf("### Disparity in product: [size %4"PRIu64"] "
               "10 * 0x%016"PRIx64"...%016"PRIx64" + %"PRIu64" = "
               "0x%016"PRIx64"...%016"PRIx64" carry %"PRIu64" not 0x%016"PRIx64"...%016"PRIx64" carry %"PRIu64"\n",
               k,b0[j],b0[0],d,b4[j],b4[0],r,b3[j],b3[0],s);
        return 1;
      }
     else if (r != s)
      { printf("### Disparity in carry: [size %4"PRIu64"] "
               "10 * 0x%016"PRIx64"...%016"PRIx64" + %"PRIu64" = "
               "%"PRIu64" not %"PRIu64"\n",
               k,b0[j],b0[0],d,r,b2[0]);
        return 1;
     }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] 10 * 0x%016"PRIx64"...%016"PRIx64" + %"PRIu64" = "
               "0x%016"PRIx64"...%016"PRIx64", carry %"PRIu64"\n",
               k,b0[j],b0[0],d,b4[j],b4[0],r);
      }
   }

  printf("All OK\n");
  return 0;
}

int test_bignum_mux(void)
{ uint64_t i, n;
  printf("Testing bignum_mux with %d cases\n",tests);
  int b, c;
  for (i = 0; i < tests; ++i)
   { n = (unsigned) rand() % MAXSIZE;
     random_bignum(n,b0);
     random_bignum(n,b1);
     b = rand() & 1;
     bignum_mux(b,n,b2,b0,b1);
     c = (b ? reference_compare(n,b2,n,b0)
            : reference_compare(n,b2,n,b1));

     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "if %d then ...0x%016"PRIx64" else ...0x%016"PRIx64" = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               n,b,b0[0],b1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (n == 0) printf("OK: [size %4"PRIu64"]\n",n);
        else printf("OK: [size %4"PRIu64"] if %d then ...0x%016"PRIx64" else ...0x%016"PRIx64" =..0x%016"PRIx64"\n",
                    n,b,b0[0],b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

// Test size-4 multiplexing function

int test_bignum_mux_4(void)
{ uint64_t i, n;
  printf("Testing bignum_mux_4 with %d cases\n",tests);
  int b, c;
  for (i = 0; i < tests; ++i)
   { n = 4;
     random_bignum(n,b0);
     random_bignum(n,b1);
     b = rand() & 1;
     bignum_mux_4(b,b2,b0,b1);
     c = (b ? reference_compare(n,b2,n,b0)
            : reference_compare(n,b2,n,b1));

     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "if %d then ...0x%016"PRIx64" else ...0x%016"PRIx64" = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               n,b,b0[0],b1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (n == 0) printf("OK: [size %4"PRIu64"]\n",n);
        else printf("OK: [size %4"PRIu64"] if %d then ...0x%016"PRIx64" else ...0x%016"PRIx64" =..0x%016"PRIx64"\n",
                    n,b,b0[0],b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

// Test size-6 multiplexing function

int test_bignum_mux_6(void)
{ uint64_t i, n;
  printf("Testing bignum_mux_6 with %d cases\n",tests);
  int b, c;
  for (i = 0; i < tests; ++i)
   { n = 6;
     random_bignum(n,b0);
     random_bignum(n,b1);
     b = rand() & 1;
     bignum_mux_6(b,b2,b0,b1);
     c = (b ? reference_compare(n,b2,n,b0)
            : reference_compare(n,b2,n,b1));

     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "if %d then ...0x%016"PRIx64" else ...0x%016"PRIx64" = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               n,b,b0[0],b1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (n == 0) printf("OK: [size %4"PRIu64"]\n",n);
        else printf("OK: [size %4"PRIu64"] if %d then ...0x%016"PRIx64" else ...0x%016"PRIx64" =..0x%016"PRIx64"\n",
                    n,b,b0[0],b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_mux16(void)
{ uint64_t i, k, t;
  printf("Testing bignum_mux16 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     uint64_t *bs = malloc(16 * k * sizeof(uint64_t));
     for (i = 0; i < 16; ++i)
       random_bignum(k,bs+k*i);
     i = rand() & 15;
     reference_copy(k,b1,k,bs+k*i);
     bignum_mux16(k,b2,bs,i);
     free(bs);

     c = reference_compare(k,b2,k,b1);

     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "element [%4"PRIu64"] = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,i,b2[0],b1[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] element [%4"PRIu64"] = .0x%016"PRIx64"\n",
                    k,i,b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_neg_p25519(void)
{ uint64_t i, k;
  printf("Testing bignum_neg_p25519 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_25519);
     if ((rand() & 0x1F) == 0) reference_of_word(k,b0,0);

     bignum_neg_p25519(b2,b0);
     if (reference_iszero(k,b0)) reference_copy(k,b3,k,b0);
     else reference_sub_samelen(k,b3,p_25519,b0);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "- ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_25519[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,b0[0],p_25519[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_neg_p256(void)
{ uint64_t i, k;
  printf("Testing bignum_neg_p256 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_256);
     if ((rand() & 0x1F) == 0) reference_of_word(k,b0,0);

     bignum_neg_p256(b2,b0);
     if (reference_iszero(k,b0)) reference_copy(k,b3,k,b0);
     else reference_sub_samelen(k,b3,p_256,b0);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "- ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_256[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,b0[0],p_256[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_neg_p256k1(void)
{ uint64_t i, k;
  printf("Testing bignum_neg_p256k1 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_256k1);
     if ((rand() & 0x1F) == 0) reference_of_word(k,b0,0);

     bignum_neg_p256k1(b2,b0);
     if (reference_iszero(k,b0)) reference_copy(k,b3,k,b0);
     else reference_sub_samelen(k,b3,p_256k1,b0);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "- ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_256k1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,b0[0],p_256k1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_neg_p384(void)
{ uint64_t i, k;
  printf("Testing bignum_neg_p384 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 6;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_384);
     if ((rand() & 0x1F) == 0) reference_of_word(k,b0,0);

     bignum_neg_p384(b2,b0);
     if (reference_iszero(k,b0)) reference_copy(k,b3,k,b0);
     else reference_sub_samelen(k,b3,p_384,b0);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "- ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_384[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,b0[0],p_384[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_neg_p521(void)
{ uint64_t i, k;
  printf("Testing bignum_neg_p521 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 9;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_521);
     if ((rand() & 0x1F) == 0) reference_of_word(k,b0,0);

     bignum_neg_p521(b2,b0);
     if (reference_iszero(k,b0)) reference_copy(k,b3,k,b0);
     else reference_sub_samelen(k,b3,p_521,b0);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "- ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_521[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,b0[0],p_521[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_neg_sm2(void)
{ uint64_t i, k;
  printf("Testing bignum_neg_sm2 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_sm2);
     if ((rand() & 0x1F) == 0) reference_of_word(k,b0,0);

     bignum_neg_sm2(b2,b0);
     if (reference_iszero(k,b0)) reference_copy(k,b3,k,b0);
     else reference_sub_samelen(k,b3,p_sm2,b0);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "- ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_sm2[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,b0[0],p_sm2[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_negmodinv(void)
{ uint64_t t, i, k;
  printf("Testing bignum_negmodinv  with %d cases\n",tests);
  int c = 0;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0); b0[0] |= 1;
     bignum_negmodinv(k,b1,b0);
     b2[0] = 1; for (i = 1; i < k; ++i) b2[i] = 0;
     reference_madd(k,b2,k,b1,k,b0);
     c = 0; for (i = 0; i < k; ++i) if (b2[i] != 0) c = 1;
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * ...0x%016"PRIx64" + 1 = ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],b2[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * ...0x%016"PRIx64" + 1 = ...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_nonzero(void)
{ uint64_t t, k;
  printf("Testing bignum_nonzero with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_sparse_bignum(k,b0);
     c1 = bignum_nonzero(k,b0);
     c2 = !reference_iszero(k,b0);
     if (c1 != c2)
      { printf("### Disparity: [size %4"PRIu64"] ...0x%016"PRIx64" = 0\n",
               k,b0[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] ...0x%016"PRIx64" = 0 <=> %"PRIx64"\n",
                    k,b0[0],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_nonzero_4(void)
{ uint64_t t, k;
  printf("Testing bignum_nonzero_4 with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k = 4;
     if (rand() & 1) random_sparse_bignum(k,b0);
     else random_bignum(k,b0);
     c1 = bignum_nonzero_4(b0);
     c2 = !reference_iszero(k,b0);
     if (c1 != c2)
      { printf("### Disparity: [size %4"PRIu64"] 0x%016"PRIx64"...0x%016"PRIx64" = 0\n",
               k,b0[3],b0[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...0x%016"PRIx64" = 0 <=> %"PRIx64"\n",
                    k,b0[3],b0[0],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_nonzero_6(void)
{ uint64_t t, k;
  printf("Testing bignum_nonzero_6 with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k = 6;
     if (rand() & 1) random_sparse_bignum(k,b0);
     else random_bignum(k,b0);
     c1 = bignum_nonzero_6(b0);
     c2 = !reference_iszero(k,b0);
     if (c1 != c2)
      { printf("### Disparity: [size %4"PRIu64"] 0x%016"PRIx64"...0x%016"PRIx64" = 0\n",
               k,b0[5],b0[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] 0x%016"PRIx64"...0x%016"PRIx64" = 0 <=> %"PRIx64"\n",
                    k,b0[5],b0[0],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_normalize(void)
{ uint64_t t, k, r;
  printf("Testing bignum_normalize with %d cases\n",tests);
  int c = 0;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     reference_copy(k,b1,k,b0);
     r = bignum_normalize(k,b1);
     reference_pow2(k,b2,reference_clz(k,b0));
     reference_mul(k,b3,k,b0,k,b2);
     c = reference_compare(k,b1,k,b3);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"]",k);
        if (k == 0) printf("\n");
        else printf (" normalize(0x%016"PRIx64"...0x%016"PRIx64") = 0x%016"PRIx64"...0x%016"PRIx64""
                     " not 0x%016"PRIx64"...0x%016"PRIx64"\n",
                     b0[k-1],b0[0],b1[k-1],b1[0],b3[k-1],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"]",k);
        if (k == 0) printf("\n");
        else printf (" normalize(0x%016"PRIx64"...0x%016"PRIx64") = 0x%016"PRIx64"...0x%016"PRIx64" "
                     "(%"PRIu64" places)\n",
                     b0[k-1],b0[0],b1[k-1],b1[0],r);
      }
     if (r != reference_clz(k,b0))
      { printf("### Disparity: [size %4"PRIu64"]: %"PRIu64" not %"PRIu64" return value\n",
               k,r,reference_clz(k,b0));
        return 1;
      }

   }
  printf("All OK\n");
  return 0;
}

int test_bignum_odd(void)
{ uint64_t t, k;
  printf("Testing bignum_odd with %d cases\n",tests);
  uint64_t c1, c2;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     c1 = bignum_odd(k,b0);
     c2 = (k != 0) && (b0[0] & 1);
     if (c1 != c2)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_odd(...0x%016"PRIx64") = %"PRIx64" not %"PRIx64"\n",
               k,b0[0],c1,c2);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK:[size %4"PRIu64"] "
               "bignum_odd(...0x%016"PRIx64") = %"PRIx64"\n",
               k,b0[0],c1);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_of_word(void)
{ uint64_t t, i, k, n;
  printf("Testing bignum_of_word with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     n = random64();
     bignum_of_word(k,b0,n);
     c = 0;
     if ((k > 0) && (b0[0] != n)) c = 1;
     for (i = 1; i < k; ++i) if (b0[i] != 0) c = 1;
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_of_word(0x%016"PRIx64") = ....0x%016"PRIx64"\n",
               k,n,b0[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK:[size %4"PRIu64"] "
               "bignum_of_word(0x%016"PRIx64") = ....0x%016"PRIx64"\n",
               k,n,b0[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_optadd(void)
{ uint64_t t, i, k;
  printf("Testing bignum_optadd with %d cases\n",tests);
  uint64_t c, c1, c2;
  uint64_t p;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     random_bignum(k,b1);
     random_bignum(k,b2);
     random_bignum(k,b3);
     p = rand() & 1;

     for (i = 0; i < k; ++i) b3[i] = b0[i];
     c1 = 0; if (p) c1 = reference_adc(k,b3,k,b3,k,b1,0);

     c2 = bignum_optadd(k,b2,b0,p,b1);

     c = reference_compare(k,b2,k,b3);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" + %"PRIx64" * ...0x%016"PRIx64" = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p,b1[0],b2[0],b3[0]);
        return 1;
      }
     else if (c1 != c2)
      {
        printf("### Disparity: [size %4"PRIu64"]: ...0x%016"PRIx64" + %"PRIx64" * ...0x%016"PRIx64" carry %"PRIu64" not %"PRIu64"\n",
               k,b0[0],p,b1[0],c2,c1);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] ...0x%016"PRIx64" + %"PRIx64" * ...0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p,b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_optneg(void)
{ uint64_t t, k;
  printf("Testing bignum_optneg with %d cases\n",tests);
  uint64_t c, c1, c2;
  uint64_t p;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b1);
     random_bignum(k,b2);
     random_bignum(k,b3);
     p = random64();
     if (rand() & 1) p = 0;
     if ((rand() & 31) == 0) reference_of_word(k,b1,0);

     c1 = 0;
     if (p != 0) c1 = reference_sbb(k,b3,0,NULL,k,b1,0);
     else reference_copy(k,b3,k,b1);

     c2 = bignum_optneg(k,b2,p,b1);

     c = reference_compare(k,b2,k,b3);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "(%s) ...0x%016"PRIx64" = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,(p ? "-" : "+"),b1[0],b2[0],b3[0]);
        return 1;
      }
     else if (c1 != c2)
      {
        printf("### Disparity: [size %4"PRIu64"]: (%s) ...0x%016"PRIx64" carry %"PRIu64" not %"PRIu64"\n",
               k,(p ? "-" : "+"),b1[0],c2,c1);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] (%s) ...0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,(p ? "-" : "+"),b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_optneg_p25519(void)
{ uint64_t i, k, p;
  printf("Testing bignum_optneg_p25519 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_25519);
     p = (rand() & 1) ? 0 :
         (rand() & 1) ? 1 :
         (rand() & 1) ? 2 : random64();
     bignum_optneg_p25519(b2,p,b0);
     if ((p == 0) || reference_iszero(k,b0)) reference_copy(k,b3,k,b0);
     else reference_sub_samelen(k,b3,p_25519,b0);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "%s...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,(p ? "-" : "+"),b0[0],p_25519[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "%s...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,(p ? "-" : "+"),b0[0],p_25519[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_optneg_p256(void)
{ uint64_t i, k, p;
  printf("Testing bignum_optneg_p256 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_256);
     p = (rand() & 1) ? 0 :
         (rand() & 1) ? 1 :
         (rand() & 1) ? 2 : random64();
     bignum_optneg_p256(b2,p,b0);
     if ((p == 0) || reference_iszero(k,b0)) reference_copy(k,b3,k,b0);
     else reference_sub_samelen(k,b3,p_256,b0);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "%s...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,(p ? "-" : "+"),b0[0],p_256[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "%s...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,(p ? "-" : "+"),b0[0],p_256[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_optneg_p256k1(void)
{ uint64_t i, k, p;
  printf("Testing bignum_optneg_p256k1 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_256k1);
     p = (rand() & 1) ? 0 :
         (rand() & 1) ? 1 :
         (rand() & 1) ? 2 : random64();
     bignum_optneg_p256k1(b2,p,b0);
     if ((p == 0) || reference_iszero(k,b0)) reference_copy(k,b3,k,b0);
     else reference_sub_samelen(k,b3,p_256k1,b0);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "%s...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,(p ? "-" : "+"),b0[0],p_256k1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "%s...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,(p ? "-" : "+"),b0[0],p_256k1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_optneg_p384(void)
{ uint64_t i, k, p;
  printf("Testing bignum_optneg_p384 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 6;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_384);
     p = (rand() & 1) ? 0 :
         (rand() & 1) ? 1 :
         (rand() & 1) ? 2 : random64();
     bignum_optneg_p384(b2,p,b0);
     if (!p || reference_iszero(k,b0)) reference_copy(k,b3,k,b0);
     else reference_sub_samelen(k,b3,p_384,b0);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "%s...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,(p ? "-" : "+"),b0[0],p_384[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "%s...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,(p ? "-" : "+"),b0[0],p_384[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_optneg_p521(void)
{ uint64_t i, k, p;
  printf("Testing bignum_optneg_p521 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 9;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_521);
     p = (rand() & 1) ? 0 :
         (rand() & 1) ? 1 :
         (rand() & 1) ? 2 : random64();
     bignum_optneg_p521(b2,p,b0);
     if (!p || reference_iszero(k,b0)) reference_copy(k,b3,k,b0);
     else reference_sub_samelen(k,b3,p_521,b0);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "%s...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,(p ? "-" : "+"),b0[0],p_521[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "%s...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,(p ? "-" : "+"),b0[0],p_521[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_optneg_sm2(void)
{ uint64_t i, k, p;
  printf("Testing bignum_optneg_sm2 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_sm2);
     p = (rand() & 1) ? 0 :
         (rand() & 1) ? 1 :
         (rand() & 1) ? 2 : random64();
     bignum_optneg_sm2(b2,p,b0);
     if ((p == 0) || reference_iszero(k,b0)) reference_copy(k,b3,k,b0);
     else reference_sub_samelen(k,b3,p_sm2,b0);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "%s...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,(p ? "-" : "+"),b0[0],p_sm2[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
               "%s...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64"\n",
               k,(p ? "-" : "+"),b0[0],p_sm2[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_optsub(void)
{ uint64_t t, i, k;
  printf("Testing bignum_optsub with %d cases\n",tests);
  uint64_t c, c1, c2;
  uint64_t p;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     random_bignum(k,b1);
     random_bignum(k,b2);
     random_bignum(k,b3);
     p = rand() & 1;

     for (i = 0; i < k; ++i) b3[i] = b0[i];
     c1 = 0; if (p) c1 = reference_sbb(k,b3,k,b3,k,b1,0);

     c2 = bignum_optsub(k,b2,b0,p,b1);

     c = reference_compare(k,b2,k,b3);

    if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" - %"PRIx64" * ...0x%016"PRIx64" = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p,b1[0],b2[0],b3[0]);
        return 1;
      }
     else if (c1 != c2)
      {
        printf("### Disparity: [size %4"PRIu64"]: ...0x%016"PRIx64" - %"PRIx64" * ...0x%016"PRIx64" carry %"PRIu64" not %"PRIu64"\n",
               k,b0[0],p,b1[0],c2,c1);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] ...0x%016"PRIx64" - %"PRIx64" * ...0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p,b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_optsubadd(void)
{ uint64_t t, i, k;
  printf("Testing bignum_optsubadd with %d cases\n",tests);
  uint64_t c, c1, c2;
  uint64_t p;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     random_bignum(k,b0);
     random_bignum(k,b1);
     random_bignum(k,b2);
     random_bignum(k,b3);
     p = random64();

     for (i = 0; i < k; ++i) b3[i] = b0[i];
     c1 = 0;
     if (p & (UINT64_C(1)<<63)) c1 = reference_sbb(k,b3,k,b3,k,b1,0);
     else if (p != 0) c1 = reference_adc(k,b3,k,b3,k,b1,0);

     c2 = bignum_optsubadd(k,b2,b0,p,b1);

     c = reference_compare(k,b2,k,b3);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" + sgn(%"PRIx64") * ...0x%016"PRIx64" = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p,b1[0],b2[0],b3[0]);
        return 1;
      }
     else if (c1 != c2)
      {
        printf("### Disparity: [size %4"PRIu64"]: ...0x%016"PRIx64" + sgn(%"PRIx64") * ...0x%016"PRIx64" carry %"PRIu64" not %"PRIu64"\n",
               k,b0[0],p,b1[0],c2,c1);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] ...0x%016"PRIx64" + sgn(%"PRIx64") * ...0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p,b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_pow2(void)
{ uint64_t t, i, k, n;
  printf("Testing bignum_pow2 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k = (unsigned) rand() % MAXSIZE;
     n = random64() % (1000 * k + 1);
     if (rand() & 1) n %= (65 * k + 1);
     for (i = 0; i < k; ++i) b0[i] = 42;
     bignum_pow2(k,b0,n);
     for (i = 0; i < k; ++i) b1[i] = 0;
     if (n < 64*k) b1[n>>6] = UINT64_C(1)<<(n&UINT64_C(63));
     c = reference_compare(k,b0,k,b1);

     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_pow2(0x%016"PRIx64") = ....0x%016"PRIx64" not ....0x%016"PRIx64"\n",
               k,n,b0[0],b1[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size    0] bignum_pow2(0x%016"PRIx64")\n",n);
        else printf("OK: [size %4"PRIu64"] "
               "bignum_pow2(0x%016"PRIx64") = ....0x%016"PRIx64"\n",
               k,n,b0[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_shl_small(void)
{ uint64_t t, j, k1, k2, a, r;
  printf("Testing bignum_shl_small with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k1 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     a = random64();
     if (rand() & 31) a &= UINT64_C(63);
     random_bignum(k1,b1);
     random_bignum(k2,b2);
     for (j = 0; j < k2; ++j) b3[j] = b2[j] + 1;
     r = bignum_shl_small(k2,b2,k1,b1,a); b2[k2] = r;
     reference_cmul(k2+1,b3,(UINT64_C(1)<<(a&UINT64_C(63))),(k2 < k1 ? k2 : k1),b1);
     c = reference_compare(k2+1,b2,k2+1,b3);
     if (c != 0)
      { printf("### Disparity: [sizes %4"PRIu64" := %4"PRIu64"] "
               "...0x%016"PRIx64" << %2"PRIu64", = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k2,k1,b1[0],a,b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k2 == 0) printf("OK: [sizes %4"PRIu64" := %4"PRIu64"]\n",k2,k1);
        else printf("OK: [sizes %4"PRIu64" := %4"PRIu64"] ...0x%016"PRIx64" << %2"PRIu64" = ...0x%016"PRIx64"\n",
                    k2,k1,b1[0],a,b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_shr_small(void)
{ uint64_t t, j, k1, k2, a, r;
  printf("Testing bignum_shr_small with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k1 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     a = random64();
     if (rand() & 31) a &= UINT64_C(63);
     random_bignum(k1,b1);
     random_bignum(k2,b2);
     for (j = 0; j < k2+1; ++j) b3[j] = b2[j] + 1;

     r = bignum_shr_small(k2,b2+1,k1,b1,a);
     b2[0] = ((a&UINT64_C(63)) == 0) ? 0 : (r<<(64 - (a&UINT64_C(63))));

     reference_copy(k2+1,b3+1,k1,b1); b3[0] = 0;
     c = 0; for (j = 0; j < (a & UINT64_C(63)); ++j) c = reference_shr_samelen(k2+2,b3,b3,c);

     c = reference_compare(k2+1,b2,k2+1,b3);
     if (c != 0)
      { printf("### Disparity: [sizes %4"PRIu64" := %4"PRIu64"] "
               "...0x%016"PRIx64" >> %2"PRIu64", = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k2,k1,b1[0],a,b2[1],b3[1]);
        return 1;
      }
     else if (VERBOSE)
      { if (k2 == 0) printf("OK: [sizes %4"PRIu64" := %4"PRIu64"]\n",k2,k1);
        else printf("OK: [sizes %4"PRIu64" := %4"PRIu64"] ...0x%016"PRIx64" >> %2"PRIu64" = ...0x%016"PRIx64"\n",
                    k2,k1,b1[0],a,b2[1]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_sqr(void)
{ uint64_t t, j, k0, k2;
  printf("Testing bignum_sqr with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { k0 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     random_bignum(k0,b0);
     random_bignum(k2,b2);
     for (j = 0; j < k2; ++j) b3[j] = b2[j];
     bignum_sqr(k2,b2,k0,b0);
     reference_mul(k2,b3,k0,b0,k0,b0);
     c = reference_compare(k2,b2,k2,b3);
     if (c != 0)
      { printf("### Disparity: [sizes %4"PRIu64" := %4"PRIu64"^2] "
               "...0x%016"PRIx64" ^ 2 = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k2,k0,b0[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k0 == 0 || k2 == 0) printf("OK: [sizes %4"PRIu64" := %4"PRIu64"^2]\n",k2,k0);
        else printf("OK: [sizes %4"PRIu64" := %4"PRIu64"^2] ...0x%016"PRIx64" ^ 2 = ...0x%016"PRIx64"\n",
                    k2,k0,b0[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}


int test_bignum_sqr_specific
  (uint64_t p,uint64_t n, char *name,
   void (*f)(uint64_t *, const uint64_t *))
{ uint64_t i, j;
  printf("Testing %s with %d cases\n",name,tests);
  int c;
  for (i = 0; i < tests; ++i)
   { random_bignum(n,b0);
     random_bignum(p,b2);
     for (j = 0; j < p; ++j) b3[j] = b2[j] + 1;
     (*f)(b2,b0);
     reference_mul(p,b3,n,b0,n,b0);
     c = reference_compare(p,b2,p,b3);
     if (c != 0)
      { printf("### Disparity: [sizes %4"PRIu64" x %4"PRIu64" -> %4"PRIu64"] "
               "...0x%016"PRIx64"^2  = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               n,n,p,b0[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (p == 0) printf("OK: [size %4"PRIu64" x %4"PRIu64" -> %4"PRIu64"]\n",n,n,p);
        else printf("OK: [size %4"PRIu64" x %4"PRIu64" -> %4"PRIu64"] "
                    "...0x%016"PRIx64"^2 =..0x%016"PRIx64"\n",
                    n,n,p,b0[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_sqr_4_8(void)
{ return test_bignum_sqr_specific(8,4,"bignum_sqr_4_8",bignum_sqr_4_8);
}

int test_bignum_sqr_4_8_alt(void)
{ return test_bignum_sqr_specific(8,4,"bignum_sqr_4_8_alt",bignum_sqr_4_8_alt);
}

int test_bignum_sqr_6_12(void)
{ return test_bignum_sqr_specific(12,6,"bignum_sqr_6_12",bignum_sqr_6_12);
}

int test_bignum_sqr_6_12_alt(void)
{ return test_bignum_sqr_specific(12,6,"bignum_sqr_6_12_alt",bignum_sqr_6_12_alt);
}

int test_bignum_sqr_8_16(void)
{ return test_bignum_sqr_specific(16,8,"bignum_sqr_8_16",bignum_sqr_8_16);
}

int test_bignum_sqr_8_16_alt(void)
{ return test_bignum_sqr_specific(16,8,"bignum_sqr_8_16_alt",bignum_sqr_8_16_alt);
}

int test_bignum_sqr_p25519(void)
{ uint64_t i, k;
  printf("Testing bignum_sqr_p25519 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b0);
     bignum_sqr_p25519(b2,b0);
     reference_mul(2*k,b4,k,b0,k,b0);
     reference_copy(2*k,b3,k,p_25519);
     reference_mod(2*k,b5,b4,b3);
     reference_copy(k,b3,2*k,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_25519[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_25519[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_sqr_p25519_alt(void)
{ uint64_t i, k;
  printf("Testing bignum_sqr_p25519_alt with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b0);
     bignum_sqr_p25519_alt(b2,b0);
     reference_mul(2*k,b4,k,b0,k,b0);
     reference_copy(2*k,b3,k,p_25519);
     reference_mod(2*k,b5,b4,b3);
     reference_copy(k,b3,2*k,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_25519[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_25519[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_sqr_p256k1(void)
{ uint64_t i, k;
  printf("Testing bignum_sqr_p256k1 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b0);
     bignum_sqr_p256k1(b2,b0);
     reference_mul(2*k,b4,k,b0,k,b0);
     reference_copy(2*k,b3,k,p_256k1);
     reference_mod(2*k,b5,b4,b3);
     reference_copy(k,b3,2*k,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_256k1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_256k1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_sqr_p256k1_alt(void)
{ uint64_t i, k;
  printf("Testing bignum_sqr_p256k1_alt with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b0);
     bignum_sqr_p256k1_alt(b2,b0);
     reference_mul(2*k,b4,k,b0,k,b0);
     reference_copy(2*k,b3,k,p_256k1);
     reference_mod(2*k,b5,b4,b3);
     reference_copy(k,b3,2*k,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_256k1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_256k1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_sqr_p521_specific(const char *name, void (*f)(uint64_t*, const uint64_t*))
{ uint64_t i, k;
  printf("Testing %s with %d cases\n",name,tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 9;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_521);
     f(b2,b0);
     reference_mul(2*k,b4,k,b0,k,b0);
     reference_copy(2*k,b3,k,p_521);
     reference_mod(2*k,b5,b4,b3);
     reference_copy(k,b3,2*k,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_521[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_521[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_sqr_p521(void)
{ return test_bignum_sqr_p521_specific("bignum_sqr_p521", bignum_sqr_p521) ;
}

int test_bignum_sqr_p521_alt(void)
{ return test_bignum_sqr_p521_specific("bignum_sqr_p521_alt", bignum_sqr_p521_alt);
}

int test_bignum_sqrt_p25519(void)
{ uint64_t i, k;
  printf("Testing bignum_sqrt_p25519 with %d cases\n",tests);
  uint64_t c;
  uint64_t  l, r;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_25519);
     l = reference_legendre(k,b0,p_25519);
     r = bignum_sqrt_p25519(b2,b0);
     reference_mul(2*k,b4,k,b2,k,b2);
     reference_copy(2*k,b3,k,p_25519);
     reference_mod(2*k,b5,b4,b3);
     reference_copy(k,b3,2*k,b5);

     c = reference_compare(k,b3,k,b0);
     if (l != r)
      { printf("### Disparity: [size %4"PRIu64"] "
               "legendre(...0x%016"PRIx64" / ....0x%016"PRIx64") = "
               "%"PRIi64" not %"PRIi64"\n",
               k,b0[0],p_25519[0],r,l);
        return 1;
      }
     else if ((l != -1) && (c != 0))
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b2[0],p_25519[0],b3[0],b0[0]);
        return 1;
      }
     else if (b2[0] & 1)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" is odd (wrong choice of square root)\n",
               k,b2[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64" (%s)\n",
                    k,b2[0],p_25519[0],b0[0],
                    ((l == -1) ? "nonresidue" :
                     (l == 1) ? "residue" :
                     (l == 0) ? "trivial" : "invalid"));
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_sqrt_p25519_alt(void)
{ uint64_t i, k;
  printf("Testing bignum_sqrt_p25519_alt with %d cases\n",tests);
  uint64_t c;
  uint64_t  l, r;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_25519);
     l = reference_legendre(k,b0,p_25519);
     r = bignum_sqrt_p25519_alt(b2,b0);
     reference_mul(2*k,b4,k,b2,k,b2);
     reference_copy(2*k,b3,k,p_25519);
     reference_mod(2*k,b5,b4,b3);
     reference_copy(k,b3,2*k,b5);

     c = reference_compare(k,b3,k,b0);
     if (l != r)
      { printf("### Disparity: [size %4"PRIu64"] "
               "legendre(...0x%016"PRIx64" / ....0x%016"PRIx64") = "
               "%"PRIi64" not %"PRIi64"\n",
               k,b0[0],p_25519[0],r,l);
        return 1;
      }
     else if ((l != -1) && (c != 0))
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b2[0],p_25519[0],b3[0],b0[0]);
        return 1;
      }
     else if (b2[0] & 1)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" is odd (wrong choice of square root)\n",
               k,b2[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" ^ 2 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64" (%s)\n",
                    k,b2[0],p_25519[0],b0[0],
                    ((l == -1) ? "nonresidue" :
                     (l == 1) ? "residue" :
                     (l == 0) ? "trivial" : "invalid"));
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_sub(void)
{ uint64_t t, j, k0, k1, k2;
  printf("Testing bignum_sub with %d cases\n",tests);
  uint64_t c, c1, c2;
  for (t = 0; t < tests; ++t)
   { k0 = (unsigned) rand() % MAXSIZE;
     k1 = (unsigned) rand() % MAXSIZE;
     k2 = (unsigned) rand() % MAXSIZE;
     random_bignum(k0,b0);
     random_bignum(k1,b1);
     random_bignum(k2,b2);
     for (j = 0; j < k2; ++j) b3[j] = b2[j];
     c1 = bignum_sub(k2,b2,k0,b0,k1,b1);
     c2 = reference_sbb(k2,b3,k0,b0,k1,b1,0);
     c = reference_compare(k2,b2,k2,b3);
     if ((c != 0) || (c1 != c2))
      { printf("### Disparity: [sizes %4"PRIu64" := %4"PRIu64" - %4"PRIu64"] "
               "...0x%016"PRIx64" - ...0x%016"PRIx64" = ....0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k2,k0,k1,b0[0],b1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k0 == 0 || k1 == 0 || k2 == 0) printf("OK: [sizes %4"PRIu64" := %4"PRIu64" - %4"PRIu64"]\n",k2,k0,k1);
        else printf("OK: [sizes %4"PRIu64" := %4"PRIu64" - %4"PRIu64"] ...0x%016"PRIx64" - ...0x%016"PRIx64" = ...0x%016"PRIx64"\n",
                    k2,k0,k1,b0[0],b1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_sub_p25519(void)
{ uint64_t i, k;
  printf("Testing bignum_sub_p25519 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_25519);
     random_bignum(k,b2); reference_mod(k,b1,b2,p_25519);
     bignum_sub_p25519(b2,b0,b1);
     reference_copy(k+1,b3,k,p_25519);
     reference_copy(k+1,b4,k,b0);
     reference_copy(k+1,b5,k,b1);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_sub_samelen(k+1,b4,b4,b5);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" - ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],p_25519[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" - ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],p_25519[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_sub_p256(void)
{ uint64_t i, k;
  printf("Testing bignum_sub_p256 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_256);
     random_bignum(k,b2); reference_mod(k,b1,b2,p_256);
     bignum_sub_p256(b2,b0,b1);
     reference_copy(k+1,b3,k,p_256);
     reference_copy(k+1,b4,k,b0);
     reference_copy(k+1,b5,k,b1);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_sub_samelen(k+1,b4,b4,b5);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" - ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],p_256[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" - ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],p_256[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_sub_p256k1(void)
{ uint64_t i, k;
  printf("Testing bignum_sub_p256k1 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_256k1);
     random_bignum(k,b2); reference_mod(k,b1,b2,p_256k1);
     bignum_sub_p256k1(b2,b0,b1);
     reference_copy(k+1,b3,k,p_256k1);
     reference_copy(k+1,b4,k,b0);
     reference_copy(k+1,b5,k,b1);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_sub_samelen(k+1,b4,b4,b5);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" - ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],p_256k1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" - ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],p_256k1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_sub_p384(void)
{ uint64_t i, k;
  printf("Testing bignum_sub_p384 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 6;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_384);
     random_bignum(k,b2); reference_mod(k,b1,b2,p_384);
     bignum_sub_p384(b2,b0,b1);
     reference_copy(k+1,b3,k,p_384);
     reference_copy(k+1,b4,k,b0);
     reference_copy(k+1,b5,k,b1);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_sub_samelen(k+1,b4,b4,b5);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" - ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],p_384[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" - ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],p_384[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_sub_p521(void)
{ uint64_t i, k;
  printf("Testing bignum_sub_p521 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 9;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_521);
     random_bignum(k,b2); reference_mod(k,b1,b2,p_521);
     bignum_sub_p521(b2,b0,b1);
     reference_copy(k+1,b3,k,p_521);
     reference_copy(k+1,b4,k,b0);
     reference_copy(k+1,b5,k,b1);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_sub_samelen(k+1,b4,b4,b5);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" - ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],p_521[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" - ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],p_521[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_sub_sm2(void)
{ uint64_t i, k;
  printf("Testing bignum_sub_sm2 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_sm2);
     random_bignum(k,b2); reference_mod(k,b1,b2,p_sm2);
     bignum_sub_sm2(b2,b0,b1);
     reference_copy(k+1,b3,k,p_sm2);
     reference_copy(k+1,b4,k,b0);
     reference_copy(k+1,b5,k,b1);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_sub_samelen(k+1,b4,b4,b5);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" - ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],b1[0],p_sm2[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" - ...0x%016"PRIx64" mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],b1[0],p_sm2[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_tobebytes_4(void)
{ uint64_t t;
  printf("Testing bignum_tobebytes_4 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     reference_bigendian(4,b3,b0);
     bignum_tobebytes_4((uint8_t *)b4,b0);
     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_tobebytes_4(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] bignum_tobebytes_4(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_tobebytes_6(void)
{ uint64_t t;
  printf("Testing bignum_tobebytes_6 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(6,b0);
     reference_bigendian(6,b3,b0);
     bignum_tobebytes_6((uint8_t *)b4,b0);
     c = reference_compare(6,b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_tobebytes_6(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[5],b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] bignum_tobebytes_6(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[5],b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_tolebytes_4(void)
{ uint64_t t;
  printf("Testing bignum_tolebytes_4 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     reference_littleendian(4,b3,b0);
     bignum_tolebytes_4((uint8_t *)b4,b0);
     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_tolebytes_4(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] bignum_tolebytes_4(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[3],b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_tolebytes_6(void)
{ uint64_t t;
  printf("Testing bignum_tolebytes_6 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(6,b0);
     reference_littleendian(6,b3,b0);
     bignum_tolebytes_6((uint8_t *)b4,b0);
     c = reference_compare(6,b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_tolebytes_6(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[5],b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] bignum_tolebytes_6(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[5],b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_tolebytes_p521(void)
{ uint64_t t;
  printf("Testing bignum_tolebytes_p521 with %d cases\n",tests);
  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(9,b0);
     reference_tolebytes(66,(uint8_t *)b3,9,b0);
     bignum_tolebytes_p521((uint8_t *)b4,b0);
     c = reference_compare(9,b3,9,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "bignum_tolebytes_p521(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[8],b0[0],b4[8],b4[0],b3[8],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] bignum_tolebytes_p521(0x%016"PRIx64"...%016"PRIx64") = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[8],b0[0],b4[8],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_tomont_p256(void)
{ uint64_t t;
  printf("Testing bignum_tomont_p256 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     reference_modpowtwo(4,b1,256,p_256);
     reference_mul(8,b2,4,b1,4,b0);
     reference_copy(8,b1,4,p_256);
     reference_mod(8,b3,b2,b1);
     bignum_tomont_p256(b4,b0);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^256 * ...0x%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^256 * ...0x%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_tomont_p256_alt(void)
{ uint64_t t;
  printf("Testing bignum_tomont_p256_alt with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     reference_modpowtwo(4,b1,256,p_256);
     reference_mul(8,b2,4,b1,4,b0);
     reference_copy(8,b1,4,p_256);
     reference_mod(8,b3,b2,b1);
     bignum_tomont_p256_alt(b4,b0);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^256 * ...0x%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^256 * ...0x%016"PRIx64" mod p_256 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_tomont_p256k1(void)
{ uint64_t t;
  printf("Testing bignum_tomont_p256k1 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     reference_modpowtwo(4,b1,256,p_256k1);
     reference_mul(8,b2,4,b1,4,b0);
     reference_copy(8,b1,4,p_256k1);
     reference_mod(8,b3,b2,b1);
     bignum_tomont_p256k1(b4,b0);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^256 * ...0x%016"PRIx64" mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^256 * ...0x%016"PRIx64" mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_tomont_p256k1_alt(void)
{ uint64_t t;
  printf("Testing bignum_tomont_p256k1_alt with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     reference_modpowtwo(4,b1,256,p_256k1);
     reference_mul(8,b2,4,b1,4,b0);
     reference_copy(8,b1,4,p_256k1);
     reference_mod(8,b3,b2,b1);
     bignum_tomont_p256k1_alt(b4,b0);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^256 * ...0x%016"PRIx64" mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^256 * ...0x%016"PRIx64" mod p_256k1 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_tomont_p384(void)
{ uint64_t t;
  printf("Testing bignum_tomont_p384 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(6,b0);
     reference_modpowtwo(6,b1,384,p_384);
     reference_mul(12,b2,6,b1,6,b0);
     reference_copy(12,b1,6,p_384);
     reference_mod(12,b3,b2,b1);
     bignum_tomont_p384(b4,b0);

     c = reference_compare(6,b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^384 * ...0x%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^384 * ...0x%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_tomont_p384_alt(void)
{ uint64_t t;
  printf("Testing bignum_tomont_p384_alt with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(6,b0);
     reference_modpowtwo(6,b1,384,p_384);
     reference_mul(12,b2,6,b1,6,b0);
     reference_copy(12,b1,6,p_384);
     reference_mod(12,b3,b2,b1);
     bignum_tomont_p384_alt(b4,b0);

     c = reference_compare(6,b3,6,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^384 * ...0x%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b4[5],b4[0],b3[5],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^384 * ...0x%016"PRIx64" mod p_384 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(6),b0[0],b4[5],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_tomont_p521(void)
{ uint64_t t;
  printf("Testing bignum_tomont_p521 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(9,b0);
     reference_modpowtwo(9,b1,576,p_521);
     reference_mul(18,b2,9,b1,9,b0);
     reference_copy(18,b1,9,p_521);
     reference_mod(18,b3,b2,b1);
     bignum_tomont_p521(b4,b0);

     c = reference_compare(9,b3,9,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^576 * ...0x%016"PRIx64" mod p_521 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[0],b4[8],b4[0],b3[8],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^576 * ...0x%016"PRIx64" mod p_521 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(9),b0[0],b4[8],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_tomont_sm2(void)
{ uint64_t t;
  printf("Testing bignum_tomont_sm2 with %d cases\n",tests);

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);
     reference_modpowtwo(4,b1,256,p_sm2);
     reference_mul(8,b2,4,b1,4,b0);
     reference_copy(8,b1,4,p_sm2);
     reference_mod(8,b3,b2,b1);
     bignum_tomont_sm2(b4,b0);

     c = reference_compare(4,b3,4,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2^256 * ...0x%016"PRIx64" mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64" not 0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0],b3[3],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2^256 * ...0x%016"PRIx64" mod p_sm2 = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               UINT64_C(4),b0[0],b4[3],b4[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_triple_p256(void)
{ uint64_t i, k;
  printf("Testing bignum_triple_p256 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b0);
     bignum_triple_p256(b2,b0);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b0);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_256);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_256[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_256[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_triple_p256_alt(void)
{ uint64_t i, k;
  printf("Testing bignum_triple_p256_alt with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b0);
     bignum_triple_p256_alt(b2,b0);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b0);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_256);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_256[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_256[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_triple_p256k1(void)
{ uint64_t i, k;
  printf("Testing bignum_triple_p256k1 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b0);
     bignum_triple_p256k1(b2,b0);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b0);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_256k1);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_256k1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_256k1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_triple_p256k1_alt(void)
{ uint64_t i, k;
  printf("Testing bignum_triple_p256k1_alt with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b0);
     bignum_triple_p256k1_alt(b2,b0);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b0);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_256k1);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_256k1[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_256k1[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_triple_p384(void)
{ uint64_t i, k;
  printf("Testing bignum_triple_p384 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 6;
     random_bignum(k,b0);
     bignum_triple_p384(b2,b0);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b0);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_384);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_384[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_384[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_triple_p384_alt(void)
{ uint64_t i, k;
  printf("Testing bignum_triple_p384_alt with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 6;
     random_bignum(k,b0);
     bignum_triple_p384_alt(b2,b0);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b0);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_384);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_384[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_384[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_triple_p521(void)
{ uint64_t i, k;
  printf("Testing bignum_triple_p521 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 9;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_521);
     bignum_triple_p521(b2,b0);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b0);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_521);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_521[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_521[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_triple_p521_alt(void)
{ uint64_t i, k;
  printf("Testing bignum_triple_p521_alt with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 9;
     random_bignum(k,b2); reference_mod(k,b0,b2,p_521);
     bignum_triple_p521_alt(b2,b0);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b0);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_521);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_521[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_521[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_triple_sm2(void)
{ uint64_t i, k;
  printf("Testing bignum_triple_sm2 with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b0);
     bignum_triple_sm2(b2,b0);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b0);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_sm2);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_sm2[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_sm2[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_bignum_triple_sm2_alt(void)
{ uint64_t i, k;
  printf("Testing bignum_triple_sm2_alt with %d cases\n",tests);
  uint64_t c;
  for (i = 0; i < tests; ++i)
   { k = 4;
     random_bignum(k,b0);
     bignum_triple_sm2_alt(b2,b0);
     reference_copy(k+1,b3,k,b0);
     reference_copy(k+1,b4,k,b0);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_add_samelen(k+1,b4,b4,b3);
     reference_copy(k+1,b3,k,p_sm2);
     reference_mod(k+1,b5,b4,b3);
     reference_copy(k,b3,k+1,b5);

     c = reference_compare(k,b3,k,b2);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
               "...0x%016"PRIx64" not ...0x%016"PRIx64"\n",
               k,b0[0],p_sm2[0],b2[0],b3[0]);
        return 1;
      }
     else if (VERBOSE)
      { if (k == 0) printf("OK: [size %4"PRIu64"]\n",k);
        else printf("OK: [size %4"PRIu64"] "
                    "...0x%016"PRIx64" * 3 mod ....0x%016"PRIx64" = "
                    "...0x%016"PRIx64"\n",
                    k,b0[0],p_sm2[0],b2[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_curve25519_ladderstep(void)
{ uint64_t t, k, b;
  printf("Testing curve25519_ladderstep with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b0); reference_mod(k,b1,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2+k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2+2*k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2+3*k,b0,p_25519);
     b = (rand() & 1) ? rand() : 0;
     curve25519_ladderstep(b3,b1,b2,b);
     reference_curve25519ladderstep(b4,b1,b2,b);

     c = reference_compare(4*k,b3,4*k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "step_%d [...0x%016"PRIx64"] (<...0x%016"PRIx64">,<...0x%016"PRIx64">) = "
               "(<...0x%016"PRIx64">,<...0x%016"PRIx64">) not "
               "(<...0x%016"PRIx64">,<...0x%016"PRIx64">)\n",
               k,(b != 0),b1[0],b2[0],b2[4],b3[0],b3[4],b4[0],b4[4]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "step_%d [...0x%016"PRIx64"] (<...0x%016"PRIx64">,<...0x%016"PRIx64">) = "
               "(<...0x%016"PRIx64">,<...0x%016"PRIx64">)\n",
               k,(b != 0),b1[0],b2[0],b2[4],b3[0],b3[4]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_curve25519_ladderstep_alt(void)
{ uint64_t t, k, b;
  printf("Testing curve25519_ladderstep_alt with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b0); reference_mod(k,b1,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2+k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2+2*k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2+3*k,b0,p_25519);
     b = (rand() & 1) ? rand() : 0;
     curve25519_ladderstep_alt(b3,b1,b2,b);
     reference_curve25519ladderstep(b4,b1,b2,b);

     c = reference_compare(4*k,b3,4*k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "step_%d [...0x%016"PRIx64"] (<...0x%016"PRIx64">,<...0x%016"PRIx64">) = "
               "(<...0x%016"PRIx64">,<...0x%016"PRIx64">) not "
               "(<...0x%016"PRIx64">,<...0x%016"PRIx64">)\n",
               k,(b != 0),b1[0],b2[0],b2[4],b3[0],b3[4],b4[0],b4[4]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "step_%d [...0x%016"PRIx64"] (<...0x%016"PRIx64">,<...0x%016"PRIx64">) = "
               "(<...0x%016"PRIx64">,<...0x%016"PRIx64">)\n",
               k,(b != 0),b1[0],b2[0],b2[4],b3[0],b3[4]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_curve25519_pxscalarmul(void)
{ uint64_t t, k;
  printf("Testing curve25519_pxscalarmul with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b1);
     random_bignum(k,b0); reference_mod(k,b2,b0,p_25519);
     curve25519_pxscalarmul(b3,b1,b2);
     reference_curve25519pxscalarmul(b4,b1,b2);

     c = reference_compare(2*k,b3,2*k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "<...0x%016"PRIx64",-> * ...0x%016"PRIx64" = "
               "<...0x%016"PRIx64",...0x%016"PRIx64"> not "
               "<...0x%016"PRIx64",...0x%016"PRIx64">\n",
               k,b1[0],b2[0],b3[0],b3[4],b4[0],b4[4]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "<...0x%016"PRIx64",-> * ...0x%016"PRIx64" = "
               "<...0x%016"PRIx64",...0x%016"PRIx64">\n",
               k,b1[0],b2[0],b3[0],b3[4]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_curve25519_pxscalarmul_alt(void)
{ uint64_t t, k;
  printf("Testing curve25519_pxscalarmul_alt with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b1);
     random_bignum(k,b0); reference_mod(k,b2,b0,p_25519);
     curve25519_pxscalarmul_alt(b3,b1,b2);
     reference_curve25519pxscalarmul(b4,b1,b2);

     c = reference_compare(2*k,b3,2*k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "<...0x%016"PRIx64",-> * ...0x%016"PRIx64" = "
               "<...0x%016"PRIx64",...0x%016"PRIx64"> not "
               "<...0x%016"PRIx64",...0x%016"PRIx64">\n",
               k,b1[0],b2[0],b3[0],b3[4],b4[0],b4[4]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "<...0x%016"PRIx64",-> * ...0x%016"PRIx64" = "
               "<...0x%016"PRIx64",...0x%016"PRIx64">\n",
               k,b1[0],b2[0],b3[0],b3[4]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_curve25519_x25519(void)
{ uint64_t t, k;
  printf("Testing curve25519_x25519 with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b2);
     random_bignum(k,b1);

     // With non-trivial probability, let X be in the cofactor 8-group

     if ((rand() & 15) == 0)
      { b2[3] = UINT64_C(0x57119fd0dd4e22d8);
        b2[2] = UINT64_C(0x868e1c58c45c4404);
        b2[1] = UINT64_C(0x5bef839c55b1d0b1);
        b2[0] = UINT64_C(0x248c50a3bc959c5f);
      }

     curve25519_x25519(b3,b1,b2);
     reference_curve25519x25519(b4,b1,b2);

     c = reference_compare(k,b3,k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64"> not "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],b2[3],b2[0],b3[3],b3[0],b4[3],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],b2[3],b2[0],b3[3],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_curve25519_x25519_alt(void)
{ uint64_t t, k;
  printf("Testing curve25519_x25519_alt with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b2);
     random_bignum(k,b1);

     // With non-trivial probability, let X be in the cofactor 8-group

     if ((rand() & 15) == 0)
      { b2[3] = UINT64_C(0x57119fd0dd4e22d8);
        b2[2] = UINT64_C(0x868e1c58c45c4404);
        b2[1] = UINT64_C(0x5bef839c55b1d0b1);
        b2[0] = UINT64_C(0x248c50a3bc959c5f);
      }

     curve25519_x25519_alt(b3,b1,b2);
     reference_curve25519x25519(b4,b1,b2);

     c = reference_compare(k,b3,k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64"> not "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],b2[3],b2[0],b3[3],b3[0],b4[3],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],b2[3],b2[0],b3[3],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_curve25519_x25519_byte(void)
{ uint64_t t, k;
  printf("Testing curve25519_x25519_byte with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b2);
     random_bignum(k,b1);

     // With non-trivial probability, let X be in the cofactor 8-group

     if ((rand() & 15) == 0)
      { b2[3] = UINT64_C(0x57119fd0dd4e22d8);
        b2[2] = UINT64_C(0x868e1c58c45c4404);
        b2[1] = UINT64_C(0x5bef839c55b1d0b1);
        b2[0] = UINT64_C(0x248c50a3bc959c5f);
      }

     reference_tolebytes(32,bb1,4,b1);
     reference_tolebytes(32,bb2,4,b2);
     curve25519_x25519_byte(bb3,bb1,bb2);
     reference_fromlebytes(4,b3,32,bb3);
     reference_curve25519x25519(b4,b1,b2);

     c = reference_compare(k,b3,k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64"> not "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],b2[3],b2[0],b3[3],b3[0],b4[3],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],b2[3],b2[0],b3[3],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_curve25519_x25519_byte_alt(void)
{ uint64_t t, k;
  printf("Testing curve25519_x25519_byte_alt with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b2);
     random_bignum(k,b1);

     // With non-trivial probability, let X be in the cofactor 8-group

     if ((rand() & 15) == 0)
      { b2[3] = UINT64_C(0x57119fd0dd4e22d8);
        b2[2] = UINT64_C(0x868e1c58c45c4404);
        b2[1] = UINT64_C(0x5bef839c55b1d0b1);
        b2[0] = UINT64_C(0x248c50a3bc959c5f);
      }

     reference_tolebytes(32,bb1,4,b1);
     reference_tolebytes(32,bb2,4,b2);
     curve25519_x25519_byte_alt(bb3,bb1,bb2);
     reference_fromlebytes(4,b3,32,bb3);
     reference_curve25519x25519(b4,b1,b2);

     c = reference_compare(k,b3,k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64"> not "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],b2[3],b2[0],b3[3],b3[0],b4[3],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],b2[3],b2[0],b3[3],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_curve25519_x25519base(void)
{ uint64_t t, k;
  printf("Testing curve25519_x25519base with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b1);
     reference_of_word(k,b2,UINT64_C(9));

     curve25519_x25519base(b3,b1);
     reference_curve25519x25519(b4,b1,b2);

     c = reference_compare(k,b3,k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64"> not "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],b2[3],b2[0],b3[3],b3[0],b4[3],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],b2[3],b2[0],b3[3],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_curve25519_x25519base_alt(void)
{ uint64_t t, k;
  printf("Testing curve25519_x25519base_alt with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b1);
     reference_of_word(k,b2,UINT64_C(9));

     curve25519_x25519base_alt(b3,b1);
     reference_curve25519x25519(b4,b1,b2);

     c = reference_compare(k,b3,k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64"> not "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],b2[3],b2[0],b3[3],b3[0],b4[3],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],b2[3],b2[0],b3[3],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_curve25519_x25519base_byte(void)
{ uint64_t t, k;
  printf("Testing curve25519_x25519base_byte with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b1);
     reference_of_word(k,b2,UINT64_C(9));

     reference_tolebytes(32,bb1,4,b1);
     curve25519_x25519base_byte(bb3,bb1);
     reference_fromlebytes(4,b3,32,bb3);
     reference_curve25519x25519(b4,b1,b2);

     c = reference_compare(k,b3,k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64"> not "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],b2[3],b2[0],b3[3],b3[0],b4[3],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],b2[3],b2[0],b3[3],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_curve25519_x25519base_byte_alt(void)
{ uint64_t t, k;
  printf("Testing curve25519_x25519base_byte_alt with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b1);
     reference_of_word(k,b2,UINT64_C(9));

     reference_tolebytes(32,bb1,4,b1);
     curve25519_x25519base_byte_alt(bb3,bb1);
     reference_fromlebytes(4,b3,32,bb3);
     reference_curve25519x25519(b4,b1,b2);

     c = reference_compare(k,b3,k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64"> not "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],b2[3],b2[0],b3[3],b3[0],b4[3],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],b2[3],b2[0],b3[3],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_edwards25519_decode(void)
{ uint64_t t, k;
  printf("Testing edwards25519_decode with %d cases\n",tests);
  k = 4;

  uint64_t b, b_ref;
  int c, d;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);

     b = edwards25519_decode(b1,(uint8_t*)b0);
     b_ref = reference_edwards25519decode(b3,(uint8_t*)b0);

     if (b != b_ref)
      { printf("Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" should be %s but isn't\n",
               k,b0[3],b0[0],
               (b_ref ? "invalid" : "valid"));

        return 1;
      }

     reference_edwards25519encode((uint8_t*)b2,b1);
     c = reference_compare(k,b2,k,b0);
     d = reference_compare(2*k,b3,2*k,b1);

     if ((b == 0) && (c != 0))
      { printf("### Disparity: [size %4"PRIu64"] "
               "encode <...0x%016"PRIx64",...%016"PRIx64"> = "
               "0x%016"PRIx64"...%016"PRIx64", input = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,b1[0],b1[4],b2[3],b2[0],b0[3],b0[0]);
        return 1;
      }

     if ((b == 0) && (d != 0))
      { printf("### Disparity: [size %4"PRIu64"] "
               "decode 0x%016"PRIx64"...%016"PRIx64" = "
              "<...0x%016"PRIx64",...0x%016"PRIx64"> not "
              "<...0x%016"PRIx64",...0x%016"PRIx64">\n",
              k,b0[3],b0[0],b1[0],b1[4],b3[0],b3[4]);
        return 1;
      }

     else if (VERBOSE && (b != 0))
      { printf("OK: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64
               " is correctly flagged as invalid\n",
               k,b0[3],b0[0]);
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
              "encode <...0x%016"PRIx64",...%016"PRIx64"> = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,b1[0],b1[4],b0[3],b0[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_edwards25519_decode_alt(void)
{ uint64_t t, k;
  printf("Testing edwards25519_decode_alt with %d cases\n",tests);
  k = 4;

  uint64_t b, b_ref;
  int c, d;
  for (t = 0; t < tests; ++t)
   { random_bignum(4,b0);

     b = edwards25519_decode_alt(b1,(uint8_t*)b0);
     b_ref = reference_edwards25519decode(b3,(uint8_t*)b0);

     if (b != b_ref)
      { printf("Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" should be %s but isn't\n",
               k,b0[3],b0[0],
               (b_ref ? "invalid" : "valid"));

        return 1;
      }

     reference_edwards25519encode((uint8_t*)b2,b1);
     c = reference_compare(k,b2,k,b0);
     d = reference_compare(2*k,b3,2*k,b1);

     if ((b == 0) && (c != 0))
      { printf("### Disparity: [size %4"PRIu64"] "
               "encode <...0x%016"PRIx64",...%016"PRIx64"> = "
               "0x%016"PRIx64"...%016"PRIx64", input = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,b1[0],b1[4],b2[3],b2[0],b0[3],b0[0]);
        return 1;
      }

     if ((b == 0) && (d != 0))
      { printf("### Disparity: [size %4"PRIu64"] "
               "decode 0x%016"PRIx64"...%016"PRIx64" = "
              "<...0x%016"PRIx64",...0x%016"PRIx64"> not "
              "<...0x%016"PRIx64",...0x%016"PRIx64">\n",
              k,b0[3],b0[0],b1[0],b1[4],b3[0],b3[4]);
        return 1;
      }

     else if (VERBOSE && (b != 0))
      { printf("OK: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64
               " is correctly flagged as invalid\n",
               k,b0[3],b0[0]);
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
              "encode <...0x%016"PRIx64",...%016"PRIx64"> = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,b1[0],b1[4],b0[3],b0[0]);
      }
   }
  printf("All OK\n");
  return 0;
}


int test_edwards25519_encode(void)
{ uint64_t t, k;
  printf("Testing edwards25519_encode with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(2*k,b1);
     b1[3] &= UINT64_C(0x7FFFFFFFFFFFFFFF);
     b1[7] &= UINT64_C(0x7FFFFFFFFFFFFFFF);

     edwards25519_encode((uint8_t*)b3,b1);
     reference_edwards25519encode((uint8_t*)b4,b1);

     c = reference_compare(k,b3,k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "encode <...0x%016"PRIx64",...%016"PRIx64"> = "
               "0x%016"PRIx64"...%016"PRIx64" not "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,b1[0],b1[4],b3[3],b3[0],b4[3],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
              "encode <...0x%016"PRIx64",...%016"PRIx64"> = "
               "0x%016"PRIx64"...%016"PRIx64"\n",
               k,b1[0],b1[4],b3[3],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}


int test_edwards25519_epadd(void)
{ uint64_t t, k;
  printf("Testing edwards25519_epadd with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b0); reference_mod(k,b1,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+2*k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+3*k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2+k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2+2*k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2+3*k,b0,p_25519);
     edwards25519_epadd(b3,b1,b2);
     reference_edwards25519epadd(b4,b1,b2);

     c = reference_compare(4*k,b3,4*k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "<...0x%016"PRIx64"> + <...0x%016"PRIx64"> = "
               "<...0x%016"PRIx64"> not <...0x%016"PRIx64">\n",
               k,b1[0],b2[0],b3[0],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "<...0x%016"PRIx64"> + <...0x%016"PRIx64"> = "
               "<...0x%016"PRIx64">\n",
               k,b1[0],b2[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_edwards25519_epadd_alt(void)
{ uint64_t t, k;
  printf("Testing edwards25519_epadd_alt with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b0); reference_mod(k,b1,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+2*k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+3*k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2+k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2+2*k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2+3*k,b0,p_25519);
     edwards25519_epadd_alt(b3,b1,b2);
     reference_edwards25519epadd(b4,b1,b2);

     c = reference_compare(4*k,b3,4*k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "<...0x%016"PRIx64"> + <...0x%016"PRIx64"> = "
               "<...0x%016"PRIx64"> not <...0x%016"PRIx64">\n",
               k,b1[0],b2[0],b3[0],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "<...0x%016"PRIx64"> + <...0x%016"PRIx64"> = "
               "<...0x%016"PRIx64">\n",
               k,b1[0],b2[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_edwards25519_epdouble(void)
{ uint64_t t, k;
  printf("Testing edwards25519_epdouble with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b0); reference_mod(k,b1,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+2*k,b0,p_25519);
     edwards25519_epdouble(b3,b1);
     reference_edwards25519epdouble(b4,b1);

     c = reference_compare(4*k,b3,4*k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2 * <...0x%016"PRIx64"> = "
               "<...0x%016"PRIx64"> not <...0x%016"PRIx64">\n",
               k,b1[0],b3[0],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2 * <...0x%016"PRIx64"> = "
               "<...0x%016"PRIx64">\n",
               k,b1[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_edwards25519_epdouble_alt(void)
{ uint64_t t, k;
  printf("Testing edwards25519_epdouble_alt with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b0); reference_mod(k,b1,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+2*k,b0,p_25519);
     edwards25519_epdouble_alt(b3,b1);
     reference_edwards25519epdouble(b4,b1);

     c = reference_compare(4*k,b3,4*k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2 * <...0x%016"PRIx64"> = "
               "<...0x%016"PRIx64"> not <...0x%016"PRIx64">\n",
               k,b1[0],b3[0],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2 * <...0x%016"PRIx64"> = "
               "<...0x%016"PRIx64">\n",
               k,b1[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_edwards25519_pdouble(void)
{ uint64_t t, k;
  printf("Testing edwards25519_pdouble with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b0); reference_mod(k,b1,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+2*k,b0,p_25519);
     edwards25519_pdouble(b3,b1);
     reference_edwards25519pdouble(b4,b1);

     c = reference_compare(3*k,b3,3*k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2 * <...0x%016"PRIx64"> = "
               "<...0x%016"PRIx64"> not <...0x%016"PRIx64">\n",
               k,b1[0],b3[0],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2 * <...0x%016"PRIx64"> = "
               "<...0x%016"PRIx64">\n",
               k,b1[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_edwards25519_pdouble_alt(void)
{ uint64_t t, k;
  printf("Testing edwards25519_pdouble_alt with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b0); reference_mod(k,b1,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+2*k,b0,p_25519);
     edwards25519_pdouble_alt(b3,b1);
     reference_edwards25519pdouble(b4,b1);

     c = reference_compare(3*k,b3,3*k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "2 * <...0x%016"PRIx64"> = "
               "<...0x%016"PRIx64"> not <...0x%016"PRIx64">\n",
               k,b1[0],b3[0],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "2 * <...0x%016"PRIx64"> = "
               "<...0x%016"PRIx64">\n",
               k,b1[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_edwards25519_pepadd(void)
{ uint64_t t, k;
  printf("Testing edwards25519_pepadd with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b0); reference_mod(k,b1,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+2*k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+3*k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2+k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2+2*k,b0,p_25519);
     edwards25519_pepadd(b3,b1,b2);
     reference_edwards25519pepadd(b4,b1,b2);

     c = reference_compare(4*k,b3,4*k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "<...0x%016"PRIx64"> + <...0x%016"PRIx64"> = "
               "<...0x%016"PRIx64"> not <...0x%016"PRIx64">\n",
               k,b1[0],b2[0],b3[0],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "<...0x%016"PRIx64"> + <...0x%016"PRIx64"> = "
               "<...0x%016"PRIx64">\n",
               k,b1[0],b2[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_edwards25519_pepadd_alt(void)
{ uint64_t t, k;
  printf("Testing edwards25519_pepadd_alt with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b0); reference_mod(k,b1,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+2*k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b1+3*k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2+k,b0,p_25519);
     random_bignum(k,b0); reference_mod(k,b2+2*k,b0,p_25519);
     edwards25519_pepadd_alt(b3,b1,b2);
     reference_edwards25519pepadd(b4,b1,b2);

     c = reference_compare(4*k,b3,4*k,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "<...0x%016"PRIx64"> + <...0x%016"PRIx64"> = "
               "<...0x%016"PRIx64"> not <...0x%016"PRIx64">\n",
               k,b1[0],b2[0],b3[0],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "<...0x%016"PRIx64"> + <...0x%016"PRIx64"> = "
               "<...0x%016"PRIx64">\n",
               k,b1[0],b2[0],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_edwards25519_scalarmulbase(void)
{ uint64_t t, k;
  printf("Testing edwards25519_scalarmulbase with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b1);

     // With non-zero probability exercise values near multiples of
     // the basepoint element order

     if ((rand() & 0xF) == 0)
      { bignum_cmul(4,b1,(rand() & 0xF),4,n_25519);
        if ((rand() & 0x3) == 0) b1[0] += (rand() & 0x3);
      }

     // With non-zero probability exercise close to top
     // word of the basepoint order 2^252

     if ((rand() & 0x3F) == 0)
      { b1[3] = UINT64_C(0x1000000000000000) * rand();
        b1[2] = random64d(6);
        b1[1] = random64();
        b1[0] = random64();
      }

     edwards25519_scalarmulbase(b3,b1);
     reference_edwards25519scalarmulbase(b4,b1);

     c = reference_compare(8,b3,8,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64"> not "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],g_edwards25519[3],g_edwards25519[0],b3[3],b3[0],b4[3],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],g_edwards25519[3],g_edwards25519[0],b3[3],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_edwards25519_scalarmulbase_alt(void)
{ uint64_t t, k;
  printf("Testing edwards25519_scalarmulbase_alt with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   { random_bignum(k,b1);

     // With non-zero probability exercise values near multiples of
     // the basepoint element order

     if ((rand() & 0xF) == 0)
      { bignum_cmul(4,b1,(rand() & 0xF),4,n_25519);
        if ((rand() & 0x3) == 0) b1[0] += (rand() & 0x3);
      }

     // With non-zero probability exercise close to top
     // word of the basepoint order 2^252

     if ((rand() & 0x3F) == 0)
      { b1[3] = UINT64_C(0x1000000000000000) * rand();
        b1[2] = random64d(6);
        b1[1] = random64();
        b1[0] = random64();
      }

     edwards25519_scalarmulbase_alt(b3,b1);
     reference_edwards25519scalarmulbase(b4,b1);

     c = reference_compare(8,b3,8,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64"> not "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],g_edwards25519[3],g_edwards25519[0],b3[3],b3[0],b4[3],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> = "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b1[3],b1[0],g_edwards25519[3],g_edwards25519[0],b3[3],b3[0]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_edwards25519_scalarmuldouble(void)
{ uint64_t t, k;
  printf("Testing edwards25519_scalarmuldouble with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   {
     random_bignum(k,b0);
     random_bignum(k,b3); reference_edwards25519scalarmulbase(b1,b3);
     random_bignum(k,b2);

     edwards25519_scalarmuldouble(b3,b0,b1,b2);
     reference_edwards25519scalarmuldouble(b4,b0,b1,b2);

     c = reference_compare(8,b3,8,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> + "
               "0x%016"PRIx64"...%016"PRIx64" * base = "
               "<...0x%016"PRIx64"...%016"PRIx64"> not "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b0[3],b0[0],b1[3],b1[0],b2[3],b2[0],b3[3],b3[0],b4[3],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> + ... * ... = "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b0[3],b0[0],b1[3],b1[0],b3[3],b3[0]);
     }
   }
  printf("All OK\n");
  return 0;
}

int test_edwards25519_scalarmuldouble_alt(void)
{ uint64_t t, k;
  printf("Testing edwards25519_scalarmuldouble_alt with %d cases\n",tests);
  k = 4;

  int c;
  for (t = 0; t < tests; ++t)
   {
     random_bignum(k,b0);
     random_bignum(k,b3); reference_edwards25519scalarmulbase(b1,b3);
     random_bignum(k,b2);

     edwards25519_scalarmuldouble_alt(b3,b0,b1,b2);
     reference_edwards25519scalarmuldouble(b4,b0,b1,b2);

     c = reference_compare(8,b3,8,b4);
     if (c != 0)
      { printf("### Disparity: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> + "
               "0x%016"PRIx64"...%016"PRIx64" * base = "
               "<...0x%016"PRIx64"...%016"PRIx64"> not "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b0[3],b0[0],b1[3],b1[0],b2[3],b2[0],b3[3],b3[0],b4[3],b4[0]);
        return 1;
      }
     else if (VERBOSE)
      { printf("OK: [size %4"PRIu64"] "
               "0x%016"PRIx64"...%016"PRIx64" * "
               "<0x%016"PRIx64"...%016"PRIx64"> + ... * ... = "
               "<...0x%016"PRIx64"...%016"PRIx64">\n",
               k,b0[3],b0[0],b1[3],b1[0],b3[3],b3[0]);
     }
   }
  printf("All OK\n");
  return 0;
}

=======
>>>>>>> 56f41495 (Added spec test to intt)
#ifdef __x86_64__
static void mlkem_poly_to_avx2_layout(int16_t a[256])
{
  int16_t b[256];
  uint64_t i, j;
  for (i = 0; i < 8; i++)
    for (j = 0; j < 16; j++)
      b[16*i+j] = a[8*j+i];

  for (i = 0; i < 8; i++)
    for (j = 0; j < 16; j++)
      b[128+16*i+j] = a[128+8*j+i];

  for (i = 0; i < 256; i++)
    a[i] = b[i];
}

static void mlkem_polyvec_to_avx2_layout(int16_t *a, int k)
{
  uint64_t i;
  for (i = 0; i < k; i++)
    mlkem_poly_to_avx2_layout(&a[i*256]);
}

static void mlkem_poly_mulcache_to_avx2_layout(int16_t a[128])
{
  int16_t b[128];
  uint64_t i, j;

  for (i = 0; i < 4; i++)
    for (j = 0; j < 16; j++)
      b[16*i+j] = (i & 1) ? -a[4*j+i] : a[4*j+i];

  for (i = 0; i < 4; i++)
    for (j = 0; j < 16; j++)
      b[64+16*i+j] = (i & 1) ? -a[64+4*j+i] : a[64+4*j+i];

  for (i = 0; i < 128; i++)
    a[i] = b[i];

}
#endif

int test_mlkem_basemul_k2(void)
{
uint64_t t, i;
  int16_t a[512] __attribute__((aligned(32)));
  int16_t b[512] __attribute__((aligned(32)));
  int16_t x[256] __attribute__((aligned(32)));
  int16_t y[256] __attribute__((aligned(32)));
  int16_t bt[256] __attribute__((aligned(32)));
  printf("Testing mlkem_basemul_k2 with %d cases\n",tests);

  for (t = 0; t < tests; ++t)
   { for (i = 0; i < 512; ++i)
        a[i] = (int16_t) (random64() % 4097),
        b[i] = (int16_t) (random64() % 4097); // Assumed <= 2^12
     reference_basemul2(y,a,b);
     reference_mulcache_compute(bt,b);
     reference_mulcache_compute(bt+128,b+256);

#ifdef __x86_64__
     mlkem_polyvec_to_avx2_layout(a, 2);
     mlkem_polyvec_to_avx2_layout(b, 2);
     mlkem_poly_mulcache_to_avx2_layout(bt);
     mlkem_poly_mulcache_to_avx2_layout(bt+128);
#endif

     mlkem_basemul_k2(x,a,b,bt);

#ifdef __x86_64__
     mlkem_poly_to_avx2_layout(y);
#endif

     for (i = 0; i < 256; ++i)
      { if (rem_3329(x[i]) != rem_3329(y[i]))
         { printf("Error in basemul_k2 element i = %"PRIu64"; code[i] = 0x%04"PRIx16
                  " while reference[i] = 0x%04"PRIx16"\n",
                  i,x[i],y[i]);
           return 1;
         }
      }
     if (VERBOSE)
      { printf("OK: basemul_k2[0x%04"PRIx16",0x%04"PRIx16",...,"
               "0x%04"PRIx16",0x%04"PRIx16"] = "
               "[0x%04"PRIx16",0x%04"PRIx16",...,"
               "0x%04"PRIx16",0x%04"PRIx16"]\n",
               a[0],a[1],a[510],a[511],
               x[0],x[1],x[254],x[255]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_mlkem_basemul_k3(void)
{
uint64_t t, i;
  int16_t a[768] __attribute__((aligned(32)));
  int16_t b[768] __attribute__((aligned(32)));
  int16_t x[256] __attribute__((aligned(32)));
  int16_t y[256] __attribute__((aligned(32)));
  int16_t bt[384] __attribute__((aligned(32)));
  printf("Testing mlkem_basemul_k3 with %d cases\n",tests);

  for (t = 0; t < tests; ++t)
   { for (i = 0; i < 768; ++i)
        a[i] = (int16_t) (random64() % 4097),
        b[i] = (int16_t) (random64() % 4097); // Assumed <= 2^12
     reference_basemul3(y,a,b);
     reference_mulcache_compute(bt,b);
     reference_mulcache_compute(bt+128,b+256);
     reference_mulcache_compute(bt+256,b+512);

#ifdef __x86_64__
     mlkem_polyvec_to_avx2_layout(a, 3);
     mlkem_polyvec_to_avx2_layout(b, 3);
     mlkem_poly_mulcache_to_avx2_layout(bt);
     mlkem_poly_mulcache_to_avx2_layout(bt+128);
     mlkem_poly_mulcache_to_avx2_layout(bt+256);
#endif

     mlkem_basemul_k3(x,a,b,bt);

#ifdef __x86_64__
     mlkem_poly_to_avx2_layout(y);
#endif

     for (i = 0; i < 256; ++i)
      { if (rem_3329(x[i]) != rem_3329(y[i]))
         { printf("Error in basemul_k3 element i = %"PRIu64"; code[i] = 0x%04"PRIx16
                  " while reference[i] = 0x%04"PRIx16"\n",
                  i,x[i],y[i]);
           return 1;
         }
      }
     if (VERBOSE)
      { printf("OK: basemul_k3[0x%04"PRIx16",0x%04"PRIx16",...,"
               "0x%04"PRIx16",0x%04"PRIx16"] = "
               "[0x%04"PRIx16",0x%04"PRIx16",...,"
               "0x%04"PRIx16",0x%04"PRIx16"]\n",
               a[0],a[1],a[766],a[767],
               x[0],x[1],x[254],x[255]);
      }
   }
  printf("All OK\n");
  return 0;
}


int test_mlkem_basemul_k4(void)
{
uint64_t t, i;
  int16_t a[1024] __attribute__((aligned(32)));
  int16_t b[1024] __attribute__((aligned(32)));
  int16_t x[256] __attribute__((aligned(32)));
  int16_t y[256] __attribute__((aligned(32)));
  int16_t bt[512] __attribute__((aligned(32)));
  printf("Testing mlkem_basemul_k4 with %d cases\n",tests);

  for (t = 0; t < tests; ++t)
   { for (i = 0; i < 1024; ++i)
        a[i] = (int16_t) (random64() % 4097),
        b[i] = (int16_t) (random64() % 4097); // Assumed <= 2^12
     reference_basemul4(y,a,b);
     reference_mulcache_compute(bt,b);
     reference_mulcache_compute(bt+128,b+256);
     reference_mulcache_compute(bt+256,b+512);
     reference_mulcache_compute(bt+384,b+768);

#ifdef __x86_64__
     mlkem_polyvec_to_avx2_layout(a, 4);
     mlkem_polyvec_to_avx2_layout(b, 4);
     mlkem_poly_mulcache_to_avx2_layout(bt);
     mlkem_poly_mulcache_to_avx2_layout(bt+128);
     mlkem_poly_mulcache_to_avx2_layout(bt+256);
     mlkem_poly_mulcache_to_avx2_layout(bt+384);
#endif

     mlkem_basemul_k4(x,a,b,bt);

#ifdef __x86_64__
     mlkem_poly_to_avx2_layout(y);
#endif

     for (i = 0; i < 256; ++i)
      { if (rem_3329(x[i]) != rem_3329(y[i]))
         { printf("Error in basemul_k4 element i = %"PRIu64"; code[i] = 0x%04"PRIx16
                  " while reference[i] = 0x%04"PRIx16"\n",
                  i,x[i],y[i]);
           return 1;
         }
      }
     if (VERBOSE)
      { printf("OK: basemul_k4[0x%04"PRIx16",0x%04"PRIx16",...,"
               "0x%04"PRIx16",0x%04"PRIx16"] = "
               "[0x%04"PRIx16",0x%04"PRIx16",...,"
               "0x%04"PRIx16",0x%04"PRIx16"]\n",
               a[0],a[1],a[1022],a[1023],
               x[0],x[1],x[254],x[255]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_mlkem_intt(void)
{
  uint64_t t, i;
  int16_t a[256] __attribute__((aligned(32)));
  int16_t b[256] __attribute__((aligned(32)));
  int16_t c[256] __attribute__((aligned(32)));
  printf("Testing mlkem_intt with %d cases\n",tests);

  for (t = 0; t < tests; ++t)
   { for (i = 0; i < 256; ++i)
        a[i] = (int16_t) (random64()); // any int16_t inputs allowed
     for (i = 0; i < 256; ++i) b[i] = a[i];
#ifdef __x86_64__
     mlkem_poly_to_avx2_layout(b);
     mlkem_intt_x86(b,mlkem_qdata);
#else
     mlkem_intt(b,intt_zetas_layer01234,intt_zetas_layer56);
#endif

     reference_bitreverse(c,a);
     reference_inverse_ntt(c,c);
     reference_tomont3329(c,c);


     for (i = 0; i < 256; ++i)
      { if (rem_3329(b[i]) != rem_3329(c[i]))
         { printf("Error in iNTT element i = %"PRIu64"; code[i] = 0x%04"PRIx16
                  " while reference[i] = 0x%04"PRIx16"\n",
                  i,rem_3329(b[i]),rem_3329(c[i]));
           return 1;
         }
      }
     if (VERBOSE)
      { printf("OK: iNTT[0x%04"PRIx16",0x%04"PRIx16",...,"
               "0x%04"PRIx16",0x%04"PRIx16"] = "
               "[0x%04"PRIx16",0x%04"PRIx16",...,"
               "0x%04"PRIx16",0x%04"PRIx16"]\n",
               a[0],a[1],a[254],a[255],
               c[0],c[1],c[254],c[255]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_mlkem_mulcache_compute(void)
{
uint64_t t, i;
  int16_t a[256] __attribute__((aligned(32)));
  int16_t x[128] __attribute__((aligned(32)));
  int16_t y[128] __attribute__((aligned(32)));
  int16_t z[128] __attribute__((aligned(32)));
  printf("Testing mlkem_mulcache_compute with %d cases\n",tests);

  for (t = 0; t < tests; ++t)
   { for (i = 0; i < 256; ++i)
        a[i] = (int16_t) (random64());

     reference_mulcache_compute(y,a);

#ifdef __x86_64__
     mlkem_poly_mulcache_to_avx2_layout(y);

     mlkem_poly_to_avx2_layout(a);
     mlkem_mulcache_compute_x86(x,a,mlkem_qdata);
#else
     mlkem_mulcache_compute(x,a,mulcache_zetas,mulcache_zetas_twisted);
#endif

     for (i = 0; i < 128; ++i)
      { if (rem_3329(x[i]) != rem_3329(y[i]))
         { printf("Error in mulcache element i = %"PRIu64"; code[i] = 0x%04"PRIx16
                  " while reference[i] = 0x%04"PRIx16"\n",
                  i,rem_3329(x[i]),rem_3329(y[i]));
           return 1;
         }
      }
     if (VERBOSE)
      { printf("OK: mulcache[0x%04"PRIx16",0x%04"PRIx16",...,"
               "0x%04"PRIx16",0x%04"PRIx16"] = "
               "[0x%04"PRIx16",0x%04"PRIx16",...,"
               "0x%04"PRIx16",0x%04"PRIx16"]\n",
               a[0],a[1],a[254],a[255],
               x[0],x[1],x[126],x[127]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_mlkem_ntt(void)
{
uint64_t t, i;
  int16_t a[256] __attribute__((aligned(32)));
  int16_t b[256] __attribute__((aligned(32)));
  int16_t c[256] __attribute__((aligned(32)));
  printf("Testing mlkem_ntt with %d cases\n",tests);

  for (t = 0; t < tests; ++t)
   { for (i = 0; i < 256; ++i)
        a[i] = (int16_t) (random64() % 16383) - 8192; // |a[i]| < 8192 assumed
     for (i = 0; i < 256; ++i) b[i] = a[i];
#ifdef __x86_64__
     mlkem_ntt_x86(b, mlkem_qdata);
     reference_forward_ntt(c,a); reference_bitreverse(c,c);
     mlkem_poly_to_avx2_layout(c);
#else
     mlkem_ntt(b,ntt_zetas_layer01234,ntt_zetas_layer56);
     reference_forward_ntt(c,a); reference_bitreverse(c,c);
#endif

     for (i = 0; i < 256; ++i)
      { if (rem_3329(b[i]) != rem_3329(c[i]))
         { printf("Error in NTT element i = %"PRIu64"; code[i] = 0x%04"PRIx16
                  " while reference[i] = 0x%04"PRIx16"\n",
                  i,b[i],c[i]);
           return 1;
         }
      }
     if (VERBOSE)
      { printf("OK: NTT[0x%04"PRIx16",0x%04"PRIx16",...,"
               "0x%04"PRIx16",0x%04"PRIx16"] = "
               "[0x%04"PRIx16",0x%04"PRIx16",...,"
               "0x%04"PRIx16",0x%04"PRIx16"]\n",
               a[0],a[1],a[254],a[255],
               c[0],c[1],c[254],c[255]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_mlkem_reduce(void)
{
uint64_t t, i;
  int16_t a[256], b[256] __attribute__((aligned(32)));
  printf("Testing mlkem_reduce with %d cases\n",tests);

  for (t = 0; t < tests; ++t)
   { for (i = 0; i < 256; ++i)
        b[i] = a[i] = (int16_t) (random64() % 65536) - 32768;
     mlkem_reduce(b);
     for (i = 0; i < 256; ++i)
      { if (rem_3329(a[i]) != b[i])
         { printf("Error in mlkem_reduce; element i = %"PRIu64
                  "; code[i] = 0x%04"PRIx16
                  " while reference[i] = 0x%04"PRIx16"\n",
                  i,b[i],rem_3329(a[i]));
           return 1;
         }
      }
     if (VERBOSE)
      { printf("OK:mlkem_reduce[0x%04"PRIx16",0x%04"PRIx16",...,"
               "0x%04"PRIx16",0x%04"PRIx16"] = "
               "[0x%04"PRIx16",0x%04"PRIx16",...,"
               "0x%04"PRIx16",0x%04"PRIx16"]\n",
               a[0],a[1],a[254],a[255],
               b[0],b[1],b[254],b[255]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_mlkem_unpack(void)
{
#ifdef __x86_64__
uint64_t t, i;
  int16_t a[256] __attribute__((aligned(32)));
  int16_t b[256] __attribute__((aligned(32)));
  printf("Testing mlkem_unpack with %d cases\n",tests);

  for (t = 0; t < tests; ++t)
   { for (i = 0; i < 256; ++i)
      { a[i] = random64() & 0xff;
        b[i] = a[i];
      }

     mlkem_unpack(a);

     mlkem_poly_to_avx2_layout(b);

     for (i = 0; i < 256; ++i)
      { if (a[i] != b[i])
         { printf("Error in mlkem_unpack; element i = %"PRIu64
                  "; expected output for input[i] = 0x%03"PRIx16
                  " while output is = 0x%03"PRIx16"\n",
                  i,b[i],a[i]);
           return 1;
         }
      }
   }
  printf("All OK\n");
  return 0;
#else
  return 0;
#endif
}

int test_mlkem_frombytes(void)
{
#ifdef __x86_64__
uint64_t t, i;
  uint8_t a[384] __attribute__((aligned(32)));
  int16_t b[256] __attribute__((aligned(32)));
  int16_t c[256] __attribute__((aligned(32)));
  printf("Testing mlkem_frombytes with %d cases\n",tests);

  for (t = 0; t < tests; ++t)
   { for (i = 0; i < 384; ++i) a[i] = random64() & 0xff;

     mlkem_frombytes(b,a);

     for (i = 0; i < 128; ++i)
      { const uint8_t t0 = a[3 * i + 0];
        const uint8_t t1 = a[3 * i + 1];
        const uint8_t t2 = a[3 * i + 2];

        c[2*i+0] = (int16_t)(t0 | ((t1 << 8) & 0xFFF));
        c[2*i+1] = (int16_t)((t1 >> 4) | (t2 << 4));
      }

     mlkem_poly_to_avx2_layout(c);

     for (i = 0; i < 256; ++i)
      { if (c[i] != b[i])
         { printf("Error in mlkem_frombytes; element i = %"PRIu64
                  "; expected output for input[i] = 0x%03"PRIx16
                  " while output is = 0x%03"PRIx16"\n",
                  i,c[i],b[i]);
           return 1;
         }
      }
   }
  printf("All OK\n");
  return 0;
#else
  return 0;
#endif
}


int test_mlkem_tobytes(void)
{
#ifdef __x86_64__
  return 1;
#else
uint64_t t, i;
  int16_t a[256];
  uint8_t c[384];
  printf("Testing mlkem_tobytes with %d cases\n",tests);

  for (t = 0; t < tests; ++t)
   { for (i = 0; i < 256; ++i) a[i] = random64() % 3329;
     mlkem_tobytes(c,a);
     for (i = 0; i < 256; ++i)
      { uint64_t j = (12 * i) / 8;
        uint64_t k = (12 * i) % 8;
        uint64_t c0 = c[j];
        uint64_t c1 = c[j+1];
        uint64_t c01 = ((c0 + (c1<<8))>>k) & UINT64_C(0xFFF);
        if (c01 != a[i])
         { printf("Error in mlkem_tobytes; element i = %"PRIu64
                  "; packed output for input[i] = 0x%03"PRIx64
                  " while input[i] = 0x%03"PRIx16"\n",
                  i,c01,a[i]);
           return 1;
         }
      }
     if (VERBOSE)
      { printf("OK:mlkem_tobytes[0x%03"PRIx16",0x%03"PRIx16",...,"
               "0x%03"PRIx16",0x%03"PRIx16"] = "
               "[0x%02"PRIx8",0x%02"PRIx8",...,"
               "0x%02"PRIx8",0x%02"PRIx8"]\n",
               a[0],a[1],a[254],a[255],
               c[0], c[1],c[382],c[383]);
      }
   }
  printf("All OK\n");
  return 0;
#endif
}

int test_mlkem_tomont(void)
{
uint64_t t, i;
  int16_t a[256] __attribute__((aligned(32)));
  int16_t b[256] __attribute__((aligned(32)));
  printf("Testing mlkem_tomont with %d cases\n",tests);

  for (t = 0; t < tests; ++t)
   { for (i = 0; i < 256; ++i)
        b[i] = a[i] = (int16_t) (random64() % 65536) - 32768;
     mlkem_tomont(b);
     for (i = 0; i < 256; ++i)
      { int16_t r = (int16_t)
         ((UINT64_C(65536) * mod_3329(a[i])) % UINT64_C(3329));
        if ((mod_3329(b[i]) != mod_3329(r)) ||
            b[i] <= -3329 || b[i] >= 3329)
         { printf("Error in mlkem_tomont; element i = %"PRIu64
                  "; code[i] = 0x%04"PRIx16
                  " while expected[i] = 0x%04"PRIx16" or 0x%04"PRIx16"\n",
                  i,b[i],r,r-3329);
           return 1;
         }
      }
     if (VERBOSE)
      { printf("OK:mlkem_tomont[0x%04"PRIx16",0x%04"PRIx16",...,"
               "0x%04"PRIx16",0x%04"PRIx16"] = "
               "[0x%04"PRIx16",0x%04"PRIx16",...,"
               "0x%04"PRIx16",0x%04"PRIx16"]\n",
               a[0],a[1],a[254],a[255],
               b[0],b[1],b[254],b[255]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_mlkem_rej_uniform(void)
{
  uint64_t t, i;
  uint8_t inbuf[24*160];
   int16_t a[256], b[256];
  uint64_t ac, bc;

  printf("Testing mlkem_rej_uniform_VARIABLE_TIME with %d cases\n",tests);

  for (t = 0; t < tests; ++t)
   { uint64_t buflen = 24 * (rand() % 160);
     for (i = 0; i < buflen; ++i) inbuf[i] = (uint8_t) rand();
     ac = reference_rej_uniform(a,inbuf,buflen);
     bc = mlkem_rej_uniform_VARIABLE_TIME(b,inbuf,buflen,mlkem_rej_uniform_table);
     if (ac != bc)
      { printf("Error in number of elements returned; code = %"PRIu64
               ", ref = %"PRIu64"\n",bc,ac);
        return 1;
      }
     for (i = 0; i < ac; ++i)
      { if (a[i] != b[i])
         { printf("Error in mlkem_rej_uniform_VARIABLE_TIME; element i = %"PRIu64
                  "; code[i] = %"PRId16
                  " while reference[i] = %"PRId16"\n",
                  i,b[i],a[i]);
           return 1;
         }
      }
     if (VERBOSE)
      { printf("OK:mlkem_rej_uniform_VARIABLE_TIME, input %4"PRIu64" bytes = %4"PRIu64" elements, returned %4"PRIu64" elements: "
               "[0x%04"PRIx16",...,0x%04"PRIx16"]\n",
              buflen,(2*buflen)/3,bc,b[0],b[(bc==0) ? 0 : bc-1]);
      }
   }
  printf("All OK\n");
  return 0;
}

int test_mldsa_poly_reduce(void)
{
    // Skip test on non-x86_64 architectures
    if (get_arch_name() != ARCH_X86_64) {
        return 0;
    }

#ifdef __x86_64__
    uint64_t t, i;
    // 32-byte alignment for AVX2 vmovdqa instructions
    int32_t a[256] __attribute__((aligned(32)));
    int32_t b[256] __attribute__((aligned(32)));

    printf("Testing mldsa_poly_reduce with %d cases\n", tests);

    for (t = 0; t < tests; ++t) {
        for (i = 0; i < 256; ++i)
            // Generate random int32_t values across full range [-2^31, 2^31-1]
            b[i] = a[i] = (int32_t) (random64() % 4294967296ULL) - 2147483648LL;

        mldsa_poly_reduce(b);

        for (i = 0; i < 256; ++i) {
            if (reference_poly_reduce(a[i]) != b[i]) {
                printf("Error in mldsa_poly_reduce; element i = %"PRIu64
                       "; code[i] = 0x%08"PRIx32
                       " while reference[i] = 0x%08"PRIx32"\n",
                       i, b[i], reference_poly_reduce(a[i]));
                return 1;
            }
        }

        if (VERBOSE) {
            printf("OK:mldsa_poly_reduce[0x%08"PRIx32",0x%08"PRIx32",...,"
                   "0x%08"PRIx32",0x%08"PRIx32"] = "
                   "[0x%08"PRIx32",0x%08"PRIx32",...,"
                   "0x%08"PRIx32",0x%08"PRIx32"]\n",
                   a[0], a[1], a[254], a[255],
                   b[0], b[1], b[254], b[255]);
        }
    }
    printf("All OK\n");
    return 0;
#else
    return 0;  // Fallback for non-x86_64 compile-time environments
#endif
}

int test_mldsa_ntt(void)
{
    // Skip test on non-x86_64 architectures
    if (get_arch_name() != ARCH_X86_64) {
        return 0;
    }

#ifdef __x86_64__
    uint64_t t, i;
    // 32-byte alignment for AVX2 vmovdqa instructions
    int32_t a[256] __attribute__((aligned(32)));
    int32_t b[256] __attribute__((aligned(32)));

    printf("Testing mldsa_ntt with %d cases\n", tests);

    for (t = 0; t < tests; ++t) {
        // Generate random input polynomial coefficients (like MLKEM does)
        for (i = 0; i < 256; ++i) {
            a[i] = (int32_t)(random64() % (2 * 8380417)) - 8380417;
            b[i] = a[i];  // Copy for assembly implementation
        }

        // Call the x86 assembly implementation with complete AVX2 data structure
        mldsa_ntt(b, mldsa_avx2_data);

        // Test against HOL-Light specification implementation
        reference_mldsa_forward_ntt_spec(a);

        // Compare results (apply reduction to both values for comparison)
        for (i = 0; i < 256; ++i) {
            int32_t reduced_a = reference_poly_reduce(a[i]);
            int32_t reduced_b = reference_poly_reduce(b[i]);

            // Also check if they're congruent modulo MLDSA_Q
            if (reduced_a != reduced_b) {
                // Check if they differ by a multiple of MLDSA_Q
                int64_t diff = (int64_t)a[i] - (int64_t)b[i];
                if (diff % 8380417 != 0) {
                    printf("Error in mldsa_ntt element i = %"PRIu64"; "
                           "code[%"PRIu64"] = 0x%08"PRIx32" (reduced: 0x%08"PRIx32") while reference[%"PRIu64"] = 0x%08"PRIx32" (reduced: 0x%08"PRIx32")\n",
                           i, i, b[i], reduced_b, i, a[i], reduced_a);
                    return 1;
                }
            }
        }

        if (VERBOSE) {
            printf("OK: mldsa_ntt[0x%08"PRIx32",0x%08"PRIx32",...,"
                   "0x%08"PRIx32",0x%08"PRIx32"] = "
                   "[0x%08"PRIx32",0x%08"PRIx32",...,"
                   "0x%08"PRIx32",0x%08"PRIx32"]\n",
                   a[0], a[1], a[254], a[255],
                   b[0], b[1], b[254], b[255]);
        }
    }

    printf("All OK\n");
    return 0;
#else
    return 0;  // Fallback for non-x86_64 compile-time environments
#endif
}

// Test mldsa_intt: validates both assembly and C reference specification
// Tests that both NTT/iNTT pairs are proper inverses
int test_mldsa_intt(void)
{
    // Skip test on non-x86_64 architectures
    if (get_arch_name() != ARCH_X86_64) {
        return 0;
    }

#ifdef __x86_64__
    uint64_t t, i;
    int32_t original[256] __attribute__((aligned(32)));
    int32_t asm_result[256] __attribute__((aligned(32)));
    int32_t spec_result[256] __attribute__((aligned(32)));
    int32_t temp[256] __attribute__((aligned(32)));
    
    printf("Testing mldsa_intt with %d cases\n", tests);
    
    for (t = 0; t < tests; ++t) {
        const int32_t MLDSA_Q = 8380417;
        
        // Generate random normal-form coefficients
        for (i = 0; i < 256; ++i)
            original[i] = (int32_t)(random64() % (2 * 8380417)) - 8380417;
        
        // Test 1: Assembly NTT  Assembly iNTT round-trip
        for (i = 0; i < 256; ++i) temp[i] = original[i];
        mldsa_ntt(temp, mldsa_avx2_data);
        for (i = 0; i < 256; ++i) asm_result[i] = temp[i];
        mldsa_intt(asm_result, mldsa_avx2_data);
        reference_frommont_mldsa(asm_result);
        
        // Test 2: C reference NTT  C reference iNTT round-trip  
        for (i = 0; i < 256; ++i) temp[i] = original[i];
        reference_mldsa_forward_ntt(temp);
        for (i = 0; i < 256; ++i) spec_result[i] = temp[i];
        reference_mldsa_inverse_ntt(spec_result);
        reference_frommont_mldsa(spec_result);
        
        // Both should recover the original (modulo q)
        // Assembly may produce negation due to sign convention
        for (i = 0; i < 256; ++i) {
            int32_t norm_original = ((original[i] % MLDSA_Q) + MLDSA_Q) % MLDSA_Q;
            int32_t norm_asm = ((asm_result[i] % MLDSA_Q) + MLDSA_Q) % MLDSA_Q;
            int32_t norm_spec = ((spec_result[i] % MLDSA_Q) + MLDSA_Q) % MLDSA_Q;
            int32_t norm_negated = ((MLDSA_Q - norm_original) % MLDSA_Q);
            
            // Assembly: accept original or negation (sign convention)
            int asm_ok = (norm_asm == norm_original) || (norm_asm == norm_negated);
            // Spec: must match original exactly
            int spec_ok = (norm_spec == norm_original);
            
            if (!asm_ok || !spec_ok) {
                printf("Error at element i = %"PRIu64":\n", i);
                printf("  Original: 0x%08"PRIx32" (norm: 0x%08"PRIx32")\n",
                       original[i], norm_original);
                printf("  Assembly round-trip: 0x%08"PRIx32" (norm: 0x%08"PRIx32") %s\n",
                       asm_result[i], norm_asm, asm_ok ? "" : "");
                printf("  Spec round-trip: 0x%08"PRIx32" (norm: 0x%08"PRIx32") %s\n",
                       spec_result[i], norm_spec, spec_ok ? "" : "");
                return 1;
            }
        }
        
        if (VERBOSE) {
            // Display using spec NTT input/output
            for (i = 0; i < 256; ++i) temp[i] = original[i];
            reference_mldsa_forward_ntt(temp);
            
            printf("OK: iNTT[0x%08"PRIx32",0x%08"PRIx32",...,"
                   "0x%08"PRIx32",0x%08"PRIx32"] = "
                   "[0x%08"PRIx32",0x%08"PRIx32",...,"
                   "0x%08"PRIx32",0x%08"PRIx32"]\n",
                   temp[0], temp[1], temp[254], temp[255],
                   spec_result[0], spec_result[1], spec_result[254], spec_result[255]);
        }
    }
    
    printf("All OK\n");
    return 0;
#else
    return 0;  // Fallback for non-x86_64 compile-time environments
#endif
}

// ****************************************************************************
// Main dispatching to appropriate test code
// ****************************************************************************

static char *function_to_test;
static int tested = 0;
static int successes = 0;
static int failures = 0;
static int skipped = 0;
static int inapplicable = 0;

// functionaltest runs f() if enabled is true and records the result.
// If the return value is nonzero, the test has failed.
void functionaltest(int enabled,char *name,int (*f)(void))
{ ++tested;
  // Only benchmark matching function name
  // Empty string matches everything, terminal _ matches everything

  char *spaceptr = strchr(name,' ');
  int compline = (spaceptr) ? spaceptr-name : strlen(name);
  int wantline = strlen(function_to_test);
  int testline = wantline;
  if (wantline == 0) testline = 0;
  else if (function_to_test[wantline-1] == '_') testline = wantline - 1;
  else if (testline < compline) testline = compline;
  if (strncmp(name,function_to_test,testline))
   { ++skipped;
     return;
   }

  // Only benchmark function using supported instructions

  if (!enabled)
   { printf("Skipping %s because not applicable (%s support)\n",name,
            (get_arch_name() == ARCH_AARCH64) ? "ARM sha3" :
            "x86 BMI/ADX");
     ++inapplicable;
     return;
   }

  if (f()) ++failures; else ++successes;
}

// Main function allowing various command-line options:
//
// ./test [-number_of_tests] [function]
// ./test [[+]number_of_tests] [function]
//
// the difference being that the second one also runs extra
// tests like known value tests even if not explicitly
// selected in the function list.
//
// The function can end in an underscore which is interpreted
// as a wildcard "*", e.g. "bignum_add_p_"

int main(int argc, char *argv[])
{ int bmi = get_arch_name() == ARCH_AARCH64 || supports_bmi2_and_adx();
  int sha3 = get_arch_name() == ARCH_AARCH64 && supports_arm_sha3();
  int arm = get_arch_name() == ARCH_AARCH64;
  int all = 1;
  int extrastrigger = 1;

  char *argending;
  long negreps;
  function_to_test = "";
  tests = TESTS;

  if (argc >= 2)
   { negreps = strtol(argv[1],&argending,10);
     if (negreps <= 0) extrastrigger = 0;
     if (negreps >= 0) negreps = -negreps;
     if (argending == argv[1])
      { if (argc >= 3 || argv[1][0] == '-')
         { printf("Usage: ./test [-reps] [function_name]\n");
           printf(" e.g.: ./test -1000 bignum_add\n");
           printf("   or: ./test -25 bignum_mul_\n");
           return (-1);
         }
        else function_to_test = argv[1];
      }
     else
      { tests = -negreps;
        if (argc >= 3) function_to_test = argv[2];
      }
   }

  if (tests == 0) tests = TESTS;

  // ML-DSA tests
  functionaltest(all,"mldsa_intt",test_mldsa_intt);
  functionaltest(all,"mldsa_ntt",test_mldsa_ntt);
  //functionaltest(all,"mldsa_poly_reduce",test_mldsa_poly_reduce);
  /* 
  // ML-KEM tests
  functionaltest(all,"mlkem_basemul_k2",test_mlkem_basemul_k2);
  functionaltest(all,"mlkem_basemul_k3",test_mlkem_basemul_k3);
  functionaltest(all,"mlkem_basemul_k4",test_mlkem_basemul_k4);
  functionaltest(all,"mlkem_intt",test_mlkem_intt);
  functionaltest(all,"mlkem_ntt",test_mlkem_ntt);
  functionaltest(all,"mlkem_reduce",test_mlkem_reduce);
  
  if (get_arch_name() == ARCH_AARCH64) {
    functionaltest(arm,"mlkem_mulcache_compute",test_mlkem_mulcache_compute);
    functionaltest(arm,"mlkem_tobytes",test_mlkem_tobytes);
    functionaltest(arm,"mlkem_tomont",test_mlkem_tomont);
    functionaltest(arm,"mlkem_rej_uniform_VARIABLE_TIME",test_mlkem_rej_uniform);
  }
*/
  if (successes == tested)
   { printf("All %d tests run, all passed\n",successes);
     return 0;
   }

  if (successes + skipped == tested)
   { printf("Skipped %d but all %d selected tests passed\n",skipped,successes);
     return 1;
   }

  if (failures != 0) printf("***** FAILED %d tests\n",failures);
  else printf("Testing all passed but is incomplete\n");
  printf("                     Total operations to test = %3d\n",tested);
  printf("                                       Passed = %3d\n",successes);
  printf("                                      Failed  = %3d\n",failures);
  printf("         Skipped because not selected by user = %3d\n",skipped);
  printf("Skipped because inapplicable (no %s) = %3d\n",
         ((get_arch_name() == ARCH_AARCH64) ? "ARM sha3" : "x86 BMI/ADX"),inapplicable);
  return 1;
}
/*
  functionaltest(all,"bignum_add_p25519",test_bignum_add_p25519);
  functionaltest(all,"bignum_add_p256",test_bignum_add_p256);
  functionaltest(all,"bignum_add_p256k1",test_bignum_add_p256k1);
  functionaltest(all,"bignum_add_p384",test_bignum_add_p384);
  functionaltest(all,"bignum_add_p521",test_bignum_add_p521);
  functionaltest(all,"bignum_add_sm2",test_bignum_add_sm2);
  functionaltest(all,"bignum_amontifier",test_bignum_amontifier);
  functionaltest(all,"bignum_amontmul",test_bignum_amontmul);
  functionaltest(all,"bignum_amontredc",test_bignum_amontredc);
  functionaltest(all,"bignum_amontsqr",test_bignum_amontsqr);
  functionaltest(all,"bignum_bigendian_4",test_bignum_bigendian_4);
  functionaltest(all,"bignum_bigendian_6",test_bignum_bigendian_6);
  functionaltest(all,"bignum_bitfield",test_bignum_bitfield);
  functionaltest(all,"bignum_bitsize",test_bignum_bitsize);
  functionaltest(all,"bignum_cdiv",test_bignum_cdiv);
  functionaltest(all,"bignum_cdiv_exact",test_bignum_cdiv_exact);
  functionaltest(all,"bignum_cld",test_bignum_cld);
  functionaltest(all,"bignum_clz",test_bignum_clz);
  functionaltest(all,"bignum_cmadd",test_bignum_cmadd);
  functionaltest(all,"bignum_cmnegadd",test_bignum_cmnegadd);
  functionaltest(all,"bignum_cmod",test_bignum_cmod);
  functionaltest(all,"bignum_cmul",test_bignum_cmul);
  functionaltest(bmi,"bignum_cmul_p25519",test_bignum_cmul_p25519);
  functionaltest(all,"bignum_cmul_p25519_alt",test_bignum_cmul_p25519_alt);
  functionaltest(bmi,"bignum_cmul_p256",test_bignum_cmul_p256);
  functionaltest(all,"bignum_cmul_p256_alt",test_bignum_cmul_p256_alt);
  functionaltest(bmi,"bignum_cmul_p256k1",test_bignum_cmul_p256k1);
  functionaltest(all,"bignum_cmul_p256k1_alt",test_bignum_cmul_p256k1_alt);
  functionaltest(bmi,"bignum_cmul_p384",test_bignum_cmul_p384);
  functionaltest(all,"bignum_cmul_p384_alt",test_bignum_cmul_p384_alt);
  functionaltest(bmi,"bignum_cmul_p521",test_bignum_cmul_p521);
  functionaltest(all,"bignum_cmul_p521_alt",test_bignum_cmul_p521_alt);
  functionaltest(bmi,"bignum_cmul_sm2",test_bignum_cmul_sm2);
  functionaltest(all,"bignum_cmul_sm2_alt",test_bignum_cmul_sm2_alt);
  functionaltest(all,"bignum_coprime",test_bignum_coprime);
  functionaltest(all,"bignum_copy",test_bignum_copy);
  functionaltest(all,"bignum_copy_row_from_table",test_bignum_copy_row_from_table);
  functionaltest(all,"bignum_ctd",test_bignum_ctd);
  functionaltest(all,"bignum_ctz",test_bignum_ctz);
  functionaltest(bmi,"bignum_deamont_p256",test_bignum_deamont_p256);
  functionaltest(all,"bignum_deamont_p256_alt",test_bignum_deamont_p256_alt);
  functionaltest(all,"bignum_deamont_p256k1",test_bignum_deamont_p256k1);
  functionaltest(bmi,"bignum_deamont_p384",test_bignum_deamont_p384);
  functionaltest(all,"bignum_deamont_p384_alt",test_bignum_deamont_p384_alt);
  functionaltest(all,"bignum_deamont_p521",test_bignum_deamont_p521);
  functionaltest(all,"bignum_deamont_sm2",test_bignum_deamont_sm2);
  functionaltest(all,"bignum_demont",test_bignum_demont);
  functionaltest(bmi,"bignum_demont_p256",test_bignum_demont_p256);
  functionaltest(all,"bignum_demont_p256_alt",test_bignum_demont_p256_alt);
  functionaltest(all,"bignum_demont_p256k1",test_bignum_demont_p256k1);
  functionaltest(bmi,"bignum_demont_p384",test_bignum_demont_p384);
  functionaltest(all,"bignum_demont_p384_alt",test_bignum_demont_p384_alt);
  functionaltest(all,"bignum_demont_p521",test_bignum_demont_p521);
  functionaltest(all,"bignum_demont_sm2",test_bignum_demont_sm2);
  functionaltest(all,"bignum_digit",test_bignum_digit);
  functionaltest(all,"bignum_digitsize",test_bignum_digitsize);
  functionaltest(all,"bignum_divmod10",test_bignum_divmod10);
  functionaltest(all,"bignum_double_p25519",test_bignum_double_p25519);
  functionaltest(all,"bignum_double_p256",test_bignum_double_p256);
  functionaltest(all,"bignum_double_p256k1",test_bignum_double_p256k1);
  functionaltest(all,"bignum_double_p384",test_bignum_double_p384);
  functionaltest(all,"bignum_double_p521",test_bignum_double_p521);
  functionaltest(all,"bignum_double_sm2",test_bignum_double_sm2);
  functionaltest(all,"bignum_emontredc",test_bignum_emontredc);
  functionaltest(bmi,"bignum_emontredc_8n",test_bignum_emontredc_8n);
  functionaltest(all,"bignum_eq",test_bignum_eq);
  functionaltest(all,"bignum_even",test_bignum_even);
  functionaltest(all,"bignum_frombebytes_4",test_bignum_frombebytes_4);
  functionaltest(all,"bignum_frombebytes_6",test_bignum_frombebytes_6);
  functionaltest(all,"bignum_fromlebytes_4",test_bignum_fromlebytes_4);
  functionaltest(all,"bignum_fromlebytes_6",test_bignum_fromlebytes_6);
  functionaltest(all,"bignum_fromlebytes_p521",test_bignum_fromlebytes_p521);
  functionaltest(all,"bignum_ge",test_bignum_ge);
  functionaltest(all,"bignum_gt",test_bignum_gt);
  functionaltest(all,"bignum_half_p256",test_bignum_half_p256);
  functionaltest(all,"bignum_half_p256k1",test_bignum_half_p256k1);
  functionaltest(all,"bignum_half_p384",test_bignum_half_p384);
  functionaltest(all,"bignum_half_p521",test_bignum_half_p521);
  functionaltest(all,"bignum_half_sm2",test_bignum_half_sm2);
  functionaltest(all,"bignum_inv_p25519",test_bignum_inv_p25519);
  functionaltest(all,"bignum_inv_p256",test_bignum_inv_p256);
  functionaltest(all,"bignum_inv_p384",test_bignum_inv_p384);
  functionaltest(all,"bignum_inv_p521",test_bignum_inv_p521);
  functionaltest(all,"bignum_inv_sm2",test_bignum_inv_sm2);
  functionaltest(bmi,"bignum_invsqrt_p25519",test_bignum_invsqrt_p25519);
  functionaltest(all,"bignum_invsqrt_p25519_alt",test_bignum_invsqrt_p25519_alt);
  functionaltest(all,"bignum_iszero",test_bignum_iszero);
  functionaltest(bmi,"bignum_kmul_16_32",test_bignum_kmul_16_32);
  functionaltest(bmi,"bignum_kmul_32_64", test_bignum_kmul_32_64);
  functionaltest(bmi,"bignum_ksqr_16_32",test_bignum_ksqr_16_32);
  functionaltest(bmi,"bignum_ksqr_32_64",test_bignum_ksqr_32_64);
  functionaltest(all,"bignum_le",test_bignum_le);
  functionaltest(all,"bignum_littleendian_4",test_bignum_littleendian_4);
  functionaltest(all,"bignum_littleendian_6",test_bignum_littleendian_6);
  functionaltest(all,"bignum_lt",test_bignum_lt);
  functionaltest(all,"bignum_madd",test_bignum_madd);
  functionaltest(bmi,"bignum_madd_n25519",test_bignum_madd_n25519);
  functionaltest(all,"bignum_madd_n25519_alt",test_bignum_madd_n25519_alt);
  functionaltest(all,"bignum_mod_m25519",test_bignum_mod_m25519);
  functionaltest(all,"bignum_mod_m25519_4",test_bignum_mod_m25519_4);
  functionaltest(all,"bignum_mod_n25519",test_bignum_mod_n25519);
  functionaltest(all,"bignum_mod_n25519_4",test_bignum_mod_n25519_4);
  functionaltest(bmi,"bignum_mod_n256",test_bignum_mod_n256);
  functionaltest(all,"bignum_mod_n256_4",test_bignum_mod_n256_4);
  functionaltest(all,"bignum_mod_n256_alt",test_bignum_mod_n256_alt);
  functionaltest(all,"bignum_mod_n256k1_4",test_bignum_mod_n256k1_4);
  functionaltest(bmi,"bignum_mod_n384",test_bignum_mod_n384);
  functionaltest(all,"bignum_mod_n384_6",test_bignum_mod_n384_6);
  functionaltest(all,"bignum_mod_n384_alt",test_bignum_mod_n384_alt);
  functionaltest(bmi,"bignum_mod_n521_9",test_bignum_mod_n521_9);
  functionaltest(all,"bignum_mod_n521_9_alt",test_bignum_mod_n521_9_alt);
  functionaltest(bmi,"bignum_mod_nsm2",test_bignum_mod_nsm2);
  functionaltest(all,"bignum_mod_nsm2_4",test_bignum_mod_nsm2_4);
  functionaltest(all,"bignum_mod_nsm2_alt",test_bignum_mod_nsm2_alt);
  functionaltest(all,"bignum_mod_p25519_4",test_bignum_mod_p25519_4);
  functionaltest(bmi,"bignum_mod_p256",test_bignum_mod_p256);
  functionaltest(all,"bignum_mod_p256_4",test_bignum_mod_p256_4);
  functionaltest(all,"bignum_mod_p256_alt",test_bignum_mod_p256_alt);
  functionaltest(all,"bignum_mod_p256k1_4",test_bignum_mod_p256k1_4);
  functionaltest(bmi,"bignum_mod_p384",test_bignum_mod_p384);
  functionaltest(all,"bignum_mod_p384_6",test_bignum_mod_p384_6);
  functionaltest(all,"bignum_mod_p384_alt",test_bignum_mod_p384_alt);
  functionaltest(all,"bignum_mod_p521_9",test_bignum_mod_p521_9);
  functionaltest(all,"bignum_mod_sm2",test_bignum_mod_sm2);
  functionaltest(all,"bignum_mod_sm2_4",test_bignum_mod_sm2_4);
  functionaltest(all,"bignum_modadd",test_bignum_modadd);
  functionaltest(all,"bignum_moddouble",test_bignum_moddouble);
  functionaltest(all,"bignum_modexp",test_bignum_modexp);
  functionaltest(all,"bignum_modifier",test_bignum_modifier);
  functionaltest(all,"bignum_modinv",test_bignum_modinv);
  functionaltest(all,"bignum_modoptneg",test_bignum_modoptneg);
  functionaltest(all,"bignum_modsub",test_bignum_modsub);
  functionaltest(all,"bignum_montifier",test_bignum_montifier);
  functionaltest(all,"bignum_montinv_p256",test_bignum_montinv_p256);
  functionaltest(all,"bignum_montinv_p384",test_bignum_montinv_p384);
  functionaltest(all,"bignum_montinv_sm2",test_bignum_montinv_sm2);
  functionaltest(all,"bignum_montmul",test_bignum_montmul);
  functionaltest(bmi,"bignum_montmul_p256",test_bignum_montmul_p256);
  functionaltest(all,"bignum_montmul_p256_alt",test_bignum_montmul_p256_alt);
  functionaltest(bmi,"bignum_montmul_p256k1",test_bignum_montmul_p256k1);
  functionaltest(all,"bignum_montmul_p256k1_alt",test_bignum_montmul_p256k1_alt);
  functionaltest(bmi,"bignum_montmul_p384",test_bignum_montmul_p384);
  functionaltest(all,"bignum_montmul_p384_alt",test_bignum_montmul_p384_alt);
  functionaltest(bmi,"bignum_montmul_p521",test_bignum_montmul_p521);
  functionaltest(all,"bignum_montmul_p521_alt",test_bignum_montmul_p521_alt);
  functionaltest(bmi,"bignum_montmul_sm2",test_bignum_montmul_sm2);
  functionaltest(all,"bignum_montmul_sm2_alt",test_bignum_montmul_sm2_alt);
  functionaltest(all,"bignum_montredc",test_bignum_montredc);
  functionaltest(all,"bignum_montsqr",test_bignum_montsqr);
  functionaltest(bmi,"bignum_montsqr_p256",test_bignum_montsqr_p256);
  functionaltest(all,"bignum_montsqr_p256_alt",test_bignum_montsqr_p256_alt);
  functionaltest(bmi,"bignum_montsqr_p256k1",test_bignum_montsqr_p256k1);
  functionaltest(all,"bignum_montsqr_p256k1_alt",test_bignum_montsqr_p256k1_alt);
  functionaltest(bmi,"bignum_montsqr_p384",test_bignum_montsqr_p384);
  functionaltest(all,"bignum_montsqr_p384_alt",test_bignum_montsqr_p384_alt);
  functionaltest(bmi,"bignum_montsqr_p521",test_bignum_montsqr_p521);
  functionaltest(all,"bignum_montsqr_p521_alt",test_bignum_montsqr_p521_alt);
  functionaltest(bmi,"bignum_montsqr_sm2",test_bignum_montsqr_sm2);
  functionaltest(all,"bignum_montsqr_sm2_alt",test_bignum_montsqr_sm2_alt);
  functionaltest(all,"bignum_mul",test_bignum_mul);
  functionaltest(bmi,"bignum_mul_4_8",test_bignum_mul_4_8);
  functionaltest(all,"bignum_mul_4_8_alt",test_bignum_mul_4_8_alt);
  functionaltest(bmi,"bignum_mul_6_12",test_bignum_mul_6_12);
  functionaltest(all,"bignum_mul_6_12_alt",test_bignum_mul_6_12_alt);
  functionaltest(bmi,"bignum_mul_8_16",test_bignum_mul_8_16);
  functionaltest(all,"bignum_mul_8_16_alt",test_bignum_mul_8_16_alt);
  functionaltest(bmi,"bignum_mul_p25519",test_bignum_mul_p25519);
  functionaltest(all,"bignum_mul_p25519_alt",test_bignum_mul_p25519_alt);
  functionaltest(bmi,"bignum_mul_p256k1",test_bignum_mul_p256k1);
  functionaltest(all,"bignum_mul_p256k1_alt",test_bignum_mul_p256k1_alt);
  functionaltest(bmi,"bignum_mul_p521",test_bignum_mul_p521);
  functionaltest(all,"bignum_mul_p521_alt",test_bignum_mul_p521_alt);
  functionaltest(all,"bignum_muladd10",test_bignum_muladd10);
  functionaltest(all,"bignum_mux",test_bignum_mux);
  functionaltest(all,"bignum_mux16",test_bignum_mux16);
  functionaltest(all,"bignum_mux_4",test_bignum_mux_4);
  functionaltest(all,"bignum_mux_6",test_bignum_mux_6);
  functionaltest(all,"bignum_neg_p25519",test_bignum_neg_p25519);
  functionaltest(all,"bignum_neg_p256",test_bignum_neg_p256);
  functionaltest(all,"bignum_neg_p256k1",test_bignum_neg_p256k1);
  functionaltest(all,"bignum_neg_p384",test_bignum_neg_p384);
  functionaltest(all,"bignum_neg_p521",test_bignum_neg_p521);
  functionaltest(all,"bignum_neg_sm2",test_bignum_neg_sm2);
  functionaltest(all,"bignum_negmodinv",test_bignum_negmodinv);
  functionaltest(all,"bignum_nonzero",test_bignum_nonzero);
  functionaltest(all,"bignum_nonzero_4",test_bignum_nonzero_4);
  functionaltest(all,"bignum_nonzero_6",test_bignum_nonzero_6);
  functionaltest(all,"bignum_normalize",test_bignum_normalize);
  functionaltest(all,"bignum_odd",test_bignum_odd);
  functionaltest(all,"bignum_of_word",test_bignum_of_word);
  functionaltest(all,"bignum_optadd",test_bignum_optadd);
  functionaltest(all,"bignum_optneg",test_bignum_optneg);
  functionaltest(all,"bignum_optneg_p25519",test_bignum_optneg_p25519);
  functionaltest(all,"bignum_optneg_p256",test_bignum_optneg_p256);
  functionaltest(all,"bignum_optneg_p256k1",test_bignum_optneg_p256k1);
  functionaltest(all,"bignum_optneg_p384",test_bignum_optneg_p384);
  functionaltest(all,"bignum_optneg_p521",test_bignum_optneg_p521);
  functionaltest(all,"bignum_optneg_sm2",test_bignum_optneg_sm2);
  functionaltest(all,"bignum_optsub",test_bignum_optsub);
  functionaltest(all,"bignum_optsubadd",test_bignum_optsubadd);
  functionaltest(all,"bignum_pow2",test_bignum_pow2);
  functionaltest(all,"bignum_shl_small",test_bignum_shl_small);
  functionaltest(all,"bignum_shr_small",test_bignum_shr_small);
  functionaltest(all,"bignum_sqr",test_bignum_sqr);
  functionaltest(bmi,"bignum_sqr_4_8",test_bignum_sqr_4_8);
  functionaltest(all,"bignum_sqr_4_8_alt",test_bignum_sqr_4_8_alt);
  functionaltest(bmi,"bignum_sqr_6_12",test_bignum_sqr_6_12);
  functionaltest(all,"bignum_sqr_6_12_alt",test_bignum_sqr_6_12_alt);
  functionaltest(bmi,"bignum_sqr_8_16",test_bignum_sqr_8_16);
  functionaltest(all,"bignum_sqr_8_16_alt",test_bignum_sqr_8_16_alt);
  functionaltest(bmi,"bignum_sqr_p25519",test_bignum_sqr_p25519);
  functionaltest(all,"bignum_sqr_p25519_alt",test_bignum_sqr_p25519_alt);
  functionaltest(bmi,"bignum_sqr_p256k1",test_bignum_sqr_p256k1);
  functionaltest(all,"bignum_sqr_p256k1_alt",test_bignum_sqr_p256k1_alt);
  functionaltest(bmi,"bignum_sqr_p521",test_bignum_sqr_p521);
  functionaltest(all,"bignum_sqr_p521_alt",test_bignum_sqr_p521_alt);
  functionaltest(bmi,"bignum_sqrt_p25519",test_bignum_sqrt_p25519);
  functionaltest(all,"bignum_sqrt_p25519_alt",test_bignum_sqrt_p25519_alt);
  functionaltest(all,"bignum_sub",test_bignum_sub);
  functionaltest(all,"bignum_sub_p25519",test_bignum_sub_p25519);
  functionaltest(all,"bignum_sub_p256",test_bignum_sub_p256);
  functionaltest(all,"bignum_sub_p256k1",test_bignum_sub_p256k1);
  functionaltest(all,"bignum_sub_p384",test_bignum_sub_p384);
  functionaltest(all,"bignum_sub_p521",test_bignum_sub_p521);
  functionaltest(all,"bignum_sub_sm2",test_bignum_sub_sm2);
  functionaltest(all,"bignum_tobebytes_4",test_bignum_tobebytes_4);
  functionaltest(all,"bignum_tobebytes_6",test_bignum_tobebytes_6);
  functionaltest(all,"bignum_tolebytes_4",test_bignum_tolebytes_4);
  functionaltest(all,"bignum_tolebytes_6",test_bignum_tolebytes_6);
  functionaltest(all,"bignum_tolebytes_p521",test_bignum_tolebytes_p521);
  functionaltest(bmi,"bignum_tomont_p256",test_bignum_tomont_p256);
  functionaltest(all,"bignum_tomont_p256_alt",test_bignum_tomont_p256_alt);
  functionaltest(bmi,"bignum_tomont_p256k1",test_bignum_tomont_p256k1);
  functionaltest(all,"bignum_tomont_p256k1_alt",test_bignum_tomont_p256k1_alt);
  functionaltest(bmi,"bignum_tomont_p384",test_bignum_tomont_p384);
  functionaltest(all,"bignum_tomont_p384_alt",test_bignum_tomont_p384_alt);
  functionaltest(all,"bignum_tomont_p521",test_bignum_tomont_p521);
  functionaltest(all,"bignum_tomont_sm2",test_bignum_tomont_sm2);
  functionaltest(bmi,"bignum_triple_p256",test_bignum_triple_p256);
  functionaltest(all,"bignum_triple_p256_alt",test_bignum_triple_p256_alt);
  functionaltest(bmi,"bignum_triple_p256k1",test_bignum_triple_p256k1);
  functionaltest(all,"bignum_triple_p256k1_alt",test_bignum_triple_p256k1_alt);
  functionaltest(bmi,"bignum_triple_p384",test_bignum_triple_p384);
  functionaltest(all,"bignum_triple_p384_alt",test_bignum_triple_p384_alt);
  functionaltest(bmi,"bignum_triple_p521",test_bignum_triple_p521);
  functionaltest(all,"bignum_triple_p521_alt",test_bignum_triple_p521_alt);
  functionaltest(bmi,"bignum_triple_sm2",test_bignum_triple_sm2);
  functionaltest(all,"bignum_triple_sm2_alt",test_bignum_triple_sm2_alt);
  functionaltest(bmi,"curve25519_ladderstep",test_curve25519_ladderstep);
  functionaltest(all,"curve25519_ladderstep_alt",test_curve25519_ladderstep_alt);
  functionaltest(bmi,"curve25519_pxscalarmul",test_curve25519_pxscalarmul);
  functionaltest(all,"curve25519_pxscalarmul_alt",test_curve25519_pxscalarmul_alt);
  functionaltest(bmi,"curve25519_x25519",test_curve25519_x25519);
  functionaltest(all,"curve25519_x25519_alt",test_curve25519_x25519_alt);
  functionaltest(bmi,"curve25519_x25519_byte",test_curve25519_x25519_byte);
  functionaltest(all,"curve25519_x25519_byte_alt",test_curve25519_x25519_byte_alt);
  functionaltest(bmi,"curve25519_x25519base",test_curve25519_x25519base);
  functionaltest(all,"curve25519_x25519base_alt",test_curve25519_x25519base_alt);
  functionaltest(bmi,"curve25519_x25519base_byte",test_curve25519_x25519base_byte);
  functionaltest(all,"curve25519_x25519base_byte_alt",test_curve25519_x25519base_byte_alt);
  functionaltest(bmi,"edwards25519_decode",test_edwards25519_decode);
  functionaltest(all,"edwards25519_decode_alt",test_edwards25519_decode_alt);
  functionaltest(all,"edwards25519_encode",test_edwards25519_encode);
  functionaltest(bmi,"edwards25519_epadd",test_edwards25519_epadd);
  functionaltest(all,"edwards25519_epadd_alt",test_edwards25519_epadd_alt);
  functionaltest(bmi,"edwards25519_epdouble",test_edwards25519_epdouble);
  functionaltest(all,"edwards25519_epdouble_alt",test_edwards25519_epdouble_alt);
  functionaltest(bmi,"edwards25519_pdouble",test_edwards25519_pdouble);
  functionaltest(all,"edwards25519_pdouble_alt",test_edwards25519_pdouble_alt);
  functionaltest(bmi,"edwards25519_pepadd",test_edwards25519_pepadd);
  functionaltest(all,"edwards25519_pepadd_alt",test_edwards25519_pepadd_alt);
  functionaltest(bmi,"edwards25519_scalarmulbase",test_edwards25519_scalarmulbase);
  functionaltest(all,"edwards25519_scalarmulbase_alt",test_edwards25519_scalarmulbase_alt);
  functionaltest(bmi,"edwards25519_scalarmuldouble",test_edwards25519_scalarmuldouble);
  functionaltest(all,"edwards25519_scalarmuldouble_alt",test_edwards25519_scalarmuldouble_alt);
  functionaltest(all,"mldsa_intt",test_mldsa_intt);
  functionaltest(all,"mldsa_ntt",test_mldsa_ntt);
  functionaltest(all,"mldsa_poly_reduce",test_mldsa_poly_reduce);
  functionaltest(all,"mlkem_basemul_k2",test_mlkem_basemul_k2);
  functionaltest(all,"mlkem_basemul_k3",test_mlkem_basemul_k3);
  functionaltest(all,"mlkem_basemul_k4",test_mlkem_basemul_k4);
  functionaltest(all,"mlkem_frombytes",test_mlkem_frombytes);
  functionaltest(all,"mlkem_intt",test_mlkem_intt);
  functionaltest(all,"mlkem_mulcache_compute",test_mlkem_mulcache_compute);
  functionaltest(all,"mlkem_ntt",test_mlkem_ntt);
  functionaltest(all,"mlkem_reduce",test_mlkem_reduce);
<<<<<<< HEAD
  functionaltest(all,"mlkem_rej_uniform_VARIABLE_TIME",test_mlkem_rej_uniform);
  functionaltest(all,"mlkem_tobytes",test_mlkem_tobytes);
  functionaltest(all,"mlkem_tomont",test_mlkem_tomont);
  functionaltest(all,"mlkem_unpack",test_mlkem_unpack);
=======
>>>>>>> 56f41495 (Added spec test to intt)
  functionaltest(bmi,"p256_montjadd",test_p256_montjadd);
  functionaltest(all,"p256_montjadd_alt",test_p256_montjadd_alt);
  functionaltest(bmi,"p256_montjdouble",test_p256_montjdouble);
  functionaltest(all,"p256_montjdouble_alt",test_p256_montjdouble_alt);
  functionaltest(bmi,"p256_montjmixadd",test_p256_montjmixadd);
  functionaltest(all,"p256_montjmixadd_alt",test_p256_montjmixadd_alt);
  functionaltest(bmi,"p256_montjscalarmul",test_p256_montjscalarmul);
  functionaltest(all,"p256_montjscalarmul_alt",test_p256_montjscalarmul_alt);
  functionaltest(bmi,"p256_scalarmul",test_p256_scalarmul);
  functionaltest(all,"p256_scalarmul_alt",test_p256_scalarmul_alt);
  functionaltest(bmi,"p256_scalarmulbase",test_p256_scalarmulbase);
  functionaltest(all,"p256_scalarmulbase_alt",test_p256_scalarmulbase_alt);
  functionaltest(bmi,"p384_montjadd",test_p384_montjadd);
  functionaltest(all,"p384_montjadd_alt",test_p384_montjadd_alt);
  functionaltest(bmi,"p384_montjdouble",test_p384_montjdouble);
  functionaltest(all,"p384_montjdouble_alt",test_p384_montjdouble_alt);
  functionaltest(bmi,"p384_montjmixadd",test_p384_montjmixadd);
  functionaltest(all,"p384_montjmixadd_alt",test_p384_montjmixadd_alt);
  functionaltest(bmi,"p384_montjscalarmul",test_p384_montjscalarmul);
  functionaltest(all,"p384_montjscalarmul_alt",test_p384_montjscalarmul_alt);
  functionaltest(bmi,"p521_jadd",test_p521_jadd);
  functionaltest(all,"p521_jadd_alt",test_p521_jadd_alt);
  functionaltest(bmi,"p521_jdouble",test_p521_jdouble);
  functionaltest(all,"p521_jdouble_alt",test_p521_jdouble_alt);
  functionaltest(bmi,"p521_jmixadd",test_p521_jmixadd);
  functionaltest(all,"p521_jmixadd_alt",test_p521_jmixadd_alt);
  functionaltest(bmi,"p521_jscalarmul",test_p521_jscalarmul);
  functionaltest(all,"p521_jscalarmul_alt",test_p521_jscalarmul_alt);
  functionaltest(bmi,"secp256k1_jadd",test_secp256k1_jadd);
  functionaltest(all,"secp256k1_jadd_alt",test_secp256k1_jadd_alt);
  functionaltest(bmi,"secp256k1_jdouble",test_secp256k1_jdouble);
  functionaltest(all,"secp256k1_jdouble_alt",test_secp256k1_jdouble_alt);
  functionaltest(bmi,"secp256k1_jmixadd",test_secp256k1_jmixadd);
  functionaltest(all,"secp256k1_jmixadd_alt",test_secp256k1_jmixadd_alt);
  functionaltest(all,"sha3_keccak_f1600",test_sha3_keccak_f1600);
  functionaltest(bmi,"sm2_montjadd",test_sm2_montjadd);
  functionaltest(all,"sm2_montjadd_alt",test_sm2_montjadd_alt);
  functionaltest(bmi,"sm2_montjdouble",test_sm2_montjdouble);
  functionaltest(all,"sm2_montjdouble_alt",test_sm2_montjdouble_alt);
  functionaltest(bmi,"sm2_montjmixadd",test_sm2_montjmixadd);
  functionaltest(all,"sm2_montjmixadd_alt",test_sm2_montjmixadd_alt);
  functionaltest(bmi,"sm2_montjscalarmul",test_sm2_montjscalarmul);
  functionaltest(all,"sm2_montjscalarmul_alt",test_sm2_montjscalarmul_alt);
  functionaltest(all,"word_bytereverse",test_word_bytereverse);
  functionaltest(all,"word_clz",test_word_clz);
  functionaltest(all,"word_ctz",test_word_ctz);
  functionaltest(all,"word_divstep59",test_word_divstep59);
  functionaltest(all,"word_max",test_word_max);
  functionaltest(all,"word_min",test_word_min);
  functionaltest(all,"word_negmodinv",test_word_negmodinv);
  functionaltest(all,"word_popcount",test_word_popcount);
  functionaltest(all,"word_recip",test_word_recip);

  if (get_arch_name() == ARCH_AARCH64) {
    functionaltest(all,"bignum_copy_row_from_table_8n",test_bignum_copy_row_from_table_8n);
    functionaltest(all,"bignum_copy_row_from_table_16",test_bignum_copy_row_from_table_16);
    functionaltest(all,"bignum_copy_row_from_table_32",test_bignum_copy_row_from_table_32);
    functionaltest(all,"bignum_emontredc_8n_cdiff",test_bignum_emontredc_8n_cdiff);
<<<<<<< HEAD
=======
    functionaltest(arm,"mlkem_mulcache_compute",test_mlkem_mulcache_compute);
    functionaltest(arm,"mlkem_tobytes",test_mlkem_tobytes);
    functionaltest(arm,"mlkem_tomont",test_mlkem_tomont);
    functionaltest(arm,"mlkem_rej_uniform_VARIABLE_TIME",test_mlkem_rej_uniform);
>>>>>>> 56f41495 (Added spec test to intt)
    functionaltest(sha3,"sha3_keccak_f1600_alt",test_sha3_keccak_f1600_alt);
    functionaltest(arm,"sha3_keccak_f1600_alt2",test_sha3_keccak_f1600_alt2);
    functionaltest(sha3,"sha3_keccak2_f1600",test_sha3_keccak2_f1600);
    functionaltest(sha3,"sha3_keccak2_f1600_alt",test_sha3_keccak2_f1600_alt);
    functionaltest(sha3,"sha3_keccak4_f1600",test_sha3_keccak4_f1600);
    functionaltest(arm,"sha3_keccak4_f1600_alt",test_sha3_keccak4_f1600_alt);
    functionaltest(sha3,"sha3_keccak4_f1600_alt2",test_sha3_keccak4_f1600_alt2);

  }

  if (extrastrigger) function_to_test = "_";

  functionaltest(bmi,"known value tests",test_known_values);

  functionaltest(bmi,"curve25519_x25519 (TweetNaCl)",test_curve25519_x25519_tweetnacl);
  functionaltest(all,"curve25519_x25519_alt (TweetNaCl)",test_curve25519_x25519_alt_tweetnacl);
  functionaltest(bmi,"curve25519_x25519_byte (TweetNaCl)",test_curve25519_x25519_byte_tweetnacl);
  functionaltest(all,"curve25519_x25519_byte+alt (TweetNaCl)",test_curve25519_x25519_byte_alt_tweetnacl);
  functionaltest(bmi,"curve25519_x25519base (TweetNaCl)",test_curve25519_x25519base_tweetnacl);
  functionaltest(all,"curve25519_x25519base_alt (TweetNaCl)",test_curve25519_x25519base_alt_tweetnacl);
  functionaltest(bmi,"curve25519_x25519base_byte (TweetNaCl)",test_curve25519_x25519base_byte_tweetnacl);
  functionaltest(all,"curve25519_x25519base_byte_alt (TweetNaCl)",test_curve25519_x25519base_byte_alt_tweetnacl);
  functionaltest(bmi,"edwards25519_scalarmulbase (TweetNaCl)",test_edwards25519_scalarmulbase_tweetnacl);
  functionaltest(all,"edwards25519_scalarmulbase_alt (TweetNaCl)",test_edwards25519_scalarmulbase_alt_tweetnacl);

  if (successes == tested)
   { printf("All %d tests run, all passed\n",successes);
     return 0;
   }

  if (successes + skipped == tested)
   { printf("Skipped %d but all %d selected tests passed\n",skipped,successes);
     return 1;
   }

  if (failures != 0) printf("***** FAILED %d tests\n",failures);
  else printf("Testing all passed but is incomplete\n");
  printf("                     Total operations to test = %3d\n",tested);
  printf("                                       Passed = %3d\n",successes);
  printf("                                      Failed  = %3d\n",failures);
  printf("         Skipped because not selected by user = %3d\n",skipped);
  printf("Skipped because inapplicable (no %s) = %3d\n",
         ((get_arch_name() == ARCH_AARCH64) ? "ARM sha3" : "x86 BMI/ADX"),inapplicable);
  return 1;
}
*/
